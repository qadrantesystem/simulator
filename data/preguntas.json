{
  "metadata": {
    "version": "1.0",
    "totalPreguntas": 90,
    "categorias": ["arquitectura", "reactivo", "resiliencia", "cloud", "data", "seguridad", "observabilidad", "liderazgo", "patrones", "azure", "fundamentos"]
  },
  "preguntas": [
    {
      "id": 1,
      "categoria": "arquitectura",
      "dificultad": "senior",
      "pregunta": "Si tuvieras que dise√±ar la arquitectura de APIs para una app tipo Yape (saldos, transferencias, pagos), ¬øc√≥mo la estructurar√≠as?",
      "respuesta": "<p>Usar√≠a <strong>3 capas de APIs</strong>:</p><ul><li><strong>API de Experiencia (BFF)</strong> - Es el MOZO. Orquesta llamadas, junta datos y entrega al cliente. Uso WebFlux.</li><li><strong>API de Negocio</strong> - Son las COCINAS especializadas. Un microservicio por dominio.</li><li><strong>API de Sincronizaci√≥n</strong> - El ALMAC√âN VIEJO. Conecta con el core bancario legacy.</li></ul><p>Regla de oro: <strong>NUNCA expones el negocio directamente</strong>.</p>",
      "analogia": "Es como una poller√≠a: el mozo (experiencia) atiende, las cocinas (negocio) preparan, el almac√©n (sincronizaci√≥n) tiene la materia prima.",
      "codigo": "@Bean\npublic RouteLocator routes(RouteLocatorBuilder builder) {\n    return builder.routes()\n        .route(\"saldos\", r -> r\n            .path(\"/api/saldos/**\")\n            .filters(f -> f.circuitBreaker(c -> c.setName(\"saldosCB\")))\n            .uri(\"lb://ms-saldos\"))\n        .build();\n}",
      "frase": "Las APIs de experiencia son el mozo, las de negocio son las cocinas, y las de sincronizaci√≥n van al almac√©n viejo."
    },
    {
      "id": 2,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "Expl√≠came la diferencia entre Arquitectura Hexagonal y Clean Architecture. ¬øCu√°ndo usar√≠as cada una?",
      "respuesta": "<p>Ambas separan negocio de infraestructura:</p><ul><li><strong>Hexagonal (Ports & Adapters)</strong> - Tu negocio es una ISLA. Los puertos son MUELLES donde llegan barcos (adaptadores).</li><li><strong>Clean Architecture</strong> - CAPAS DE CEBOLLA. Centro = negocio, capas externas dependen de internas.</li></ul><p><strong>Hexagonal:</strong> Muchas integraciones externas. <strong>Clean:</strong> Dominio muy complejo.</p>",
      "analogia": "Hexagonal es una isla con muelles para distintos barcos. Clean es una cebolla con capas que protegen el centro.",
      "codigo": "// Puerto (interface)\npublic interface CuentaRepository {\n    Mono<Cuenta> findById(String id);\n}\n\n// Adaptador MongoDB\n@Repository\npublic class CuentaMongoAdapter implements CuentaRepository {\n    public Mono<Cuenta> findById(String id) {\n        return mongoTemplate.findById(id, CuentaDocument.class)\n            .map(this::toDomain);\n    }\n}",
      "frase": "Hexagonal te permite cambiar de MongoDB a PostgreSQL sin tocar una l√≠nea del negocio."
    },
    {
      "id": 3,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es CQRS y cu√°ndo lo aplicar√≠as en un sistema bancario?",
      "respuesta": "<p>CQRS = DOS PIZARRAS:</p><ul><li><strong>Command (Escritura)</strong> - Operaciones complejas, validaciones. PostgreSQL normalizado.</li><li><strong>Query (Lectura)</strong> - Optimizada para mostrar. MongoDB/Redis desnormalizado.</li></ul><p><strong>Usar cuando:</strong> Lees mucho m√°s de lo que escribes (80/20). Historial de movimientos en Yape.</p>",
      "analogia": "Dos pizarras: una para escribir con calma (validaciones) y otra para leer volando (optimizada).",
      "codigo": "// Command - Escribir\npublic Mono<Void> transferir(TransferenciaCmd cmd) {\n    return cuentaRepo.findById(cmd.getOrigen())\n        .flatMap(cuenta -> cuenta.debitar(cmd.getMonto()))\n        .then(eventPublisher.publish(new TransferenciaEvent(cmd)));\n}\n\n// Query - Leer\npublic Flux<MovimientoDTO> getMovimientos(String cuentaId) {\n    return movimientoReadRepo.findByCuentaId(cuentaId);\n}",
      "frase": "Con CQRS, cuando abres Yape la consulta vuela porque va a una base optimizada solo para leer."
    },
    {
      "id": 4,
      "categoria": "arquitectura",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es Event Sourcing y por qu√© es importante en banca?",
      "respuesta": "<p>Guardar TODO lo que pas√≥, no solo el estado actual:</p><ul><li><strong>Sin ES:</strong> Solo s√© que tienes S/1,500.</li><li><strong>Con ES:</strong> Guardo CADA movimiento y puedo reconstruir el saldo.</li></ul><p><strong>En banca:</strong> Auditor√≠a SBS, viaje en el tiempo, detecci√≥n de fraudes, replay de eventos.</p>",
      "analogia": "No solo s√© que tienes S/1,500, s√© EXACTAMENTE c√≥mo llegaste ah√≠ con cada movimiento.",
      "codigo": "public record TransferenciaRealizada(\n    String id, String origen, String destino,\n    BigDecimal monto, Instant timestamp\n) {}\n\npublic Cuenta reconstruir(String cuentaId) {\n    return eventStore.getEvents(cuentaId)\n        .reduce(Cuenta.vacia(), Cuenta::aplicarEvento);\n}",
      "frase": "En banca, Event Sourcing no es opcional. Los reguladores te piden trazabilidad completa."
    },
    {
      "id": 5,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo manejas transacciones distribuidas entre microservicios? Ejemplo: transferencia interbancaria.",
      "respuesta": "<p>En microservicios NO usas ACID tradicional. Usas <strong>SAGA</strong>:</p><ul><li>CTRL+Z para cada paso. Si falla paso 4, deshago 3, 2, 1.</li><li><strong>Orquestada:</strong> Un director controla todo.</li><li><strong>Coreografiada:</strong> Cada servicio reacciona a eventos.</li></ul>",
      "analogia": "SAGA es como comprar en cuotas: si falla el paso 4, te desbloquean el monto y eliminan las cuotas.",
      "codigo": "@Service\npublic class TransferenciaOrquestador {\n    public Mono<Void> ejecutar(TransferenciaCmd cmd) {\n        return validarSaldo(cmd)\n            .then(debitarOrigen(cmd))\n            .then(llamarBancoDestino(cmd))\n            .onErrorResume(e -> compensar(cmd, e));\n    }\n    \n    private Mono<Void> compensar(TransferenciaCmd cmd, Throwable e) {\n        return revertirDebito(cmd)\n            .then(notificarUsuario(cmd, \"Fallido\"));\n    }\n}",
      "frase": "En microservicios no hay transacciones m√°gicas. SAGA es tu CTRL+Z distribuido."
    },
    {
      "id": 6,
      "categoria": "reactivo",
      "dificultad": "senior",
      "pregunta": "¬øPor qu√© usar√≠as programaci√≥n reactiva en Yape? Expl√≠calo para el Gerente de Producto.",
      "respuesta": "<p><strong>TRADICIONAL:</strong> Pollo a la brasa - te quedas PARADO esperando 20 min. 1000 clientes = 1000 cajas.</p><p><strong>REACTIVO:</strong> Food court con BEEPER - pides, te dan beeper, te sientas. Te avisan cuando est√° listo.</p><p><strong>Beneficio:</strong> 100,000 usuarios con 10 servidores (reactivo) vs 100 servidores (tradicional). <strong>90% ahorro.</strong></p>",
      "analogia": "Reactivo es el food court con beeper: no te quedas parado esperando, te avisan cuando est√° listo.",
      "codigo": "// Tradicional - BLOQUEANTE\npublic Saldo getSaldo(String id) {\n    return repository.findById(id); // Hilo BLOQUEADO\n}\n\n// Reactivo - NO BLOQUEANTE\npublic Mono<Saldo> getSaldo(String id) {\n    return repository.findById(id); // Hilo LIBRE\n}",
      "frase": "Reactivo = menos plata en servidores, m√°s clientes atendidos. En hora punta, es caerse o seguir funcionando."
    },
    {
      "id": 7,
      "categoria": "reactivo",
      "dificultad": "senior",
      "pregunta": "¬øCu√°l es la diferencia entre Mono y Flux? Dame ejemplos en Yape.",
      "respuesta": "<p><strong>MONO = Un paquete.</strong> Yapear S/50 = UNA respuesta (√©xito o fall√≥).</p><p><strong>FLUX = Muchos paquetes (streaming).</strong> Ver movimientos = MUCHOS llegan, como suscripci√≥n mensual.</p><p><strong>Ejemplos:</strong> Mono<TransferenciaResponse>, Mono<Saldo>, Flux<Movimiento>, Flux<Notificacion>.</p>",
      "analogia": "Mono es un delivery √∫nico. Flux es una suscripci√≥n donde siguen llegando paquetes.",
      "codigo": "// MONO - Una respuesta\npublic Mono<TransferenciaResponse> yapear(YapeRequest req) {\n    return validar(req)\n        .flatMap(this::ejecutar)\n        .map(this::construirResponse);\n}\n\n// FLUX - Stream\npublic Flux<Movimiento> getMovimientos(String cuentaId) {\n    return movimientoRepo.findByCuentaId(cuentaId).take(50);\n}",
      "frase": "Mono para yapear (una respuesta). Flux para movimientos (stream de datos)."
    },
    {
      "id": 8,
      "categoria": "reactivo",
      "dificultad": "lead",
      "pregunta": "¬øCu√°l es la diferencia entre map y flatMap en programaci√≥n reactiva?",
      "respuesta": "<p><strong>MAP:</strong> Transformas el valor directamente. Naranja ‚Üí jugo. S√≠ncrono.</p><p><strong>FLATMAP:</strong> Tu transformaci√≥n retorna otro Mono/Flux. Aplanas para evitar Mono<Mono<T>>.</p><p><strong>Regla:</strong> ¬øRetorna valor normal? ‚Üí MAP. ¬øRetorna Mono/Flux? ‚Üí FLATMAP.</p>",
      "analogia": "Map es agregarle queso a la pizza. FlatMap es cuando tu pizza trae otra pizza y abres ambas cajas.",
      "codigo": "// MAP - valor directo\nMono<String> nombre = usuarioMono\n    .map(u -> u.getNombre());\n\n// FLATMAP - retorna Mono\nMono<Cuenta> cuenta = usuarioMono\n    .flatMap(u -> cuentaRepo.findByUsuarioId(u.getId()));",
      "frase": "Map para transformar datos, flatMap para llamar otros servicios reactivos."
    },
    {
      "id": 9,
      "categoria": "reactivo",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es backpressure y c√≥mo lo manejas cuando Kafka produce m√°s eventos de los que puedes procesar?",
      "respuesta": "<p>Backpressure = el MOZO le dice a la COCINA: ¬°PARA! No me doy abasto.</p><p><strong>Sin backpressure:</strong> Memoria llena ‚Üí OutOfMemory ‚Üí üíÄ</p><p><strong>Estrategias:</strong> Buffer (cola limitada), Drop (descartar), Latest (solo el reciente), Error (fallar si saturan).</p>",
      "analogia": "El mozo dici√©ndole a la cocina: 'Para, no me doy abasto con tantos platos'.",
      "codigo": "Flux.fromIterable(eventos)\n    .onBackpressureBuffer(1000)\n    .onBackpressureDrop(e -> log.warn(\"Descartado: {}\", e))\n    .flatMap(this::procesar, 10) // Max 10 paralelo\n    .subscribe();",
      "frase": "Sin backpressure, Kafka te ahoga. Con backpressure, t√∫ controlas cu√°ntos puedes masticar."
    },
    {
      "id": 10,
      "categoria": "reactivo",
      "dificultad": "senior",
      "pregunta": "¬øDiferencia entre RxJava y Project Reactor? ¬øCu√°ndo usar cada uno?",
      "respuesta": "<p><strong>RxJava:</strong> Single, Maybe, Observable, Flowable, Completable. Naci√≥ para Android.</p><p><strong>Reactor:</strong> Mono, Flux. Naci√≥ para Spring. Integraci√≥n nativa con WebFlux.</p><p><strong>Usar:</strong> RxJava para Android/legacy. Reactor para Spring/proyectos nuevos.</p>",
      "analogia": "RxJava tiene muchos tipos de vasos. Reactor es m√°s simple: vaso chico (Mono) y vaso grande (Flux).",
      "codigo": "// RxJava\nSingle<Usuario> usuario = Single.just(new Usuario());\nMaybe<Cuenta> cuenta = Maybe.empty();\nFlowable<Evento> eventos = Flowable.fromIterable(lista);\n\n// Reactor\nMono<Usuario> usuario = Mono.just(new Usuario());\nFlux<Evento> eventos = Flux.fromIterable(lista);",
      "frase": "Si tu stack es Spring, usa Reactor. No mezcles ambos en el mismo proyecto."
    },
    {
      "id": 11,
      "categoria": "resiliencia",
      "dificultad": "senior",
      "pregunta": "El servicio de pago de luz en Yape est√° lento o ca√≠do. ¬øC√≥mo evitas que se caiga toda la app?",
      "respuesta": "<p>Patrones de resiliencia con Resilience4j:</p><ul><li><strong>Circuit Breaker:</strong> Fusible - 5 fallas seguidas, abro circuito.</li><li><strong>Timeout:</strong> 5 segundos m√°ximo, corto.</li><li><strong>Retry:</strong> 3 intentos con backoff (1s, 2s, 4s).</li><li><strong>Fallback:</strong> Cache o mensaje 'No disponible'.</li><li><strong>Bulkhead:</strong> Pool separado, no afecta otros servicios.</li></ul>",
      "analogia": "Circuit Breaker es el fusible de tu casa: si hay cortocircuito, corta para que no se queme todo.",
      "codigo": "@CircuitBreaker(name = \"servicioLuz\", fallbackMethod = \"fallback\")\n@Retry(name = \"servicioLuz\")\n@TimeLimiter(name = \"servicioLuz\")\npublic Mono<DeudaDTO> consultarDeuda(String suministro) {\n    return webClient.get()\n        .uri(\"/deudas/{s}\", suministro)\n        .retrieve()\n        .bodyToMono(DeudaDTO.class);\n}\n\npublic Mono<DeudaDTO> fallback(String s, Throwable t) {\n    return cacheService.getUltimaDeuda(s);\n}",
      "frase": "Dise√±a para el FALLO, no para el √©xito. Tu app no debe caerse con el servicio externo."
    },
    {
      "id": 12,
      "categoria": "resiliencia",
      "dificultad": "lead",
      "pregunta": "Expl√≠came los estados del Circuit Breaker y c√≥mo configurar√≠as umbrales para pagos.",
      "respuesta": "<p><strong>3 estados:</strong></p><ul><li><strong>CLOSED:</strong> Normal, requests pasan, cuento fallas.</li><li><strong>OPEN:</strong> Muchas fallas, cort√©. Requests fallan inmediato.</li><li><strong>HALF-OPEN:</strong> Probando si se recuper√≥.</li></ul><p><strong>Config pagos:</strong> 50% fallas abre, 30s espera, 3 requests de prueba, ventana de 10.</p>",
      "analogia": "Fusible: CERRADO = corriente pasa. ABIERTO = cort√≥. SEMI-ABIERTO = probando si ya se arregl√≥.",
      "codigo": "resilience4j:\n  circuitbreaker:\n    instances:\n      servicioPagos:\n        failureRateThreshold: 50\n        waitDurationInOpenState: 30s\n        permittedNumberOfCallsInHalfOpenState: 3\n        slidingWindowSize: 10\n        slowCallRateThreshold: 80\n        slowCallDurationThreshold: 3s",
      "frase": "Circuit Breaker mal configurado es peor que no tener. Muy sensible = se abre por nada. Muy tolerante = no protege."
    },
    {
      "id": 13,
      "categoria": "resiliencia",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es el patr√≥n Bulkhead y c√≥mo lo aplicar√≠as en banca?",
      "respuesta": "<p>Bulkhead = compartimentos de un BARCO. Si uno se inunda, los dem√°s no se hunden.</p><p><strong>En Yape:</strong> Pool saldos: 20 hilos. Pool transferencias: 30 hilos. Pool pagos: 15 hilos. Si pagos se satura, saldos sigue funcionando.</p>",
      "analogia": "Compartimentos del barco: si uno se inunda, los dem√°s siguen a flote.",
      "codigo": "@Bulkhead(name = \"pagoServicios\", type = Bulkhead.Type.THREADPOOL)\npublic Mono<PagoResponse> pagarServicio(PagoRequest req) {\n    return servicioExternoClient.pagar(req);\n}\n\n# Config\nresilience4j.bulkhead.instances.pagoServicios:\n  maxConcurrentCalls: 15\n  maxWaitDuration: 500ms",
      "frase": "Sin Bulkhead, un servicio lento consume todos los hilos y tumba toda la app."
    },
    {
      "id": 14,
      "categoria": "cloud",
      "dificultad": "senior",
      "pregunta": "¬øC√≥mo dise√±ar√≠as un pipeline CI/CD para microservicios bancarios?",
      "respuesta": "<p>Pipeline seguro y auditable:</p><ul><li><strong>Build & Test:</strong> Compilar, unit tests, cobertura 80%.</li><li><strong>Security:</strong> SonarQube (SAST), Snyk (deps), Trivy (container).</li><li><strong>Build Image:</strong> Docker, tag sem√°ntico.</li><li><strong>Deploy DEV:</strong> Autom√°tico.</li><li><strong>Deploy QA:</strong> Aprobaci√≥n manual.</li><li><strong>Deploy PROD:</strong> Doble aprobaci√≥n + Blue-Green.</li></ul>",
      "analogia": "L√≠nea de producci√≥n de autos: cada estaci√≥n verifica algo, si falla una inspecci√≥n, el auto no sale.",
      "codigo": "name: CI/CD Pipeline\non: [push]\njobs:\n  build-test:\n    steps:\n      - run: ./gradlew build test\n      - run: ./gradlew sonarqube\n      - uses: snyk/actions/gradle@master\n  \n  deploy-prod:\n    needs: build-test\n    environment: production\n    steps:\n      - run: ./scripts/blue-green-deploy.sh",
      "frase": "En banca, el pipeline es tu primera l√≠nea de defensa. Si pasa, deber√≠a ser seguro para producci√≥n."
    },
    {
      "id": 15,
      "categoria": "cloud",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo gestionas secretos en microservicios desplegados en Kubernetes?",
      "respuesta": "<p>NUNCA secretos en c√≥digo. Usar:</p><ul><li><strong>Azure Key Vault / AWS Secrets Manager / Vault:</strong> Almac√©n centralizado con rotaci√≥n.</li><li><strong>External Secrets Operator:</strong> Sincroniza del Vault a K8s.</li><li><strong>Workload Identity:</strong> Pod se autentica sin credenciales hardcodeadas.</li></ul>",
      "analogia": "Secretos son llaves de la b√≥veda: no las dejas pegadas en la puerta. Las guardas en caja fuerte.",
      "codigo": "apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: db-credentials\nspec:\n  refreshInterval: 1h\n  secretStoreRef:\n    name: azure-keyvault\n  data:\n    - secretKey: password\n      remoteRef:\n        key: db-password",
      "frase": "Secreto hardcodeado en c√≥digo = red flag. En banca, puede costarte la certificaci√≥n PCI-DSS."
    },
    {
      "id": 16,
      "categoria": "cloud",
      "dificultad": "senior",
      "pregunta": "¬øDiferencia entre HPA y VPA en Kubernetes? ¬øCu√°ndo usar cada uno?",
      "respuesta": "<p><strong>HPA (Horizontal):</strong> Agrega M√ÅS pods. Abrir m√°s cajas en el banco.</p><p><strong>VPA (Vertical):</strong> Hace cada pod M√ÅS POTENTE. Poner cajero m√°s r√°pido.</p><p><strong>Usar:</strong> HPA para microservicios stateless (mayor√≠a). VPA para apps que no escalan horizontal (BD).</p>",
      "analogia": "HPA = abrir m√°s cajas. VPA = poner cajero m√°s r√°pido. En banca digital, casi siempre queremos m√°s cajas.",
      "codigo": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: ms-transferencias\nspec:\n  scaleTargetRef:\n    kind: Deployment\n    name: ms-transferencias\n  minReplicas: 3\n  maxReplicas: 20\n  metrics:\n    - type: Resource\n      resource:\n        name: cpu\n        target:\n          averageUtilization: 70",
      "frase": "En hora punta, HPA escala de 3 a 15 pods autom√°ticamente. Pagas solo lo que usas."
    },
    {
      "id": 17,
      "categoria": "data",
      "dificultad": "senior",
      "pregunta": "¬øCu√°ndo usar√≠as Redis en arquitectura bancaria y qu√© patrones implementar√≠as?",
      "respuesta": "<p>Redis = memoria de corto plazo s√∫per r√°pida:</p><ul><li><strong>Cache saldos:</strong> Consulta instant√°nea, TTL 30s.</li><li><strong>Rate Limiting:</strong> M√°x 100 consultas/usuario/minuto.</li><li><strong>Sesiones:</strong> Tokens distribuidos entre pods.</li><li><strong>Locks distribuidos:</strong> Evitar doble procesamiento.</li></ul><p><strong>Patrones:</strong> Cache-Aside (busco cache, si no BD), Write-Through.</p>",
      "analogia": "Redis es memoria de trabajo: guardas lo que necesitas r√°pido, lo importante est√° en el disco (BD).",
      "codigo": "@Cacheable(value = \"saldos\", key = \"#cuentaId\")\npublic Mono<Saldo> getSaldo(String cuentaId) {\n    return saldoRepository.findByCuentaId(cuentaId);\n}\n\n@CacheEvict(value = \"saldos\", key = \"#cuentaId\")\npublic Mono<Void> actualizarSaldo(String cuentaId, BigDecimal nuevo) {\n    return saldoRepository.actualizar(cuentaId, nuevo);\n}",
      "frase": "Sin Redis, cada consulta va a BD. Con Redis, 90% se responden en milisegundos desde memoria."
    },
    {
      "id": 18,
      "categoria": "data",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo garantizas el orden de mensajes en Kafka para transacciones bancarias?",
      "respuesta": "<p>Orden garantizado SOLO dentro de una partici√≥n:</p><ul><li><strong>Partition Key = ID cuenta:</strong> Todas las tx de misma cuenta ‚Üí misma partici√≥n ‚Üí orden.</li><li><strong>Un consumer por partici√≥n:</strong> 10 particiones = m√°x 10 consumers.</li><li><strong>Idempotencia:</strong> Si reprocesa, no duplica.</li></ul><p><strong>Config:</strong> acks=all, enable.idempotence=true.</p>",
      "analogia": "Kafka es filas del banco: cada fila (partici√≥n) mantiene su orden. Tu DNI (cuenta) define tu fila.",
      "codigo": "// Productor con partition key\npublic Mono<Void> publicarTransaccion(Transaccion tx) {\n    return Mono.fromFuture(\n        kafkaTemplate.send(\"transacciones\",\n            tx.getCuentaId(),  // Partition key\n            tx)\n        .toCompletableFuture()\n    ).then();\n}",
      "frase": "En Kafka, orden es por partici√≥n. Usa ID de cuenta como partition key para orden garantizado."
    },
    {
      "id": 19,
      "categoria": "seguridad",
      "dificultad": "senior",
      "pregunta": "¬øCu√°les son las vulnerabilidades OWASP Top 10 m√°s comunes en APIs bancarias?",
      "respuesta": "<p>Las m√°s comunes:</p><ul><li><strong>A01 Broken Access Control:</strong> Usuario accede a datos de otro. Validar ownership.</li><li><strong>A02 Cryptographic Failures:</strong> Datos sin encriptar. TLS 1.3, no loggear PII.</li><li><strong>A03 Injection:</strong> SQL injection. Queries parametrizados.</li><li><strong>A07 Security Misconfiguration:</strong> Headers faltantes, errores verbosos.</li></ul><p><strong>Herramientas:</strong> SonarQube (SAST), OWASP ZAP (DAST), Snyk.</p>",
      "analogia": "OWASP es checklist de seguridad del banco: cerraduras (auth), c√°maras (logging), b√≥veda (cifrado).",
      "codigo": "// MAL - Broken Access Control\n@GetMapping(\"/cuentas/{id}\")\npublic Mono<Cuenta> getCuenta(@PathVariable String id) {\n    return cuentaRepo.findById(id); // Cualquiera accede!\n}\n\n// BIEN\n@GetMapping(\"/cuentas/{id}\")\npublic Mono<Cuenta> getCuenta(@PathVariable String id, Principal p) {\n    return cuentaRepo.findById(id)\n        .filter(c -> c.getUsuarioId().equals(p.getName()))\n        .switchIfEmpty(Mono.error(new AccessDeniedException(\"No\")));\n}",
      "frase": "Vulnerabilidad OWASP en banca no es solo bug, es riesgo regulatorio. La SBS puede multarte."
    },
    {
      "id": 20,
      "categoria": "seguridad",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementas estrategia de testing completa para microservicios bancarios?",
      "respuesta": "<p>Pir√°mide de testing:</p><ul><li><strong>Unit (70%):</strong> L√≥gica aislada, mocks, cobertura 80%.</li><li><strong>Integration (20%):</strong> BD real (Testcontainers), APIs mockeadas (WireMock).</li><li><strong>E2E (10%):</strong> Flujos cr√≠ticos completos.</li></ul><p><strong>Adicional:</strong> Contract (Pact), Performance (Gatling), Chaos, Security (SAST/DAST).</p>",
      "analogia": "Control de calidad en f√°brica: unit revisa piezas, integration el ensamblaje, E2E el producto final.",
      "codigo": "// Unit Test\n@Test\nvoid debeRechazarSinSaldo() {\n    when(cuentaRepo.findById(\"123\")).thenReturn(Mono.just(cuentaSaldo0));\n    StepVerifier.create(service.transferir(cmd))\n        .expectError(SaldoInsuficienteException.class)\n        .verify();\n}\n\n// Integration con Testcontainers\n@Testcontainers\nclass TransferenciaIT {\n    @Container\n    static PostgreSQLContainer<?> pg = new PostgreSQLContainer<>(\"postgres:15\");\n}",
      "frase": "Bug en producci√≥n puede costar millones. Invertir en testing es m√°s barato que transferencia duplicada."
    },
    {
      "id": 21,
      "categoria": "observabilidad",
      "dificultad": "senior",
      "pregunta": "¬øC√≥mo implementas los 3 pilares de observabilidad (logs, m√©tricas, traces)?",
      "respuesta": "<p><strong>LOGS:</strong> Qu√© pas√≥. JSON estructurado, correlation ID. ELK/CloudWatch.</p><p><strong>M√âTRICAS:</strong> Cu√°nto pas√≥. Latencia, throughput, errores. Prometheus + Grafana.</p><p><strong>TRACES:</strong> C√≥mo pas√≥. Flujo del request. Jaeger/Zipkin + OpenTelemetry.</p><p><strong>Correlation ID:</strong> Un ID √∫nico que se propaga a TODOS los servicios.</p>",
      "analogia": "Investigar crimen: logs son testimonios, m√©tricas son estad√≠sticas del barrio, traces son c√°maras de seguridad.",
      "codigo": "@Component\npublic class CorrelationIdFilter implements WebFilter {\n    public Mono<Void> filter(ServerWebExchange ex, WebFilterChain chain) {\n        String corrId = ex.getRequest().getHeaders()\n            .getFirst(\"X-Correlation-ID\");\n        if (corrId == null) corrId = UUID.randomUUID().toString();\n        return chain.filter(ex)\n            .contextWrite(ctx -> ctx.put(\"correlationId\", corrId));\n    }\n}",
      "frase": "Sin observabilidad, debuggear microservicios es buscar aguja en pajar. Con correlation ID, sigues un hilo rojo."
    },
    {
      "id": 22,
      "categoria": "observabilidad",
      "dificultad": "lead",
      "pregunta": "¬øQu√© m√©tricas RED y USE monitorear√≠as para servicio de transferencias?",
      "respuesta": "<p><strong>RED (servicios):</strong></p><ul><li><strong>Rate:</strong> Requests/seg. Alerta: >2000 o <100.</li><li><strong>Errors:</strong> % errores. Normal <1%, alerta >5%.</li><li><strong>Duration:</strong> Latencia p95. Normal <200ms, alerta >500ms.</li></ul><p><strong>USE (recursos):</strong> Utilization >80%, Saturation (queue >100), Errors.</p>",
      "analogia": "RED es tablero del auto: velocidad, warnings, temperatura. USE es revisar el motor.",
      "codigo": "groups:\n  - name: transferencias\n    rules:\n      - alert: AltaLatencia\n        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{service=\"ms-transferencias\"}[5m])) > 0.5\n        for: 2m\n        labels:\n          severity: warning\n      \n      - alert: AltaTasaErrores\n        expr: rate(http_requests_total{status=~\"5..\"}[5m]) / rate(http_requests_total[5m]) > 0.05\n        for: 1m\n        labels:\n          severity: critical",
      "frase": "RED dice si usuarios est√°n felices. USE dice si infraestructura est√° sufriendo. Necesitas ambas."
    },
    {
      "id": 23,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Un developer senior no sigue est√°ndares y hace todo a su manera. ¬øC√≥mo manejas la situaci√≥n?",
      "respuesta": "<p>NO confrontar p√∫blicamente:</p><ul><li><strong>1. Conversaci√≥n 1 a 1:</strong> 'Axel, veo oportunidad de alto impacto.'</li><li><strong>2. Involucrarlo:</strong> '¬øCreamos p√≠ldoras de conocimiento juntos?'</li><li><strong>3. Darle ownership:</strong> Responsable de est√°ndares de su √°rea.</li><li><strong>4. Reconocimiento p√∫blico:</strong> 'Gracias a Axel tenemos gu√≠as que todos usan.'</li></ul><p><strong>Clave:</strong> Canalizar experiencia hacia el bien del equipo.</p>",
      "analogia": "Senior rebelde es l√≠der sin direcci√≥n. Mi trabajo es darle direcci√≥n. No cambio personas, canalizo talentos.",
      "codigo": null,
      "frase": "Ya no quiero ser el mejor developer. Quiero ser el l√≠der del mejor equipo de developers."
    },
    {
      "id": 24,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Est√°s en medio del sprint y llega un pedido urgente no planificado. ¬øQu√© haces?",
      "respuesta": "<p>Proceso para urgencias:</p><ul><li><strong>1. Evaluar:</strong> ¬øEs urgente o solo importante? ¬øQui√©n pide y por qu√©?</li><li><strong>2. Negociar scope:</strong> 'Podemos hacerlo, pero sacamos X del sprint.'</li><li><strong>3. Transparencia:</strong> Explicar al equipo el cambio y el porqu√©.</li><li><strong>4. Proteger:</strong> Si es muy disruptivo, negociar para siguiente sprint.</li><li><strong>5. Documentar:</strong> Para la retro.</li></ul>",
      "analogia": "Sprint es un vuelo: ya despegaste con cierta carga. Si metes m√°s equipaje, algo tiene que salir.",
      "codigo": null,
      "frase": "Mi trabajo es ser el escudo del equipo. Filtro urgencias falsas y solo dejo pasar las que importan."
    },
    {
      "id": 25,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo haces code reviews efectivos sin desmotivar al equipo?",
      "respuesta": "<p>Principios:</p><ul><li><strong>1. Criticar c√≥digo, no persona:</strong> 'Este m√©todo podr√≠a...' vs 'Hiciste mal...'</li><li><strong>2. Preguntar, no afirmar:</strong> '¬øConsideraste usar X?'</li><li><strong>3. Explicar el porqu√©:</strong> 'Esto puede causar memory leak porque...'</li><li><strong>4. Reconocer lo bueno:</strong> Si algo est√° bien, decirlo.</li><li><strong>5. Ser oportuno:</strong> Review en 24h.</li></ul>",
      "analogia": "Code review es ser coach: se√±alas jugadas a mejorar pero celebras los goles. Solo criticar mata motivaci√≥n.",
      "codigo": "// MAL\n\"Esto est√° mal. Deber√≠as saber que no se hace as√≠.\"\n\n// BIEN\n\"¬øQu√© te parece extraer este bloque a un m√©todo privado?\nMejorar√≠a legibilidad y facilitar√≠a testearlo.\n\nprivate Mono<Saldo> validarSaldo(Cuenta cuenta) {\n    // l√≥gica\n}\n\n¬øQu√© opinas?\"",
      "frase": "Buen code review ense√±a. Mal code review humilla. La diferencia est√° en c√≥mo formulas el feedback."
    },
    {
      "id": 26,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "¬øPor qu√© quieres ser Technical Leader y no seguir como Developer Senior?",
      "respuesta": "<p>Motivaci√≥n:</p><ul><li><strong>Multiplicar impacto:</strong> Un developer escribe X l√≠neas. Un l√≠der que forma 5 developers multiplica por 5.</li><li><strong>Del singular al plural:</strong> No es 'lo que yo hice', es 'lo que CONSTRUIMOS'.</li><li><strong>Madurez:</strong> Ya recib√≠ premios. Ahora quiero que mi equipo los reciba.</li><li><strong>Visi√≥n:</strong> El c√≥digo es legacy ma√±ana. La cultura t√©cnica perdura.</li></ul>",
      "analogia": "Pasar de jugador estrella a entrenador: ya no metes los goles, pero entrenas al equipo que mete m√°s que nunca.",
      "codigo": null,
      "frase": "Ya recib√≠ palmadas en la espalda. Lleg√≥ el momento de conducir a personas que crean cosas maravillosas."
    },
    {
      "id": 27,
      "categoria": "liderazgo",
      "dificultad": "senior",
      "pregunta": "Cu√©ntame el proyecto m√°s desafiante que hayas liderado. Usa el m√©todo STAR.",
      "respuesta": "<p><strong>SITUACI√ìN:</strong> 'En 2019, Ministerio de Trabajo necesitaba Certificado √önico Laboral, consolidando 4 entidades.'</p><p><strong>TAREA:</strong> 'Dise√±ar integraci√≥n con PIDE y garantizar demanda nacional.'</p><p><strong>ACCI√ìN:</strong> 'Implement√© colas, jerarqu√≠a de excepciones, firma digital, logs centralizados.'</p><p><strong>RESULTADO:</strong> 'Premio Innovaci√≥n 2018, millones de peruanos lo usan.'</p>",
      "analogia": "STAR es tu estructura para historias de impacto. Sin estructura divagamos, con STAR somos memorables.",
      "codigo": null,
      "frase": "Dise√±ar para el fallo, no para el √©xito. Integrar sistemas es armar rompecabezas donde cada pieza puede cambiar."
    },
    {
      "id": 28,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementar√≠as Contract-First con OpenAPI en microservicios bancarios?",
      "respuesta": "<p>Contract-First = definir el contrato ANTES de codear:</p><ul><li><strong>1. Definir OpenAPI YAML</strong> con endpoints, schemas, errores.</li><li><strong>2. Generar c√≥digo</strong> del contrato (interfaces, DTOs).</li><li><strong>3. Implementar</strong> las interfaces generadas.</li><li><strong>4. Validar</strong> que el c√≥digo cumple el contrato.</li></ul><p><strong>Beneficios:</strong> Frontend y backend trabajan en paralelo, documentaci√≥n siempre actualizada.</p>",
      "analogia": "Es como construir una casa: primero los planos (contrato), luego la construcci√≥n (c√≥digo). No al rev√©s.",
      "codigo": "# openapi.yaml\npaths:\n  /cuentas/{id}/saldo:\n    get:\n      operationId: getSaldo\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: string\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Saldo'\n\n# Genera interface que implementas\npublic interface CuentasApi {\n    Mono<Saldo> getSaldo(String id);\n}",
      "frase": "Con Contract-First, frontend y backend pueden trabajar en paralelo. El contrato es el acuerdo."
    },
    {
      "id": 29,
      "categoria": "seguridad",
      "dificultad": "senior",
      "pregunta": "¬øC√≥mo implementar√≠as autenticaci√≥n y autorizaci√≥n en microservicios con JWT?",
      "respuesta": "<p>Flujo JWT en microservicios:</p><ul><li><strong>1. Login:</strong> Usuario se autentica, recibe JWT firmado.</li><li><strong>2. API Gateway:</strong> Valida firma del JWT, extrae claims.</li><li><strong>3. Propagaci√≥n:</strong> Claims se propagan a microservicios downstream.</li><li><strong>4. Autorizaci√≥n:</strong> Cada servicio valida permisos seg√∫n roles/scopes.</li></ul><p><strong>Seguridad:</strong> Tokens cortos (15min), refresh tokens, blacklist para revocaci√≥n.</p>",
      "analogia": "JWT es como tu pase del concierto: en la entrada validan que sea real, adentro cada zona valida si tu pase tiene acceso VIP.",
      "codigo": "@Bean\nSecurityWebFilterChain security(ServerHttpSecurity http) {\n    return http\n        .oauth2ResourceServer(oauth -> oauth.jwt())\n        .authorizeExchange(ex -> ex\n            .pathMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n            .pathMatchers(\"/api/**\").authenticated()\n            .anyExchange().permitAll())\n        .build();\n}\n\n// Extraer usuario del JWT\n@GetMapping(\"/mi-saldo\")\npublic Mono<Saldo> miSaldo(@AuthenticationPrincipal Jwt jwt) {\n    String userId = jwt.getSubject();\n    return saldoService.getSaldo(userId);\n}",
      "frase": "JWT en microservicios: el gateway valida la firma, cada servicio valida los permisos. Defensa en profundidad."
    },
    {
      "id": 30,
      "categoria": "reactivo",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo manejas errores en programaci√≥n reactiva? Explica los operadores principales.",
      "respuesta": "<p>Operadores de error en Reactor:</p><ul><li><strong>onErrorReturn:</strong> Valor por defecto. 'Toma pastilla y sigue.'</li><li><strong>onErrorResume:</strong> Flujo alternativo. 'Ve a otro doctor (plan B).'</li><li><strong>onErrorMap:</strong> Transformar excepci√≥n. 'Te transfiero a especialista.'</li><li><strong>retry:</strong> Reintentar. 'Intenta de nuevo.'</li><li><strong>timeout:</strong> L√≠mite de tiempo. 'Si no te atienden en 5s, vete.'</li></ul>",
      "analogia": "Manejo de errores es como hospital: onErrorReturn=pastilla, onErrorResume=otro doctor, retry=vuelve a intentar, timeout=vete si no te atienden.",
      "codigo": "public Mono<Saldo> getSaldoSeguro(String id) {\n    return cuentaRepo.findById(id)\n        .map(Cuenta::getSaldo)\n        .timeout(Duration.ofSeconds(5))\n        .retry(3)\n        .onErrorResume(TimeoutException.class, e -> \n            cacheService.getSaldoCache(id))\n        .onErrorReturn(Saldo.NO_DISPONIBLE)\n        .doOnError(e -> log.error(\"Error: {}\", e.getMessage()));\n}",
      "frase": "En reactivo, el manejo de errores es first-class citizen. Cada operador tiene su prop√≥sito."
    },
    {
      "id": 31,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo aplicar√≠as Domain-Driven Design (DDD) en un sistema bancario? Explica Bounded Contexts, Aggregates y Domain Events.",
      "respuesta": "<p><strong>DDD organiza c√≥digo por DOMINIOS de negocio:</strong></p><ul><li><strong>Bounded Context:</strong> Fronteras claras. 'Cuentas' es un contexto, 'Pr√©stamos' es otro. Cada uno tiene su lenguaje.</li><li><strong>Aggregate:</strong> Grupo de entidades que se modifican juntas. Cuenta + Movimientos = un aggregate.</li><li><strong>Domain Events:</strong> 'TransferenciaRealizada' notifica a otros contextos sin acoplamiento.</li><li><strong>Anti-Corruption Layer:</strong> Traductor entre tu dominio y sistemas legacy.</li></ul>",
      "analogia": "DDD es organizar el banco: Cuentas, Pr√©stamos, Tarjetas son departamentos separados. Se comunican por memos (eventos), no entrando a la oficina del otro.",
      "codigo": "// Aggregate Root\n@AggregateRoot\npublic class Cuenta {\n    private String id;\n    private List<Movimiento> movimientos;\n    private Saldo saldo;\n    \n    public DomainEvent debitar(BigDecimal monto) {\n        if (saldo.menor(monto)) throw new SaldoInsuficiente();\n        saldo = saldo.restar(monto);\n        return new CuentaDebitada(id, monto, Instant.now());\n    }\n}\n\n// Domain Event\npublic record CuentaDebitada(String cuentaId, BigDecimal monto, Instant when) {}",
      "frase": "DDD no es sobre c√≥digo, es sobre ENTENDER el negocio. Si no hablas el idioma del banco, tu c√≥digo ser√° confuso."
    },
    {
      "id": 32,
      "categoria": "cloud",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es un Service Mesh (Istio/Linkerd) y cu√°ndo lo necesitas en microservicios bancarios?",
      "respuesta": "<p><strong>Service Mesh = infraestructura dedicada para comunicaci√≥n entre servicios:</strong></p><ul><li><strong>Sidecar proxy:</strong> Cada pod tiene un Envoy que intercepta tr√°fico.</li><li><strong>mTLS autom√°tico:</strong> Todo cifrado sin cambiar c√≥digo.</li><li><strong>Traffic Management:</strong> Canary, blue-green, circuit breaker a nivel infra.</li><li><strong>Observabilidad:</strong> Traces distribuidos autom√°ticos.</li></ul><p><strong>¬øCu√°ndo?</strong> +30 microservicios, necesitas zero-trust networking, equipos separados manejan servicios.</p>",
      "analogia": "Service Mesh es como tener guardaespaldas para cada servicio: interceptan todo, verifican identidad, registran movimientos. T√∫ te enfocas en tu trabajo.",
      "codigo": "# VirtualService para Canary release\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: ms-transferencias\nspec:\n  hosts:\n    - ms-transferencias\n  http:\n    - match:\n        - headers:\n            x-canary:\n              exact: \"true\"\n      route:\n        - destination:\n            host: ms-transferencias\n            subset: v2\n    - route:\n        - destination:\n            host: ms-transferencias\n            subset: v1\n          weight: 90\n        - destination:\n            subset: v2\n          weight: 10",
      "frase": "Service Mesh mueve complejidad del c√≥digo a la infraestructura. Menos c√≥digo = menos bugs en tu app."
    },
    {
      "id": 33,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "System Design: Dise√±a el sistema de notificaciones push para Yape que env√≠a millones de notificaciones diarias.",
      "respuesta": "<p><strong>Componentes:</strong></p><ul><li><strong>API Gateway:</strong> Recibe eventos (transferencia, pago).</li><li><strong>Kafka:</strong> Cola de eventos, particiona por usuario para orden.</li><li><strong>Notification Workers:</strong> Consumers que procesan y formatean mensajes.</li><li><strong>Provider Abstraction:</strong> Firebase (Android), APNS (iOS), Email, SMS.</li><li><strong>Redis:</strong> Preferencias de usuario, device tokens, rate limiting.</li><li><strong>Dead Letter Queue:</strong> Reintentos para fallos.</li></ul><p><strong>Escala:</strong> 10 particiones, 10 consumers, batch processing de 100 mensajes.</p>",
      "analogia": "Sistema de correos del banco: eventos llegan a central (Kafka), carteros (workers) los distribuyen seg√∫n preferencia (push, email, SMS).",
      "codigo": "@Service\npublic class NotificationWorker {\n    @KafkaListener(topics = \"eventos-notificacion\")\n    public Mono<Void> procesar(List<EventoNotificacion> batch) {\n        return Flux.fromIterable(batch)\n            .flatMap(this::obtenerPreferencias)\n            .flatMap(this::enviarPorCanal)\n            .onErrorContinue((e, o) -> dlq.enviar(o))\n            .then();\n    }\n    \n    private Mono<Void> enviarPorCanal(NotificacionEnriquecida n) {\n        return switch(n.canal()) {\n            case PUSH -> firebaseClient.send(n);\n            case EMAIL -> emailClient.send(n);\n            case SMS -> smsClient.send(n);\n        };\n    }\n}",
      "frase": "Millones de notificaciones = Kafka + Workers escalables + Proveedores abstractos. Nunca llames a Firebase directamente."
    },
    {
      "id": 34,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Es viernes 5pm y hay un incidente P1 en producci√≥n. ¬øC√≥mo lo manejas como Tech Lead?",
      "respuesta": "<p><strong>Protocolo de Incidentes:</strong></p><ul><li><strong>1. Comunicar:</strong> Abrir canal de War Room (Slack/Teams), notificar stakeholders.</li><li><strong>2. Triaje:</strong> ¬øQu√© est√° fallando? ¬øImpacto? ¬øDesde cu√°ndo?</li><li><strong>3. Mitigar:</strong> Rollback, feature flag off, escalar recursos. PARAR LA HEMORRAGIA.</li><li><strong>4. Diagnosticar:</strong> Logs, m√©tricas, traces. ¬øQu√© cambi√≥?</li><li><strong>5. Resolver:</strong> Fix + deploy o mantener mitigaci√≥n hasta lunes.</li><li><strong>6. Post-mortem:</strong> Sin culpar. ¬øQu√© aprendimos? ¬øC√≥mo prevenimos?</li></ul>",
      "analogia": "Incidente es como incendio: primero evacuar (mitigar), luego apagar (fix), despu√©s investigar causa. No investigas mientras se quema.",
      "codigo": "// Feature Flag para mitigar r√°pido\n@PostMapping(\"/transferencias\")\npublic Mono<Response> transferir(@RequestBody TransferenciaCmd cmd) {\n    if (!featureFlags.isEnabled(\"transferencias-interbancarias\")) {\n        return Mono.just(Response.servicioTemporalmenteNoDisponible());\n    }\n    return transferenciaService.ejecutar(cmd);\n}\n\n// Rollback inmediato\n$ kubectl rollout undo deployment/ms-transferencias",
      "frase": "En un P1, primero MITIGA, despu√©s INVESTIGA. Usuarios no les importa el root cause, quieren que funcione."
    },
    {
      "id": 35,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo gestionas la deuda t√©cnica en tu equipo? ¬øCu√°ndo pagas y cu√°ndo la aceptas?",
      "respuesta": "<p><strong>Estrategia de Deuda T√©cnica:</strong></p><ul><li><strong>Inventariar:</strong> Documentar toda deuda en backlog t√©cnico con impacto.</li><li><strong>Clasificar:</strong> Cr√≠tica (seguridad, estabilidad), Alta (velocidad dev), Media (mantenibilidad), Baja (nice-to-have).</li><li><strong>Regla 20%:</strong> 20% del sprint para pagar deuda t√©cnica.</li><li><strong>Boy Scout:</strong> Deja el c√≥digo mejor de lo que lo encontraste.</li></ul><p><strong>Pagar cuando:</strong> Afecta velocidad, causa incidentes, bloquea features. <strong>Aceptar cuando:</strong> Es temporal, no afecta usuarios, se pagar√° pronto.</p>",
      "analogia": "Deuda t√©cnica es como deuda de tarjeta: poquito est√° bien, acumular intereses te quiebra. El 20% del sprint es tu pago mensual.",
      "codigo": null,
      "frase": "Deuda t√©cnica SIEMPRE se paga: o la pagas t√∫ a tu ritmo, o la pagan tus usuarios con ca√≠das y lentitud."
    },
    {
      "id": 36,
      "categoria": "data",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo dise√±ar√≠as la estrategia de base de datos para microservicios? ¬øDatabase per service o shared?",
      "respuesta": "<p><strong>Database per Service (recomendado):</strong></p><ul><li><strong>Autonom√≠a:</strong> Cada servicio controla su esquema, puede escalar independiente.</li><li><strong>Aislamiento:</strong> Fallo en una BD no afecta otras.</li><li><strong>Pol√≠glotas:</strong> PostgreSQL para transacciones, MongoDB para flexibilidad, Redis para cache.</li></ul><p><strong>Desaf√≠os:</strong> Consistencia eventual, joins distribuidos, transacciones SAGA.</p><p><strong>Shared solo si:</strong> Equipo peque√±o, dominio simple, migraci√≥n gradual de monolito.</p>",
      "analogia": "Cada departamento del banco tiene su archivo propio. Se comparten informaci√≥n por memos (APIs/eventos), no entrando al archivo del otro.",
      "codigo": "// Servicio Cuentas - PostgreSQL\n@Repository\npublic interface CuentaRepository extends ReactiveCrudRepository<Cuenta, String> {}\n\n// Servicio Movimientos - MongoDB (alto volumen)\n@Repository  \npublic interface MovimientoRepository extends ReactiveMongoRepository<Movimiento, String> {\n    Flux<Movimiento> findByCuentaIdOrderByFechaDesc(String cuentaId);\n}\n\n// Servicio Notificaciones - Redis (ef√≠mero)\n@Repository\npublic class NotificacionRedisRepository {\n    public Mono<Boolean> marcarLeida(String notifId) {\n        return redisTemplate.opsForValue().set(notifId, \"leida\", Duration.ofDays(7));\n    }\n}",
      "frase": "Database per service es el camino. S√≠, es m√°s complejo, pero la alternativa es un monolito distribuido."
    },
    {
      "id": 37,
      "categoria": "resiliencia",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es Chaos Engineering y c√≥mo lo aplicar√≠as en sistemas bancarios?",
      "respuesta": "<p><strong>Chaos Engineering = romper cosas a prop√≥sito para encontrar debilidades:</strong></p><ul><li><strong>1. Hip√≥tesis:</strong> 'Si cae el servicio de saldos, transferencias debe mostrar fallback.'</li><li><strong>2. Experimento:</strong> Matar pods de saldos en ambiente controlado.</li><li><strong>3. Medir:</strong> ¬øCircuit breaker se abri√≥? ¬øLatencia? ¬øErrores usuarios?</li><li><strong>4. Aprender:</strong> Documentar y mejorar.</li></ul><p><strong>Herramientas:</strong> Chaos Monkey, Litmus, Gremlin. <strong>En banca:</strong> Primero en staging, nunca en horario pico.</p>",
      "analogia": "Es simulacro de incendio: mejor descubrir que la puerta de emergencia est√° trabada en simulacro que en incendio real.",
      "codigo": "# Chaos experiment con Litmus\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: saldos-chaos\nspec:\n  appinfo:\n    appns: banking\n    applabel: app=ms-saldos\n  chaosServiceAccount: litmus-admin\n  experiments:\n    - name: pod-delete\n      spec:\n        components:\n          env:\n            - name: TOTAL_CHAOS_DURATION\n              value: '60'\n            - name: CHAOS_INTERVAL\n              value: '10'",
      "frase": "Chaos Engineering en banca no es irresponsable, es profesional. Mejor que descubras t√∫ las debilidades a que las descubran tus usuarios."
    },
    {
      "id": 38,
      "categoria": "observabilidad",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementar√≠as distributed tracing con OpenTelemetry en microservicios?",
      "respuesta": "<p><strong>OpenTelemetry unifica traces, m√©tricas y logs:</strong></p><ul><li><strong>Instrumentaci√≥n:</strong> SDK autom√°tico intercepta HTTP, BD, Kafka.</li><li><strong>Propagaci√≥n:</strong> Trace ID se pasa en headers (W3C Trace Context).</li><li><strong>Exportaci√≥n:</strong> Env√≠a a Jaeger, Zipkin, Tempo, X-Ray.</li><li><strong>Sampling:</strong> 10% normal, 100% en errores.</li></ul><p><strong>Beneficio:</strong> Ver TODO el flujo de un request: API Gateway ‚Üí BFF ‚Üí Servicio ‚Üí BD ‚Üí Kafka.</p>",
      "analogia": "OpenTelemetry es GPS del request: sabes exactamente por d√≥nde pas√≥, cu√°nto demor√≥ en cada parada, y d√≥nde se atasc√≥.",
      "codigo": "// build.gradle\nimplementation 'io.opentelemetry:opentelemetry-api'\nimplementation 'io.opentelemetry.instrumentation:opentelemetry-spring-webflux'\n\n// application.yml\notel:\n  traces:\n    exporter: jaeger\n  exporter:\n    jaeger:\n      endpoint: http://jaeger:14250\n  resource:\n    attributes:\n      service.name: ms-transferencias\n      deployment.environment: production\n\n// Span personalizado\n@WithSpan(\"validar-saldo-suficiente\")\npublic Mono<Boolean> validarSaldo(String cuentaId, BigDecimal monto) {\n    return saldoService.getSaldo(cuentaId)\n        .map(s -> s.compareTo(monto) >= 0);\n}",
      "frase": "Sin distributed tracing, debuggear microservicios es imposible. OpenTelemetry es el est√°ndar, no inventes."
    },
    {
      "id": 39,
      "categoria": "seguridad",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementar√≠as Rate Limiting y protecci√≥n contra DDoS en APIs bancarias?",
      "respuesta": "<p><strong>Capas de protecci√≥n:</strong></p><ul><li><strong>1. CDN/WAF:</strong> Cloudflare, AWS Shield. Primera l√≠nea contra DDoS.</li><li><strong>2. API Gateway:</strong> Rate limit por IP, usuario, API key.</li><li><strong>3. Aplicaci√≥n:</strong> Resilience4j RateLimiter por operaci√≥n cr√≠tica.</li></ul><p><strong>Estrategia:</strong></p><ul><li>Consulta saldo: 100/min por usuario.</li><li>Transferencias: 10/min por usuario.</li><li>Login: 5 intentos, luego bloqueo 15 min.</li></ul>",
      "analogia": "Rate limiting es el guardia del banco: si alguien entra y sale 100 veces en un minuto, algo raro pasa. Lo paras.",
      "codigo": "// Redis-based Rate Limiter\n@RateLimiter(name = \"transferencias\")\npublic Mono<TransferenciaResponse> transferir(TransferenciaCmd cmd) {\n    return transferenciaService.ejecutar(cmd);\n}\n\n# application.yml\nresilience4j:\n  ratelimiter:\n    instances:\n      transferencias:\n        limitForPeriod: 10\n        limitRefreshPeriod: 1m\n        timeoutDuration: 0\n\n// Custom con Redis para distribuido\npublic Mono<Boolean> permitir(String userId, String operacion) {\n    String key = \"rate:\" + operacion + \":\" + userId;\n    return redisTemplate.opsForValue()\n        .increment(key)\n        .flatMap(count -> {\n            if (count == 1) redisTemplate.expire(key, Duration.ofMinutes(1));\n            return Mono.just(count <= 10);\n        });\n}",
      "frase": "Sin rate limiting, un bot puede vaciar cuentas. En banca, es obligatorio, no opcional."
    },
    {
      "id": 40,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Tu equipo tiene 2 seniors que no se llevan bien y afectan la din√°mica. ¬øC√≥mo lo resuelves?",
      "respuesta": "<p><strong>Proceso de mediaci√≥n:</strong></p><ul><li><strong>1. Observar:</strong> ¬øEs personal o profesional? ¬øAfecta entregas?</li><li><strong>2. Individual:</strong> Hablar con cada uno por separado. Escuchar sin juzgar.</li><li><strong>3. Encontrar ra√≠z:</strong> ¬øTerritorio? ¬øEgo? ¬øComunicaci√≥n?</li><li><strong>4. Mediaci√≥n:</strong> Reuni√≥n conjunta enfocada en objetivos del equipo.</li><li><strong>5. Acuerdos:</strong> Reglas claras de colaboraci√≥n.</li><li><strong>6. Seguimiento:</strong> Check-ins peri√≥dicos.</li></ul><p><strong>Si persiste:</strong> Escalar a HR, considerar reorganizaci√≥n.</p>",
      "analogia": "Conflicto entre seniors es como dos pilotos peleando en cabina. Primero aterrizar el avi√≥n (entregas), luego resolver el conflicto.",
      "codigo": null,
      "frase": "Conflictos no resueltos son c√°ncer de equipos. No ignores se√±ales, act√∫a r√°pido pero con tacto."
    },
    {
      "id": 41,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo migrar√≠as un monolito bancario a microservicios sin detener operaciones?",
      "respuesta": "<p><strong>Estrategia Strangler Fig:</strong></p><ul><li><strong>1. Identificar bounded contexts:</strong> Mapear dominios del monolito.</li><li><strong>2. Empezar por los bordes:</strong> Features nuevas como microservicios.</li><li><strong>3. Extraer gradualmente:</strong> Un dominio a la vez (ej: Notificaciones).</li><li><strong>4. Anti-Corruption Layer:</strong> Traductor entre micro y mono.</li><li><strong>5. Database splitting:</strong> Primero replicar, luego separar.</li></ul><p><strong>Regla:</strong> Nunca big bang. Migraci√≥n de 2-3 a√±os es normal en banca.</p>",
      "analogia": "Strangler Fig es una planta que crece alrededor de un √°rbol hasta reemplazarlo. Los microservicios crecen alrededor del monolito.",
      "codigo": "// Anti-Corruption Layer\n@Service\npublic class CuentaAntiCorruptionLayer {\n    private final MonolitoClient monolito;\n    private final NuevoCuentaService nuevoServicio;\n    private final FeatureFlags flags;\n    \n    public Mono<Cuenta> getCuenta(String id) {\n        if (flags.isEnabled(\"usar-nuevo-servicio-cuentas\")) {\n            return nuevoServicio.getCuenta(id);\n        }\n        return monolito.getCuenta(id)\n            .map(this::traducirANuevoModelo);\n    }\n}",
      "frase": "Migrar monolito es marat√≥n, no sprint. Paciencia, feature flags, y nunca apagar el monolito hasta que est√© vac√≠o."
    },
    {
      "id": 42,
      "categoria": "data",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementar√≠as Outbox Pattern para garantizar consistencia entre base de datos y Kafka?",
      "respuesta": "<p><strong>Problema:</strong> Si guardas en BD y luego publicas a Kafka, puede fallar despu√©s del commit.</p><p><strong>Outbox Pattern:</strong></p><ul><li><strong>1.</strong> Transacci√≥n at√≥mica: INSERT en tabla + INSERT en outbox_events.</li><li><strong>2.</strong> Debezium/poller lee outbox_events.</li><li><strong>3.</strong> Publica a Kafka.</li><li><strong>4.</strong> Marca como procesado.</li></ul><p><strong>Beneficio:</strong> At-least-once delivery garantizado. Consumers deben ser idempotentes.</p>",
      "analogia": "Outbox es como dejar carta en bandeja de salida: la transacci√≥n la deja ah√≠, el cartero (Debezium) la recoge y env√≠a.",
      "codigo": "// Transacci√≥n at√≥mica\n@Transactional\npublic Mono<Transferencia> ejecutar(TransferenciaCmd cmd) {\n    return cuentaRepo.debitar(cmd.origen(), cmd.monto())\n        .then(cuentaRepo.acreditar(cmd.destino(), cmd.monto()))\n        .then(transferenciaRepo.guardar(cmd))\n        .then(outboxRepo.save(OutboxEvent.builder()\n            .aggregateType(\"Transferencia\")\n            .aggregateId(cmd.id())\n            .type(\"TransferenciaRealizada\")\n            .payload(toJson(cmd))\n            .build()));\n}\n\n// Debezium CDC captura cambios en outbox y publica a Kafka\n// Consumer debe ser idempotente (usar idempotency key)",
      "frase": "Sin Outbox, pierdes eventos. Con Outbox, puede duplicar. Prefiero duplicados que eventos perdidos (idempotencia)."
    },
    {
      "id": 43,
      "categoria": "reactivo",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementar√≠as Server-Sent Events (SSE) para notificaciones en tiempo real en banca?",
      "respuesta": "<p><strong>SSE vs WebSocket:</strong></p><ul><li><strong>SSE:</strong> Unidireccional servidor‚Üícliente. M√°s simple, reconexi√≥n autom√°tica.</li><li><strong>WebSocket:</strong> Bidireccional. M√°s complejo pero m√°s flexible.</li></ul><p><strong>En banca:</strong> SSE para notificaciones push (transferencias recibidas, alertas). WebSocket solo si necesitas chat o bidireccional.</p><p><strong>Implementaci√≥n:</strong> Flux que emite eventos, MediaType TEXT_EVENT_STREAM.</p>",
      "analogia": "SSE es radio: el banco transmite, t√∫ escuchas. WebSocket es tel√©fono: ambos hablan. Para notificaciones, radio basta.",
      "codigo": "@GetMapping(value = \"/notificaciones/stream\", produces = MediaType.TEXT_EVENT_STREAM_VALUE)\npublic Flux<ServerSentEvent<NotificacionDTO>> streamNotificaciones(\n        @AuthenticationPrincipal Jwt jwt) {\n    String userId = jwt.getSubject();\n    \n    return Flux.merge(\n        // Notificaciones existentes\n        notificacionService.getPendientes(userId),\n        // Nuevas notificaciones en tiempo real\n        notificacionSink.asFlux()\n            .filter(n -> n.getUserId().equals(userId))\n    )\n    .map(n -> ServerSentEvent.<NotificacionDTO>builder()\n        .id(n.getId())\n        .event(n.getTipo())\n        .data(n)\n        .build())\n    .doOnCancel(() -> log.info(\"SSE cerrado: {}\", userId));\n}",
      "frase": "SSE es subestimado. Para notificaciones unidireccionales es m√°s simple y robusto que WebSocket."
    },
    {
      "id": 44,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo mides la productividad de tu equipo de desarrollo sin caer en m√©tricas t√≥xicas?",
      "respuesta": "<p><strong>M√©tricas a EVITAR:</strong> Lines of code, commits/d√≠a, horas trabajadas.</p><p><strong>M√©tricas DORA (recomendadas):</strong></p><ul><li><strong>Deployment Frequency:</strong> ¬øCada cu√°nto desplegamos? (meta: diario)</li><li><strong>Lead Time:</strong> Commit ‚Üí producci√≥n. (meta: <1 d√≠a)</li><li><strong>Change Failure Rate:</strong> % deploys que causan incidentes. (meta: <15%)</li><li><strong>MTTR:</strong> Tiempo para recuperarse de incidente. (meta: <1 hora)</li></ul><p><strong>Complementar con:</strong> Satisfacci√≥n del equipo, deuda t√©cnica trending, cobertura tests.</p>",
      "analogia": "M√©tricas t√≥xicas son como medir chef por platos/hora: produce basura r√°pido. DORA mide si los platos llegan bien al cliente.",
      "codigo": null,
      "frase": "Si mides l√≠neas de c√≥digo, obtendr√°s c√≥digo inflado. Mide IMPACTO: qu√© tan r√°pido entregamos VALOR sin romper cosas."
    },
    {
      "id": 45,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementar√≠as idempotencia en APIs de transferencias para evitar cobros duplicados?",
      "respuesta": "<p><strong>Idempotencia = misma request, mismo resultado, sin efectos duplicados.</strong></p><p><strong>Implementaci√≥n:</strong></p><ul><li><strong>1. Idempotency Key:</strong> Cliente env√≠a UUID √∫nico en header.</li><li><strong>2. Almacenar:</strong> Redis con TTL (24h) guarda key + respuesta.</li><li><strong>3. Verificar:</strong> Si key existe, retorna respuesta guardada.</li><li><strong>4. Procesar:</strong> Si no existe, procesa y guarda.</li></ul><p><strong>Casos de uso:</strong> Transferencias, pagos, cualquier operaci√≥n no-idempotente.</p>",
      "analogia": "Es como recibo de pago: si ya pagaste (key existe), te muestro el recibo anterior. No te cobro dos veces.",
      "codigo": "@PostMapping(\"/transferencias\")\npublic Mono<TransferenciaResponse> transferir(\n        @RequestHeader(\"Idempotency-Key\") String idempotencyKey,\n        @RequestBody TransferenciaCmd cmd) {\n    \n    return idempotencyService.get(idempotencyKey)\n        .switchIfEmpty(\n            transferenciaService.ejecutar(cmd)\n                .flatMap(response -> \n                    idempotencyService.save(idempotencyKey, response, Duration.ofHours(24))\n                        .thenReturn(response))\n        );\n}\n\n// IdempotencyService con Redis\npublic Mono<TransferenciaResponse> get(String key) {\n    return redisTemplate.opsForValue()\n        .get(\"idempotency:\" + key)\n        .map(json -> fromJson(json, TransferenciaResponse.class));\n}",
      "frase": "En banca, transferencia duplicada es p√©rdida de dinero. Idempotencia no es opcional, es OBLIGATORIA."
    },
    {
      "id": 46,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es ACID en bases de datos? Expl√≠calo como si fuera una transferencia en Yape.",
      "respuesta": "<p><strong>ACID = las 4 garant√≠as de una transacci√≥n de BD:</strong></p><ul><li><strong>A - Atomicity (Atomicidad):</strong> TODO O NADA. Si yapeas S/100, o se descuenta Y llega, o ninguno. No puede quedar a medias.</li><li><strong>C - Consistency (Consistencia):</strong> REGLAS SIEMPRE SE CUMPLEN. Si tienes S/50, no puedes yapear S/100. La BD no permite estados inv√°lidos.</li><li><strong>I - Isolation (Aislamiento):</strong> CADA UNO EN SU COLA. Si t√∫ y tu hermano yapean al mismo tiempo, cada transacci√≥n es independiente.</li><li><strong>D - Durability (Durabilidad):</strong> LO QUE SE GUARD√ì, SE GUARD√ì. Si el banco dice 'transferencia exitosa', aunque se caiga el servidor, tu plata est√° segura.</li></ul>",
      "analogia": "ACID es el contrato del banco: TODO o NADA (A), respeta tus reglas (C), cada cliente en su ventanilla (I), lo firmado es ley (D).",
      "codigo": "@Transactional // Spring garantiza ACID\npublic Mono<Void> transferir(String origen, String destino, BigDecimal monto) {\n    return cuentaRepo.debitar(origen, monto)    // Si esto falla...\n        .then(cuentaRepo.acreditar(destino, monto)) // ...esto NO se ejecuta\n        .then();  // TODO O NADA (Atomicity)\n}",
      "frase": "Sin ACID, tu yape podr√≠a descontar pero no llegar. ACID es la promesa de que eso NUNCA pase."
    },
    {
      "id": 47,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Explica los patrones de microservicios por categor√≠a: Comunicaci√≥n, Datos, Resiliencia y Observabilidad.",
      "respuesta": "<p><strong>üîó COMUNICACI√ìN (c√≥mo hablan entre s√≠):</strong></p><ul><li><strong>API Gateway:</strong> Portero √∫nico de entrada.</li><li><strong>Service Discovery:</strong> P√°ginas amarillas de servicios.</li><li><strong>Sidecar:</strong> Asistente que acompa√±a a cada servicio.</li></ul><p><strong>üíæ DATOS (c√≥mo manejan info):</strong></p><ul><li><strong>Database per Service:</strong> Cada uno su BD.</li><li><strong>CQRS:</strong> Una BD para leer, otra para escribir.</li><li><strong>Event Sourcing:</strong> Guardar TODO lo que pas√≥.</li><li><strong>Saga:</strong> CTRL+Z distribuido.</li></ul><p><strong>üõ°Ô∏è RESILIENCIA (c√≥mo sobreviven):</strong></p><ul><li><strong>Circuit Breaker:</strong> Fusible que corta.</li><li><strong>Retry:</strong> Volver a intentar.</li><li><strong>Bulkhead:</strong> Compartimentos del barco.</li><li><strong>Timeout:</strong> No esperar forever.</li></ul><p><strong>üëÅÔ∏è OBSERVABILIDAD (c√≥mo los vigilas):</strong></p><ul><li><strong>Log Aggregation:</strong> Todos los logs en un lugar.</li><li><strong>Distributed Tracing:</strong> GPS del request.</li><li><strong>Health Check:</strong> ¬øEst√°s vivo?</li></ul>",
      "analogia": "Microservicios son como departamentos de empresa: COMUNICACI√ìN es c√≥mo se mandan memos, DATOS es c√≥mo guardan archivos, RESILIENCIA es plan de emergencia, OBSERVABILIDAD es las c√°maras de seguridad.",
      "codigo": "// Ejemplo combinando patrones\n@CircuitBreaker(name = \"pagos\")  // RESILIENCIA\n@Retry(name = \"pagos\")           // RESILIENCIA  \npublic Mono<PagoResponse> pagar(PagoCmd cmd) {\n    return webClient.post()      // COMUNICACI√ìN (via API Gateway)\n        .bodyValue(cmd)\n        .retrieve()\n        .bodyToMono(PagoResponse.class)\n        .doOnSuccess(r -> log.info(\"Pago OK\"))  // OBSERVABILIDAD\n        .doOnError(e -> log.error(\"Pago FAIL\")); // OBSERVABILIDAD\n}",
      "frase": "No memorices patrones, entiende QU√â PROBLEMA resuelven. Cada categor√≠a ataca un dolor espec√≠fico de microservicios."
    },
    {
      "id": 48,
      "categoria": "patrones",
      "dificultad": "senior",
      "pregunta": "¬øCu√°les son los 3 tipos de patrones de dise√±o GoF (Gang of Four)? Dame ejemplos en Java.",
      "respuesta": "<p><strong>Los 23 patrones GoF se dividen en 3 familias:</strong></p><p><strong>üèóÔ∏è CREACIONALES (c√≥mo CREAR objetos):</strong></p><ul><li><strong>Singleton:</strong> Solo UNO en todo el sistema (Config, Logger).</li><li><strong>Factory:</strong> F√°brica que decide qu√© objeto crear.</li><li><strong>Builder:</strong> Construir paso a paso (objetos complejos).</li></ul><p><strong>üß± ESTRUCTURALES (c√≥mo ORGANIZAR clases):</strong></p><ul><li><strong>Adapter:</strong> Enchufe adaptador entre incompatibles.</li><li><strong>Decorator:</strong> Agregar funcionalidad sin modificar.</li><li><strong>Facade:</strong> Fachada simple para sistema complejo.</li></ul><p><strong>üé≠ COMPORTAMIENTO (c√≥mo INTERACT√öAN):</strong></p><ul><li><strong>Strategy:</strong> Cambiar algoritmo en runtime.</li><li><strong>Observer:</strong> Notificar cuando algo cambia.</li><li><strong>Template Method:</strong> Esqueleto con pasos personalizables.</li></ul>",
      "analogia": "GoF son recetas de cocina probadas: CREACIONALES = c√≥mo preparar ingredientes, ESTRUCTURALES = c√≥mo armar el plato, COMPORTAMIENTO = c√≥mo servir y presentar.",
      "codigo": "// CREACIONAL - Builder\nTransferencia t = Transferencia.builder()\n    .origen(\"123\").destino(\"456\").monto(100).build();\n\n// ESTRUCTURAL - Adapter\npublic class LegacyBankAdapter implements ModernBankPort {\n    private LegacyBank legacy;\n    public Mono<Saldo> getSaldo(String id) {\n        return Mono.fromCallable(() -> legacy.consultarSaldo(id));\n    }\n}\n\n// COMPORTAMIENTO - Strategy\npublic interface ComisionStrategy {\n    BigDecimal calcular(BigDecimal monto);\n}\n// Cambias estrategia sin tocar c√≥digo",
      "frase": "No uses patrones por usarlos. Primero el PROBLEMA, luego buscas si hay patr√≥n que lo resuelva."
    },
    {
      "id": 49,
      "categoria": "reactivo",
      "dificultad": "senior",
      "pregunta": "¬øCu√°l es la diferencia entre operadores INTERMEDIOS y TERMINALES en programaci√≥n reactiva?",
      "respuesta": "<p><strong>üîÑ INTERMEDIOS (transforman el flujo, NO ejecutan):</strong></p><ul><li><strong>map():</strong> Transforma cada elemento.</li><li><strong>filter():</strong> Filtra elementos.</li><li><strong>flatMap():</strong> Transforma y aplana.</li><li><strong>take(n):</strong> Toma solo n elementos.</li><li><strong>distinct():</strong> Elimina duplicados.</li><li><strong>doOnNext():</strong> Side effect sin modificar.</li></ul><p><strong>üèÅ TERMINALES (disparan la ejecuci√≥n):</strong></p><ul><li><strong>subscribe():</strong> ¬°ARRANCA!</li><li><strong>block():</strong> Espera resultado (¬°evitar!).</li><li><strong>collectList():</strong> Junta todo en lista.</li><li><strong>count():</strong> Cuenta elementos.</li><li><strong>then():</strong> Cuando termine, haz esto.</li></ul><p><strong>REGLA DE ORO:</strong> Sin operador terminal, NADA se ejecuta. Es como armar receta pero nunca cocinar.</p>",
      "analogia": "Intermedios son INSTRUCCIONES de la receta (picar, mezclar, sazonar). Terminales son COCINAR (meter al horno). Sin cocinar, solo tienes papel con instrucciones.",
      "codigo": "// NADA se ejecuta (solo intermedios)\nFlux.just(1, 2, 3)\n    .map(n -> n * 2)      // Intermedio\n    .filter(n -> n > 2);   // Intermedio - ¬°RECETA SIN COCINAR!\n\n// AHORA S√ç se ejecuta (terminal)\nFlux.just(1, 2, 3)\n    .map(n -> n * 2)      // Intermedio\n    .filter(n -> n > 2)    // Intermedio  \n    .subscribe(System.out::println);  // TERMINAL = ¬°ARRANCA!",
      "frase": "Sin subscribe(), tu c√≥digo reactivo es letra muerta. Es el bot√≥n de PLAY."
    },
    {
      "id": 50,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es programaci√≥n funcional y cu√°les son sus principios? Expl√≠calo con ejemplos de Yape.",
      "respuesta": "<p><strong>Programaci√≥n Funcional = c√≥digo como FUNCIONES MATEM√ÅTICAS:</strong></p><p><strong>üìå PRINCIPIOS:</strong></p><ul><li><strong>Inmutabilidad:</strong> Datos NO se modifican, se crean nuevos. Tu saldo no se 'modifica', se crea nuevo estado.</li><li><strong>Funciones Puras:</strong> Mismo input = mismo output. calcularComision(100) SIEMPRE = 2.</li><li><strong>Sin Side Effects:</strong> Funci√≥n no modifica nada externo.</li><li><strong>First-Class Functions:</strong> Funciones son valores, se pasan como par√°metros.</li><li><strong>Higher-Order Functions:</strong> Funciones que reciben/retornan funciones (map, filter, reduce).</li></ul><p><strong>BENEFICIOS:</strong> C√≥digo predecible, f√°cil de testear, paralelizable.</p>",
      "analogia": "Funcional es cocina de RECETAS EXACTAS: mismos ingredientes = mismo plato. No hay 'a ojo'. Imperativo es cocina de abuelita: '√©chale hasta que sepa bien'.",
      "codigo": "// IMPERATIVO (mutable, side effects)\nList<Movimiento> filtrados = new ArrayList<>();\nfor (Movimiento m : movimientos) {\n    if (m.getMonto() > 100) {\n        filtrados.add(m);  // Muta lista externa\n    }\n}\n\n// FUNCIONAL (inmutable, puro)\nList<Movimiento> filtrados = movimientos.stream()\n    .filter(m -> m.getMonto() > 100)  // Funci√≥n pura\n    .collect(Collectors.toList());     // Nueva lista, no muta",
      "frase": "Funcional no es moda, es PREDICTIBILIDAD. En banca, necesitas saber que 2+2 siempre ser√° 4."
    },
    {
      "id": 51,
      "categoria": "azure",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es Azure Data Factory y cu√°ndo lo usar√≠as en un proyecto bancario?",
      "respuesta": "<p><strong>Azure Data Factory (ADF) = ORQUESTADOR de movimiento de datos:</strong></p><ul><li><strong>ETL/ELT:</strong> Extrae de BD, archivos, APIs ‚Üí Transforma ‚Üí Carga a destino.</li><li><strong>Pipelines:</strong> Flujos visuales de datos con actividades.</li><li><strong>Conectores:</strong> +90 fuentes (SQL, Oracle, SAP, S3, APIs REST).</li><li><strong>Triggers:</strong> Por horario, evento, o tumbling window.</li></ul><p><strong>EN BANCA:</strong></p><ul><li>Migraci√≥n nocturna de transacciones a Data Lake.</li><li>Consolidaci√≥n de datos de m√∫ltiples cores bancarios.</li><li>Alimentar dashboards de riesgo con data de producci√≥n.</li></ul>",
      "analogia": "ADF es el CAMI√ìN DE MUDANZA de datos: recoge cajas (datos) de varias casas (fuentes), las reorganiza en el camino (transforma), y las deja en la nueva casa (destino).",
      "codigo": "// Pipeline ADF (JSON simplificado)\n{\n  \"name\": \"MigracionTransaccionesDiaria\",\n  \"activities\": [\n    {\n      \"name\": \"CopiarDesdeOracle\",\n      \"type\": \"Copy\",\n      \"source\": { \"type\": \"OracleSource\", \"query\": \"SELECT * FROM TXN WHERE fecha = @today\" },\n      \"sink\": { \"type\": \"AzureBlobSink\", \"path\": \"raw/transacciones/\" }\n    },\n    {\n      \"name\": \"TransformarConDataflow\",\n      \"type\": \"DataFlow\",\n      \"dependsOn\": [\"CopiarDesdeOracle\"]\n    }\n  ],\n  \"trigger\": { \"type\": \"Schedule\", \"recurrence\": \"0 2 * * *\" }\n}",
      "frase": "ADF no es para tiempo real, es para BATCH. Si necesitas mover TB de datos cada noche, ADF es tu amigo."
    },
    {
      "id": 52,
      "categoria": "azure",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es Azure Functions y cu√°ndo lo usar√≠as vs un microservicio tradicional?",
      "respuesta": "<p><strong>Azure Functions = SERVERLESS, c√≥digo que corre sin servidor:</strong></p><ul><li><strong>Event-Driven:</strong> Se ejecuta cuando pasa algo (HTTP, Queue, Timer, Blob).</li><li><strong>Pay-per-execution:</strong> Solo pagas cuando corre.</li><li><strong>Auto-scale:</strong> Escala de 0 a miles autom√°ticamente.</li><li><strong>Cold Start:</strong> Primera ejecuci√≥n puede demorar (desventaja).</li></ul><p><strong>USAR FUNCTIONS:</strong> Tareas cortas, event-driven, tr√°fico impredecible.</p><p><strong>USAR MICROSERVICIO:</strong> Procesos largos, estado, tr√°fico constante, latencia cr√≠tica.</p>",
      "analogia": "Functions es TAXI: lo llamas cuando necesitas, pagas el viaje, se va. Microservicio es AUTO PROPIO: siempre disponible pero pagas parking aunque no lo uses.",
      "codigo": "// Azure Function - Trigger HTTP\n@FunctionName(\"ValidarTransferencia\")\npublic HttpResponseMessage validar(\n    @HttpTrigger(name = \"req\", methods = {HttpMethod.POST}) HttpRequestMessage<TransferenciaDTO> request,\n    ExecutionContext context) {\n    \n    TransferenciaDTO tx = request.getBody();\n    boolean valida = tx.getMonto().compareTo(BigDecimal.ZERO) > 0;\n    \n    return request.createResponseBuilder(valida ? HttpStatus.OK : HttpStatus.BAD_REQUEST)\n        .body(valida ? \"OK\" : \"Monto inv√°lido\")\n        .build();\n}\n\n// Trigger por Cola (procesar eventos)\n@FunctionName(\"ProcesarNotificacion\")\npublic void procesar(\n    @QueueTrigger(name = \"msg\", queueName = \"notificaciones\") String mensaje) {\n    // Se ejecuta cada vez que llega mensaje a la cola\n}",
      "frase": "Functions para picos impredecibles y eventos. Microservicio para carga constante. No todo debe ser serverless."
    },
    {
      "id": 53,
      "categoria": "azure",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es ACR (Azure Container Registry) y c√≥mo se integra con AKS?",
      "respuesta": "<p><strong>ACR = tu ALMAC√âN PRIVADO de im√°genes Docker:</strong></p><ul><li><strong>Registry privado:</strong> Como Docker Hub pero solo para tu empresa.</li><li><strong>Geo-replicaci√≥n:</strong> Im√°genes cerca de donde despliegas.</li><li><strong>Escaneo de vulnerabilidades:</strong> Detecta CVEs en tus im√°genes.</li><li><strong>Integraci√≥n nativa AKS:</strong> AKS jala im√°genes sin config extra.</li></ul><p><strong>FLUJO CI/CD:</strong></p><ol><li>Build imagen en pipeline.</li><li>Push a ACR con tag (v1.2.3).</li><li>AKS hace pull de ACR.</li><li>Kubernetes despliega pods.</li></ol>",
      "analogia": "ACR es tu BODEGA PRIVADA de contenedores. AKS es el PUERTO que descarga los contenedores y los pone a trabajar.",
      "codigo": "# Build y push a ACR\naz acr build --registry miregistro --image ms-transferencias:v1.2.3 .\n\n# Kubernetes deployment jalando de ACR\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ms-transferencias\nspec:\n  template:\n    spec:\n      containers:\n        - name: app\n          image: miregistro.azurecr.io/ms-transferencias:v1.2.3\n          # AKS ya tiene permisos a ACR (managed identity)",
      "frase": "ACR + AKS es el combo nativo de Azure para contenedores. Integraci√≥n sin dolor de cabeza."
    },
    {
      "id": 54,
      "categoria": "azure",
      "dificultad": "senior",
      "pregunta": "¬øCu√°l es la diferencia entre Web App for Containers y AKS? ¬øCu√°ndo usar cada uno?",
      "respuesta": "<p><strong>üåê WEB APP FOR CONTAINERS (App Service):</strong></p><ul><li><strong>PaaS simple:</strong> Subes contenedor, Azure maneja todo.</li><li><strong>Sin orquestaci√≥n:</strong> Un contenedor por app.</li><li><strong>Auto-scale b√°sico:</strong> Por CPU/memoria.</li><li><strong>Ideal para:</strong> APIs simples, equipos peque√±os, MVPs.</li></ul><p><strong>‚ò∏Ô∏è AKS (Azure Kubernetes Service):</strong></p><ul><li><strong>Orquestaci√≥n completa:</strong> Kubernetes managed.</li><li><strong>Multi-contenedor:</strong> Pods, sidecars, service mesh.</li><li><strong>Control total:</strong> Networking, storage, scaling avanzado.</li><li><strong>Ideal para:</strong> Microservicios complejos, equipos grandes, producci√≥n enterprise.</li></ul>",
      "analogia": "Web App es DEPARTAMENTO AMOBLADO: llegas y vives. AKS es TERRENO + MATERIALES: construyes como quieras pero t√∫ armas todo.",
      "codigo": "# Web App for Containers - Simple\naz webapp create --name mi-api \\\n  --resource-group mi-rg \\\n  --plan mi-plan \\\n  --deployment-container-image-name miregistro.azurecr.io/mi-api:latest\n\n# AKS - M√°s control pero m√°s config\nkubectl apply -f deployment.yaml\nkubectl apply -f service.yaml\nkubectl apply -f ingress.yaml\nkubectl apply -f hpa.yaml\n# ... y m√°s manifiestos",
      "frase": "¬øTienes 1-5 servicios simples? Web App. ¬øTienes 20+ microservicios con service mesh? AKS."
    },
    {
      "id": 55,
      "categoria": "azure",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es Azure Key Vault y c√≥mo lo usar√≠as para secretos en microservicios?",
      "respuesta": "<p><strong>Key Vault = CAJA FUERTE de Azure para secretos:</strong></p><ul><li><strong>Secrets:</strong> Passwords, connection strings, API keys.</li><li><strong>Keys:</strong> Llaves criptogr√°ficas (encrypt/decrypt).</li><li><strong>Certificates:</strong> SSL/TLS certificates.</li><li><strong>Access Policies:</strong> Qui√©n puede leer qu√©.</li><li><strong>Audit Logs:</strong> Qui√©n accedi√≥ a qu√© secreto.</li></ul><p><strong>INTEGRACI√ìN:</strong></p><ul><li><strong>Managed Identity:</strong> App se autentica sin credenciales.</li><li><strong>AKS + CSI Driver:</strong> Secretos se montan como archivos.</li><li><strong>Spring Boot:</strong> @Value lee directo de Key Vault.</li></ul>",
      "analogia": "Key Vault es la B√ìVEDA del banco donde guardas las llaves de las otras b√≥vedas. Nadie tiene la llave pegada en la puerta.",
      "codigo": "// Spring Boot con Azure Key Vault\n// application.yml\nazure:\n  keyvault:\n    uri: https://mi-vault.vault.azure.net/\n\n// Uso en c√≥digo - el secreto se jala autom√°tico\n@Value(\"${db-password}\")\nprivate String dbPassword;\n\n// AKS con CSI Driver\napiVersion: v1\nkind: Pod\nspec:\n  containers:\n    - name: app\n      volumeMounts:\n        - name: secrets\n          mountPath: \"/mnt/secrets\"\n          readOnly: true\n  volumes:\n    - name: secrets\n      csi:\n        driver: secrets-store.csi.k8s.io\n        volumeAttributes:\n          secretProviderClass: azure-keyvault",
      "frase": "Secreto en c√≥digo = despido. Secreto en Key Vault = pr√°ctica profesional. En banca, es requisito regulatorio."
    },
    {
      "id": 56,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Explica el patr√≥n Saga con sus dos variantes: Orquestada y Coreografiada.",
      "respuesta": "<p><strong>SAGA = Transacci√≥n distribuida con compensaciones (CTRL+Z):</strong></p><p><strong>üé≠ ORQUESTADA (Director de orquesta):</strong></p><ul><li>Un COORDINADOR central controla todo el flujo.</li><li>Llama servicio A ‚Üí si OK ‚Üí llama B ‚Üí si OK ‚Üí llama C.</li><li>Si falla C ‚Üí compensa B ‚Üí compensa A.</li><li><strong>Pro:</strong> F√°cil de debuggear, flujo claro.</li><li><strong>Con:</strong> Coordinador es punto de fallo.</li></ul><p><strong>üíÉ COREOGRAFIADA (Baile sin director):</strong></p><ul><li>Cada servicio REACCIONA a eventos.</li><li>A publica evento ‚Üí B escucha y act√∫a ‚Üí B publica ‚Üí C escucha.</li><li><strong>Pro:</strong> Desacoplado, no hay punto central de fallo.</li><li><strong>Con:</strong> Dif√≠cil seguir el flujo, debugging complejo.</li></ul>",
      "analogia": "ORQUESTADA es director de orquesta: √©l dice qui√©n toca cu√°ndo. COREOGRAFIADA es jam session: cada m√∫sico escucha y reacciona.",
      "codigo": "// ORQUESTADA - Coordinador\n@Service\npublic class TransferenciaSagaOrquestador {\n    public Mono<Void> ejecutar(TransferenciaCmd cmd) {\n        return paso1_ValidarSaldo(cmd)\n            .then(paso2_DebitarOrigen(cmd))\n            .then(paso3_AcreditarDestino(cmd))\n            .onErrorResume(e -> compensar(cmd, e));\n    }\n}\n\n// COREOGRAFIADA - Eventos\n@KafkaListener(topics = \"cuenta-debitada\")\npublic void onCuentaDebitada(CuentaDebitadaEvent e) {\n    // Servicio destino reacciona al evento\n    acreditarCuenta(e.getDestino(), e.getMonto())\n        .subscribe();\n}",
      "frase": "Orquestada para flujos cr√≠ticos que necesitas controlar. Coreografiada para sistemas muy distribuidos y desacoplados."
    },
    {
      "id": 57,
      "categoria": "patrones",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es el patr√≥n Sidecar y c√≥mo se usa en Kubernetes/Service Mesh?",
      "respuesta": "<p><strong>SIDECAR = Contenedor ASISTENTE que acompa√±a a tu app:</strong></p><ul><li>Vive en el mismo Pod que tu aplicaci√≥n.</li><li>Comparte red y storage con el contenedor principal.</li><li>Maneja concerns transversales SIN modificar tu c√≥digo.</li></ul><p><strong>USOS COMUNES:</strong></p><ul><li><strong>Envoy (Istio):</strong> mTLS, traffic management, observability.</li><li><strong>Log collector:</strong> Fluent Bit recoge logs.</li><li><strong>Secret injector:</strong> Vault Agent inyecta secretos.</li><li><strong>Proxy:</strong> Autenticaci√≥n, rate limiting.</li></ul>",
      "analogia": "Sidecar es tu GUARDAESPALDAS: va contigo a todos lados, maneja la seguridad, t√∫ te enfocas en tu trabajo.",
      "codigo": "# Pod con Sidecar (Envoy para Service Mesh)\napiVersion: v1\nkind: Pod\nmetadata:\n  name: ms-transferencias\n  annotations:\n    sidecar.istio.io/inject: \"true\"  # Istio inyecta Envoy\nspec:\n  containers:\n    - name: app\n      image: ms-transferencias:v1\n      ports:\n        - containerPort: 8080\n    # Istio inyecta autom√°ticamente:\n    # - name: istio-proxy\n    #   image: envoy\n    #   # Intercepta TODO el tr√°fico",
      "frase": "Sidecar mueve complejidad FUERA de tu c√≥digo. Tu app hace negocio, el sidecar hace infraestructura."
    },
    {
      "id": 58,
      "categoria": "resiliencia",
      "dificultad": "senior",
      "pregunta": "Explica el patr√≥n Retry con Exponential Backoff. ¬øPor qu√© es mejor que retry simple?",
      "respuesta": "<p><strong>RETRY SIMPLE:</strong> Falla ‚Üí espera 1s ‚Üí reintenta ‚Üí espera 1s ‚Üí reintenta...</p><p><strong>PROBLEMA:</strong> Si 1000 clientes reintentan cada 1s, BOMBARDEAS al servicio ca√≠do.</p><p><strong>EXPONENTIAL BACKOFF:</strong></p><ul><li>1er retry: espera 1s</li><li>2do retry: espera 2s</li><li>3er retry: espera 4s</li><li>4to retry: espera 8s</li></ul><p><strong>+ JITTER (ruido aleatorio):</strong> A√±ade variaci√≥n para que no todos reintenten al mismo tiempo.</p>",
      "analogia": "Retry simple es 1000 personas llamando al mismo tiempo cuando se cae la l√≠nea. Backoff con jitter es cada uno esperando diferente tiempo antes de volver a llamar.",
      "codigo": "// Resilience4j con Exponential Backoff\nresilience4j:\n  retry:\n    instances:\n      servicioPagos:\n        maxAttempts: 4\n        waitDuration: 1s\n        enableExponentialBackoff: true\n        exponentialBackoffMultiplier: 2\n        enableRandomizedWait: true  # Jitter\n        randomizedWaitFactor: 0.5\n\n// Resultado: 1s, 2s (¬±50%), 4s (¬±50%), 8s (¬±50%)",
      "frase": "Backoff exponencial + jitter evita 'thundering herd'. Sin esto, tus retries pueden tumbar al servicio que intentas recuperar."
    },
    {
      "id": 59,
      "categoria": "observabilidad",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es un Correlation ID y por qu√© es CR√çTICO en microservicios?",
      "respuesta": "<p><strong>Correlation ID = UUID √∫nico que viaja por TODOS los servicios:</strong></p><ul><li>Usuario hace request ‚Üí Gateway genera UUID.</li><li>UUID se propaga: Gateway ‚Üí BFF ‚Üí Servicio A ‚Üí Servicio B ‚Üí BD.</li><li>TODOS los logs incluyen ese UUID.</li><li>Cuando hay error, buscas por UUID y ves TODO el flujo.</li></ul><p><strong>SIN CORRELATION ID:</strong> 'Hay error en producci√≥n' ‚Üí buscar aguja en pajar entre millones de logs.</p><p><strong>CON CORRELATION ID:</strong> 'Error con ID abc-123' ‚Üí filtras y ves exactamente qu√© pas√≥.</p>",
      "analogia": "Correlation ID es como n√∫mero de TRACKING de tu paquete: sabes exactamente por d√≥nde pas√≥ y d√≥nde est√°.",
      "codigo": "// WebFilter que propaga Correlation ID\n@Component\npublic class CorrelationIdFilter implements WebFilter {\n    public Mono<Void> filter(ServerWebExchange ex, WebFilterChain chain) {\n        String correlationId = ex.getRequest().getHeaders()\n            .getFirst(\"X-Correlation-ID\");\n        \n        if (correlationId == null) {\n            correlationId = UUID.randomUUID().toString();\n        }\n        \n        // Agregar a response y contexto\n        ex.getResponse().getHeaders().add(\"X-Correlation-ID\", correlationId);\n        MDC.put(\"correlationId\", correlationId);  // Para logs\n        \n        return chain.filter(ex);\n    }\n}\n\n// Log autom√°ticamente incluye correlationId\nlog.info(\"Procesando transferencia\");  // {correlationId: abc-123, msg: ...}",
      "frase": "Sin Correlation ID, debuggear microservicios es IMPOSIBLE. Es tu hilo de Ariadna en el laberinto."
    },
    {
      "id": 60,
      "categoria": "data",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es consistencia eventual y c√≥mo la manejas en microservicios bancarios?",
      "respuesta": "<p><strong>CONSISTENCIA EVENTUAL = los datos EVENTUALMENTE ser√°n consistentes:</strong></p><ul><li>En sistemas distribuidos, NO puedes tener consistencia inmediata + disponibilidad + tolerancia a particiones (CAP).</li><li>Eliges: Disponibilidad + consistencia eventual.</li></ul><p><strong>EJEMPLO YAPE:</strong></p><ul><li>Yapeas S/100 ‚Üí tu saldo baja inmediatamente (tu vista).</li><li>Destino ve el dinero 2 segundos despu√©s (eventual).</li><li>Ambos estados son 'correctos' en su momento.</li></ul><p><strong>T√âCNICAS:</strong></p><ul><li><strong>Eventos + Idempotencia:</strong> Procesar eventos aunque lleguen duplicados.</li><li><strong>Compensaci√≥n:</strong> Si algo falla, revertir.</li><li><strong>Read-your-writes:</strong> Usuario siempre ve SUS cambios inmediatamente.</li></ul>",
      "analogia": "Es como transferencia bancaria: t√∫ ves menos saldo inmediatamente, el otro lo ve despu√©s. No es 'inconsistente', es 'eventualmente consistente'.",
      "codigo": "// Read-your-writes con cache local\npublic Mono<Saldo> getSaldo(String cuentaId, String usuarioId) {\n    // Primero revisa cache local del usuario (ve sus cambios)\n    return cacheLocal.get(cuentaId + \":\" + usuarioId)\n        .switchIfEmpty(\n            // Si no hay, va a la BD (consistencia eventual)\n            saldoRepository.findByCuentaId(cuentaId)\n        );\n}\n\npublic Mono<Void> transferir(TransferenciaCmd cmd) {\n    return ejecutarTransferencia(cmd)\n        .then(cacheLocal.put(cmd.origen(), nuevoSaldo))  // Usuario ve su cambio\n        .then(publicarEvento(new TransferenciaRealizada(cmd)));  // Eventual\n}",
      "frase": "En microservicios, consistencia inmediata es mentira costosa. Acepta eventual, dise√±a para ella, y duerme tranquilo."
    },
    {
      "id": 61,
      "categoria": "azure",
      "dificultad": "lead",
      "pregunta": "Dise√±a una arquitectura completa en Azure para un sistema bancario de pagos.",
      "respuesta": "<p><strong>üèóÔ∏è ARQUITECTURA AZURE PARA PAGOS:</strong></p><p><strong>ENTRADA:</strong></p><ul><li><strong>Azure Front Door:</strong> CDN + WAF + Load Balancing global.</li><li><strong>API Management:</strong> Rate limiting, auth, throttling.</li></ul><p><strong>C√ìMPUTO:</strong></p><ul><li><strong>AKS:</strong> Microservicios en Kubernetes.</li><li><strong>Azure Functions:</strong> Eventos async (notificaciones).</li></ul><p><strong>DATOS:</strong></p><ul><li><strong>Azure SQL:</strong> Transacciones ACID.</li><li><strong>Cosmos DB:</strong> Lecturas r√°pidas, global distribution.</li><li><strong>Redis Cache:</strong> Sesiones, rate limiting.</li></ul><p><strong>MENSAJER√çA:</strong></p><ul><li><strong>Service Bus:</strong> Colas transaccionales.</li><li><strong>Event Hub:</strong> Streaming alto volumen.</li></ul><p><strong>SEGURIDAD:</strong></p><ul><li><strong>Key Vault:</strong> Secretos.</li><li><strong>Managed Identity:</strong> Auth sin passwords.</li><li><strong>Private Link:</strong> Todo en red privada.</li></ul><p><strong>OBSERVABILIDAD:</strong></p><ul><li><strong>Application Insights:</strong> APM.</li><li><strong>Log Analytics:</strong> Logs centralizados.</li><li><strong>Azure Monitor:</strong> Alertas.</li></ul>",
      "analogia": "Es como construir un banco f√≠sico: Front Door es la fachada con seguridad, AKS son las ventanillas, SQL es la b√≥veda, Redis es la caja chica, Key Vault guarda las llaves maestras.",
      "codigo": "# Terraform simplificado\nresource \"azurerm_kubernetes_cluster\" \"aks\" {\n  name                = \"aks-pagos\"\n  kubernetes_version  = \"1.28\"\n  default_node_pool {\n    vm_size    = \"Standard_D4s_v3\"\n    node_count = 3\n  }\n}\n\nresource \"azurerm_redis_cache\" \"cache\" {\n  name     = \"redis-pagos\"\n  sku_name = \"Premium\"\n}\n\nresource \"azurerm_key_vault\" \"vault\" {\n  name = \"kv-pagos\"\n  sku_name = \"premium\"\n}",
      "frase": "Azure te da los Legos, t√∫ armas el castillo. Esta arquitectura escala a millones de transacciones."
    },
    {
      "id": 62,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© significa BASE vs ACID en bases de datos distribuidas?",
      "respuesta": "<p><strong>ACID (SQL tradicional):</strong></p><ul><li><strong>A</strong>tomicity - Todo o nada</li><li><strong>C</strong>onsistency - Reglas siempre v√°lidas</li><li><strong>I</strong>solation - Transacciones aisladas</li><li><strong>D</strong>urability - Persistencia garantizada</li></ul><p><strong>BASE (NoSQL/Distribuido):</strong></p><ul><li><strong>BA</strong>sically Available - Siempre responde algo</li><li><strong>S</strong>oft state - Estado puede cambiar sin input</li><li><strong>E</strong>ventual consistency - Eventualmente consistente</li></ul><p><strong>CU√ÅNDO USAR:</strong></p><ul><li><strong>ACID:</strong> Transferencias, pagos, inventario cr√≠tico.</li><li><strong>BASE:</strong> Likes, vistas, analytics, cache.</li></ul>",
      "analogia": "ACID es notario: todo legal, firmado, sellado. BASE es WhatsApp: el mensaje llegar√° eventualmente, pero siempre puedes enviar.",
      "codigo": "// ACID - PostgreSQL transaccional\n@Transactional(isolation = Isolation.SERIALIZABLE)\npublic void transferir(String origen, String destino, BigDecimal monto) {\n    cuentaRepo.debitar(origen, monto);\n    cuentaRepo.acreditar(destino, monto);\n}  // Commit o rollback autom√°tico\n\n// BASE - MongoDB eventual\npublic Mono<Void> registrarVista(String videoId) {\n    return mongoTemplate.updateFirst(\n        query(where(\"id\").is(videoId)),\n        new Update().inc(\"vistas\", 1),  // Eventual, no cr√≠tico\n        Video.class\n    ).then();\n}",
      "frase": "No todo necesita ACID. Pagar s√≠. Contar likes no. Usa la herramienta correcta para el problema."
    },
    {
      "id": 63,
      "categoria": "reactivo",
      "dificultad": "lead",
      "pregunta": "¬øCu√°l es la diferencia entre Cold y Hot Publishers en programaci√≥n reactiva?",
      "respuesta": "<p><strong>ü•∂ COLD PUBLISHER (Perezoso):</strong></p><ul><li>NO hace nada hasta que alguien se suscribe.</li><li>Cada suscriptor recibe su PROPIA ejecuci√≥n desde el inicio.</li><li>Ejemplo: Consulta a BD, llamada HTTP.</li></ul><p><strong>üî• HOT PUBLISHER (Activo):</strong></p><ul><li>Emite datos aunque nadie escuche.</li><li>Suscriptores reciben datos desde cuando se conectan (se pierden los anteriores).</li><li>Ejemplo: Eventos de mouse, precios de acciones en tiempo real, WebSocket.</li></ul><p><strong>CONVERTIR:</strong> .share() o .cache() convierten Cold ‚Üí Hot.</p>",
      "analogia": "COLD es Netflix: la pel√≠cula empieza cuando T√ö le das play. HOT es TV en vivo: est√° transmitiendo, te conectas y ves desde ah√≠.",
      "codigo": "// COLD - Cada suscriptor ejecuta la consulta\nMono<Usuario> coldMono = usuarioRepo.findById(\"123\");\ncoldMono.subscribe();  // Ejecuta query\ncoldMono.subscribe();  // Ejecuta query OTRA VEZ\n\n// HOT con cache - Una ejecuci√≥n, m√∫ltiples suscriptores\nMono<Usuario> hotMono = usuarioRepo.findById(\"123\").cache();\nhotMono.subscribe();  // Ejecuta query\nhotMono.subscribe();  // USA CACHE, no re-ejecuta\n\n// HOT con share - Comparte ejecuci√≥n en curso\nFlux<Precio> precios = precioService.streamPrecios().share();\nprecios.subscribe(p -> log.info(\"Suscriptor 1: {}\", p));\nprecios.subscribe(p -> log.info(\"Suscriptor 2: {}\", p));  // Mismo stream",
      "frase": "Cold para consultas (cada uno su resultado). Hot para eventos en tiempo real (todos ven lo mismo)."
    },
    {
      "id": 64,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es el patr√≥n Strangler Fig y c√≥mo migras un monolito sin downtime?",
      "respuesta": "<p><strong>STRANGLER FIG = Migraci√≥n gradual rodeando al monolito:</strong></p><ol><li><strong>Identificar bounded context:</strong> ¬øQu√© dominio extraer primero?</li><li><strong>Crear microservicio nuevo:</strong> Implementa la funcionalidad.</li><li><strong>Facade/Proxy:</strong> Router decide: ¬ømonolito o micro?</li><li><strong>Migrar tr√°fico gradual:</strong> 10% ‚Üí 50% ‚Üí 100% al micro.</li><li><strong>Eliminar c√≥digo del monolito:</strong> Cuando 100% migrado.</li><li><strong>Repetir:</strong> Siguiente dominio.</li></ol><p><strong>DURACI√ìN T√çPICA:</strong> 2-4 a√±os en banca. NO es sprint, es marat√≥n.</p>",
      "analogia": "Strangler Fig es planta que crece ALREDEDOR del √°rbol viejo hasta reemplazarlo. El √°rbol (monolito) sigue vivo mientras la planta (micros) crece.",
      "codigo": "// Facade que decide monolito vs microservicio\n@Service\npublic class TransferenciaFacade {\n    @Value(\"${feature.usar-nuevo-servicio}\") \n    private int porcentajeNuevo;  // 0, 10, 50, 100\n    \n    public Mono<TransferenciaResponse> transferir(TransferenciaCmd cmd) {\n        if (shouldUseNewService()) {\n            return nuevoMicroservicio.transferir(cmd);  // Nuevo\n        }\n        return monolitoClient.transferir(cmd);  // Legacy\n    }\n    \n    private boolean shouldUseNewService() {\n        return random.nextInt(100) < porcentajeNuevo;\n    }\n}",
      "frase": "Migrar monolito de golpe es suicidio. Strangler te da red de seguridad: si el micro falla, el monolito sigue ah√≠."
    },
    {
      "id": 65,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo documentas decisiones arquitect√≥nicas? Explica ADR (Architecture Decision Records).",
      "respuesta": "<p><strong>ADR = Documento corto que explica UNA decisi√≥n t√©cnica:</strong></p><p><strong>ESTRUCTURA:</strong></p><ul><li><strong>T√≠tulo:</strong> ADR-001: Usar PostgreSQL como BD principal.</li><li><strong>Estado:</strong> Propuesto ‚Üí Aceptado ‚Üí Deprecado ‚Üí Reemplazado.</li><li><strong>Contexto:</strong> ¬øQu√© problema enfrentamos?</li><li><strong>Decisi√≥n:</strong> ¬øQu√© decidimos?</li><li><strong>Consecuencias:</strong> Pros, contras, trade-offs.</li><li><strong>Alternativas consideradas:</strong> ¬øQu√© m√°s evaluamos?</li></ul><p><strong>BENEFICIOS:</strong> Nuevos devs entienden el 'por qu√©', evitas re-discutir decisiones, documentaci√≥n viva.</p>",
      "analogia": "ADR es como acta de reuni√≥n de arquitectura: qued√≥ documentado QU√â se decidi√≥, POR QU√â, y QU√â se descart√≥. No hay 'yo no sab√≠a'.",
      "codigo": "# docs/adr/ADR-001-usar-postgresql.md\n\n# ADR-001: Usar PostgreSQL como base de datos principal\n\n## Estado\nAceptado (2024-01-15)\n\n## Contexto\nNecesitamos BD para transacciones bancarias. \nRequisitos: ACID, JSON support, performance.\n\n## Decisi√≥n\nUsaremos PostgreSQL 15.\n\n## Consecuencias\n### Positivas\n- ACID completo para transacciones\n- JSON/JSONB para flexibilidad\n- Ecosistema maduro, buen soporte\n\n### Negativas\n- Escala vertical principalmente\n- Sharding manual si crecemos mucho\n\n## Alternativas Consideradas\n- MySQL: Descartado por JSON support inferior\n- MongoDB: Descartado por necesidad de ACID\n- CockroachDB: Descartado por costo y complejidad",
      "frase": "C√≥digo sin ADRs es como edificio sin planos: nadie sabe por qu√© se construy√≥ as√≠. Documenta decisiones, no solo c√≥digo."
    },
    {
      "id": 66,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es un Predicate en Java y cu√°ndo lo usas? Dame ejemplos en contexto bancario.",
      "respuesta": "<p><strong>Predicate&lt;T&gt; = Funci√≥n que recibe algo y retorna BOOLEAN (true/false):</strong></p><ul><li><strong>Firma:</strong> <code>boolean test(T t)</code></li><li><strong>Uso:</strong> Filtrar, validar, decidir si algo cumple condici√≥n.</li></ul><p><strong>M√âTODOS √öTILES:</strong></p><ul><li><strong>and():</strong> Combinar con AND ‚Üí ambos deben ser true.</li><li><strong>or():</strong> Combinar con OR ‚Üí al menos uno true.</li><li><strong>negate():</strong> Invertir resultado.</li></ul><p><strong>EN BANCA:</strong> Validar si cuenta est√° activa, si monto es v√°lido, si usuario tiene permisos.</p>",
      "analogia": "Predicate es el GUARDIA que pregunta: ¬øCumples el requisito? S√ç o NO. No te da nada, solo te dice si pasas o no.",
      "codigo": "// Predicates para validaci√≥n bancaria\nPredicate<Cuenta> estaActiva = cuenta -> cuenta.getEstado().equals(\"ACTIVA\");\nPredicate<Cuenta> tieneSaldo = cuenta -> cuenta.getSaldo().compareTo(BigDecimal.ZERO) > 0;\nPredicate<BigDecimal> montoValido = monto -> monto.compareTo(BigDecimal.ZERO) > 0;\n\n// Combinando predicates\nPredicate<Cuenta> puedeTransferir = estaActiva.and(tieneSaldo);\n\n// Uso en Stream\nList<Cuenta> cuentasActivas = cuentas.stream()\n    .filter(estaActiva)  // Predicate como filtro\n    .collect(Collectors.toList());\n\n// Uso en WebFlux\npublic Mono<Cuenta> getCuentaActiva(String id) {\n    return cuentaRepo.findById(id)\n        .filter(estaActiva)  // Predicate!\n        .switchIfEmpty(Mono.error(new CuentaInactivaException()));\n}",
      "frase": "Predicate responde S√ç o NO. Nada m√°s. Es tu validador universal."
    },
    {
      "id": 67,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es un Consumer en Java? ¬øCu√°ndo lo usas en lugar de Function?",
      "respuesta": "<p><strong>Consumer&lt;T&gt; = Funci√≥n que RECIBE algo pero NO retorna nada (void):</strong></p><ul><li><strong>Firma:</strong> <code>void accept(T t)</code></li><li><strong>Uso:</strong> Side effects, logging, notificar, guardar.</li></ul><p><strong>VARIANTES:</strong></p><ul><li><strong>BiConsumer&lt;T,U&gt;:</strong> Recibe DOS par√°metros.</li></ul><p><strong>DIFERENCIA CON FUNCTION:</strong></p><ul><li><strong>Function:</strong> Recibe ‚Üí procesa ‚Üí RETORNA resultado.</li><li><strong>Consumer:</strong> Recibe ‚Üí procesa ‚Üí NO retorna nada.</li></ul>",
      "analogia": "Consumer es el BUZ√ìN: le echas la carta y listo. No esperas respuesta. Function es el CAJERO: le das dinero y te da algo a cambio.",
      "codigo": "// Consumer para logging/notificaci√≥n\nConsumer<Transferencia> logTransferencia = tx -> \n    log.info(\"Transferencia: {} -> {} por S/{}\", \n        tx.getOrigen(), tx.getDestino(), tx.getMonto());\n\nConsumer<Transferencia> notificarUsuario = tx ->\n    notificationService.enviar(tx.getUsuarioId(), \"Transferencia exitosa\");\n\n// Combinando consumers\nConsumer<Transferencia> postProceso = logTransferencia.andThen(notificarUsuario);\n\n// Uso en forEach (muy com√∫n)\ntransferencias.forEach(logTransferencia);\n\n// Uso en Reactor - doOnNext\npublic Mono<Transferencia> ejecutar(TransferenciaCmd cmd) {\n    return transferenciaService.procesar(cmd)\n        .doOnNext(logTransferencia)      // Consumer!\n        .doOnNext(notificarUsuario);     // Consumer!\n}",
      "frase": "Consumer es 'hazlo y no me cuentes'. Perfecto para logs, m√©tricas, notificaciones."
    },
    {
      "id": 68,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es un Supplier en Java? ¬øC√≥mo se usa para lazy evaluation?",
      "respuesta": "<p><strong>Supplier&lt;T&gt; = Funci√≥n que NO recibe nada pero RETORNA algo:</strong></p><ul><li><strong>Firma:</strong> <code>T get()</code></li><li><strong>Uso:</strong> Factory, lazy loading, valores por defecto.</li></ul><p><strong>LAZY EVALUATION:</strong></p><ul><li>El c√≥digo dentro del Supplier NO se ejecuta hasta que llamas <code>.get()</code>.</li><li>Perfecto para valores costosos que quiz√°s no necesites.</li></ul>",
      "analogia": "Supplier es la M√ÅQUINA EXPENDEDORA: no le das nada, solo presionas el bot√≥n y te da algo. El producto se prepara cuando lo pides, no antes.",
      "codigo": "// Supplier como factory\nSupplier<UUID> generarId = () -> UUID.randomUUID();\nSupplier<Instant> ahora = () -> Instant.now();\nSupplier<Cuenta> cuentaVacia = () -> Cuenta.builder().saldo(BigDecimal.ZERO).build();\n\n// Lazy evaluation - NO ejecuta hasta que se necesita\nSupplier<BigDecimal> saldoCalculado = () -> {\n    log.info(\"Calculando saldo costoso...\");\n    return calcularSaldoComplejo();  // Solo se ejecuta si se llama .get()\n};\n\n// Uso en Optional - orElseGet vs orElse\nOptional<Cuenta> cuenta = Optional.empty();\n\n// MAL - calcularDefault() se ejecuta SIEMPRE\nCuenta c1 = cuenta.orElse(calcularDefault());\n\n// BIEN - calcularDefault() solo si es vac√≠o (Supplier!)\nCuenta c2 = cuenta.orElseGet(() -> calcularDefault());\n\n// Uso en Reactor\npublic Mono<Cuenta> getCuenta(String id) {\n    return cuentaRepo.findById(id)\n        .switchIfEmpty(Mono.fromSupplier(cuentaVacia));  // Supplier!\n}",
      "frase": "Supplier es lazy: no trabaja hasta que le pides. √ösalo para evitar c√°lculos innecesarios."
    },
    {
      "id": 69,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es Function en Java y cu√°les son sus variantes (BiFunction, UnaryOperator, BinaryOperator)?",
      "respuesta": "<p><strong>Function&lt;T,R&gt; = Recibe T, retorna R (transformaci√≥n):</strong></p><ul><li><strong>Firma:</strong> <code>R apply(T t)</code></li></ul><p><strong>VARIANTES:</strong></p><ul><li><strong>BiFunction&lt;T,U,R&gt;:</strong> Recibe DOS, retorna uno. <code>R apply(T t, U u)</code></li><li><strong>UnaryOperator&lt;T&gt;:</strong> Recibe T, retorna T (mismo tipo). <code>T apply(T t)</code></li><li><strong>BinaryOperator&lt;T&gt;:</strong> Recibe DOS T, retorna T. <code>T apply(T t1, T t2)</code></li></ul><p><strong>M√âTODOS √öTILES:</strong></p><ul><li><strong>andThen():</strong> Encadenar: primero esto, luego aquello.</li><li><strong>compose():</strong> Al rev√©s: primero aquello, luego esto.</li></ul>",
      "analogia": "Function es M√ÅQUINA PROCESADORA: le metes naranjas (T), salen jugo (R). UnaryOperator: metes naranjas, salen naranjas peladas (mismo tipo). BinaryOperator: metes 2 naranjas, sale 1 naranja mezclada.",
      "codigo": "// Function<T, R> - Transforma\nFunction<Cuenta, CuentaDTO> toDTO = cuenta -> \n    new CuentaDTO(cuenta.getId(), cuenta.getSaldo());\n\nFunction<String, Integer> longitud = String::length;\n\n// BiFunction<T, U, R> - Dos inputs\nBiFunction<BigDecimal, BigDecimal, BigDecimal> calcularInteres = \n    (capital, tasa) -> capital.multiply(tasa);\n\n// UnaryOperator<T> - Mismo tipo entrada/salida\nUnaryOperator<BigDecimal> duplicar = monto -> monto.multiply(BigDecimal.valueOf(2));\nUnaryOperator<String> mayusculas = String::toUpperCase;\n\n// BinaryOperator<T> - Dos del mismo tipo\nBinaryOperator<BigDecimal> sumar = BigDecimal::add;\nBinaryOperator<BigDecimal> mayor = (a, b) -> a.compareTo(b) > 0 ? a : b;\n\n// Uso en Stream\nList<CuentaDTO> dtos = cuentas.stream()\n    .map(toDTO)  // Function!\n    .collect(Collectors.toList());\n\nBigDecimal total = montos.stream()\n    .reduce(BigDecimal.ZERO, sumar);  // BinaryOperator!",
      "frase": "Function transforma. UnaryOperator modifica mismo tipo. BinaryOperator combina dos en uno. Memoriza estas 4."
    },
    {
      "id": 70,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øCu√°l es la diferencia entre map, flatMap y filter en Streams de Java?",
      "respuesta": "<p><strong>Los 3 pilares de transformaci√≥n en Streams:</strong></p><p><strong>üîÑ MAP:</strong> Transforma CADA elemento 1 a 1.</p><ul><li>Input: Stream&lt;A&gt; ‚Üí Output: Stream&lt;B&gt;</li><li>Usa: Function&lt;A,B&gt;</li></ul><p><strong>üîÄ FLATMAP:</strong> Transforma Y aplana (cuando map retorna colecci√≥n).</p><ul><li>Input: Stream&lt;A&gt; donde cada A produce Stream&lt;B&gt;</li><li>Output: Stream&lt;B&gt; (aplanado)</li></ul><p><strong>üö´ FILTER:</strong> Descarta elementos que no cumplen condici√≥n.</p><ul><li>Usa: Predicate&lt;A&gt;</li><li>No transforma, solo filtra.</li></ul>",
      "analogia": "MAP es traductor: cada palabra espa√±ol ‚Üí ingl√©s. FLATMAP es traductor que adem√°s separa oraciones en palabras. FILTER es guardia: solo pasan los que cumplen.",
      "codigo": "List<Cuenta> cuentas = obtenerCuentas();\n\n// MAP - Transformar cada cuenta a su saldo\nList<BigDecimal> saldos = cuentas.stream()\n    .map(Cuenta::getSaldo)  // Cuenta ‚Üí BigDecimal\n    .collect(Collectors.toList());\n\n// FILTER - Solo cuentas activas\nList<Cuenta> activas = cuentas.stream()\n    .filter(c -> c.getEstado().equals(\"ACTIVA\"))  // Predicate\n    .collect(Collectors.toList());\n\n// FLATMAP - Cada cuenta tiene lista de movimientos\n// Sin flatMap: Stream<List<Movimiento>>\n// Con flatMap: Stream<Movimiento>\nList<Movimiento> todosMovimientos = cuentas.stream()\n    .flatMap(c -> c.getMovimientos().stream())  // Aplana!\n    .collect(Collectors.toList());\n\n// Combinando los 3\nList<String> idsMovimientosGrandes = cuentas.stream()\n    .filter(c -> c.getEstado().equals(\"ACTIVA\"))      // 1. Filtrar activas\n    .flatMap(c -> c.getMovimientos().stream())        // 2. Aplanar movimientos\n    .filter(m -> m.getMonto().compareTo(new BigDecimal(\"1000\")) > 0)  // 3. Filtrar grandes\n    .map(Movimiento::getId)                            // 4. Extraer IDs\n    .collect(Collectors.toList());",
      "frase": "map transforma 1:1, flatMap transforma y aplana, filter descarta. Son el ABC de Streams."
    },
    {
      "id": 71,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es Optional en Java y c√≥mo evita NullPointerException?",
      "respuesta": "<p><strong>Optional&lt;T&gt; = Contenedor que PUEDE o NO tener valor:</strong></p><ul><li>Representa expl√≠citamente la ausencia de valor.</li><li>Obliga a manejar el caso 'no hay dato'.</li><li>Evita NullPointerException.</li></ul><p><strong>CREAR:</strong></p><ul><li><code>Optional.of(valor)</code> - valor NO puede ser null.</li><li><code>Optional.ofNullable(valor)</code> - valor puede ser null.</li><li><code>Optional.empty()</code> - vac√≠o expl√≠cito.</li></ul><p><strong>CONSUMIR:</strong></p><ul><li><code>isPresent()</code> - ¬øTiene valor?</li><li><code>orElse(default)</code> - Si vac√≠o, usa default.</li><li><code>orElseGet(supplier)</code> - Si vac√≠o, ejecuta supplier.</li><li><code>orElseThrow()</code> - Si vac√≠o, lanza excepci√≥n.</li><li><code>ifPresent(consumer)</code> - Si tiene valor, ejecuta consumer.</li></ul>",
      "analogia": "Optional es CAJA DE REGALO: puede tener regalo o estar vac√≠a. En vez de abrir y que explote (NPE), primero preguntas: ¬øhay algo adentro?",
      "codigo": "// MAL - NullPointerException potential\npublic String getNombreCliente(String cuentaId) {\n    Cuenta cuenta = cuentaRepo.findById(cuentaId);  // Puede ser null!\n    return cuenta.getCliente().getNombre();  // üí• NPE si cuenta es null\n}\n\n// BIEN - Optional expl√≠cito\npublic Optional<String> getNombreCliente(String cuentaId) {\n    return cuentaRepo.findById(cuentaId)          // Optional<Cuenta>\n        .map(Cuenta::getCliente)                   // Optional<Cliente>\n        .map(Cliente::getNombre);                  // Optional<String>\n}\n\n// Uso seguro\nString nombre = getNombreCliente(\"123\")\n    .orElse(\"Cliente Desconocido\");  // Default si vac√≠o\n\n// Con orElseThrow\nString nombre = getNombreCliente(\"123\")\n    .orElseThrow(() -> new ClienteNoEncontradoException());\n\n// ifPresent - ejecuta solo si hay valor\ngetNombreCliente(\"123\")\n    .ifPresent(n -> log.info(\"Cliente: {}\", n));",
      "frase": "Optional hace que 'puede no existir' sea EXPL√çCITO en el c√≥digo. No m√°s nulls sorpresa."
    },
    {
      "id": 72,
      "categoria": "fundamentos",
      "dificultad": "lead",
      "pregunta": "Resume las interfaces funcionales de Java: Predicate, Consumer, Supplier, Function. ¬øCu√°ndo usar cada una?",
      "respuesta": "<p><strong>RESUMEN - Las 4 interfaces funcionales principales:</strong></p><table><tr><th>Interface</th><th>Recibe</th><th>Retorna</th><th>Uso</th><th>M√©todo</th></tr><tr><td><strong>Predicate&lt;T&gt;</strong></td><td>T</td><td>boolean</td><td>Filtrar, validar</td><td>test(T)</td></tr><tr><td><strong>Consumer&lt;T&gt;</strong></td><td>T</td><td>void</td><td>Logs, notificar</td><td>accept(T)</td></tr><tr><td><strong>Supplier&lt;T&gt;</strong></td><td>nada</td><td>T</td><td>Factory, lazy</td><td>get()</td></tr><tr><td><strong>Function&lt;T,R&gt;</strong></td><td>T</td><td>R</td><td>Transformar</td><td>apply(T)</td></tr></table><p><strong>VARIANTES:</strong></p><ul><li><strong>BiPredicate, BiConsumer, BiFunction:</strong> Reciben 2 par√°metros.</li><li><strong>UnaryOperator&lt;T&gt;:</strong> Function donde T=R.</li><li><strong>BinaryOperator&lt;T&gt;:</strong> BiFunction donde T=U=R.</li></ul>",
      "analogia": "PREDICATE = Guardia (¬øpasas? s√≠/no). CONSUMER = Buz√≥n (recibe, no devuelve). SUPPLIER = M√°quina expendedora (solo da). FUNCTION = Procesador (recibe, transforma, devuelve).",
      "codigo": "// Ejemplo completo en un servicio bancario\n@Service\npublic class TransferenciaService {\n    \n    // PREDICATE - Validaci√≥n\n    private final Predicate<TransferenciaCmd> esValida = cmd ->\n        cmd.getMonto().compareTo(BigDecimal.ZERO) > 0;\n    \n    // CONSUMER - Side effects\n    private final Consumer<Transferencia> logExito = tx ->\n        log.info(\"TX exitosa: {}\", tx.getId());\n    \n    // SUPPLIER - Factory/Default\n    private final Supplier<String> generarId = () -> \n        UUID.randomUUID().toString();\n    \n    // FUNCTION - Transformaci√≥n\n    private final Function<TransferenciaCmd, Transferencia> toEntity = cmd ->\n        Transferencia.builder()\n            .id(generarId.get())  // Usa Supplier\n            .origen(cmd.getOrigen())\n            .destino(cmd.getDestino())\n            .monto(cmd.getMonto())\n            .build();\n    \n    public Mono<Transferencia> ejecutar(TransferenciaCmd cmd) {\n        if (!esValida.test(cmd)) {  // Usa Predicate\n            return Mono.error(new ValidacionException());\n        }\n        return Mono.just(cmd)\n            .map(toEntity)           // Usa Function\n            .flatMap(transRepo::save)\n            .doOnSuccess(logExito);  // Usa Consumer\n    }\n}",
      "frase": "Predicate=filtrar, Consumer=efectos, Supplier=generar, Function=transformar. Son los 4 jinetes de Java funcional."
    },
    {
      "id": 73,
      "categoria": "fundamentos",
      "dificultad": "junior",
      "pregunta": "Expl√≠came JVM, JRE y JDK como si fuera un ceviche.",
      "respuesta": "<p><strong>üçã JVM (Java Virtual Machine):</strong> Es el COCINERO. Lee tu receta (bytecode) y prepara el plato. No le importa si la receta es de Lima o Piura, √©l cocina igual en cualquier lado.</p><p><strong>üçΩÔ∏è JRE (Java Runtime Environment):</strong> Es el RESTAURANTE B√ÅSICO. Tiene cocinero + platos + cubiertos. Solo puedes COMER (ejecutar), no cocinar recetas nuevas.</p><p><strong>üë®‚Äçüç≥ JDK (Java Development Kit):</strong> Es la COCINA COMPLETA con escuela de chefs. Puedes CREAR recetas nuevas (compilar c√≥digo).</p><p><strong>RESUMEN:</strong> Usuario = JRE. Developer = JDK. Ambos tienen JVM adentro.</p>",
      "analogia": "JVM cocina. JRE es restaurante. JDK es escuela de cocina + restaurante.",
      "codigo": "# ¬øQu√© tienes instalado?\njava -version   # Tienes JRE (puedes comer)\njavac -version  # Tienes JDK (puedes cocinar)\n\n# El truco m√°gico de Java:\n# Escribes c√≥digo UNA vez, corre en CUALQUIER JVM\n# Windows, Mac, Linux... al JVM le da igual",
      "frase": "JDK para crear, JRE para correr. Simple."
    },
    {
      "id": 74,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "OOP vs Funcional vs Reactivo: ¬øCu√°ndo uso cada uno? Dame un ejemplo con Yape.",
      "respuesta": "<p><strong>üè¢ OOP (Orientado a Objetos):</strong> Para MODELAR cosas del mundo real. Cuenta, Usuario, Transferencia son OBJETOS con datos y comportamiento.</p><p><strong>‚ö° FUNCIONAL:</strong> Para TRANSFORMAR datos sin efectos raros. Filtrar cuentas activas, calcular total, mapear a DTOs.</p><p><strong>üåä REACTIVO:</strong> Para NO QUEDARTE DORMIDO esperando. Mientras consultas saldo, ya est√°s procesando otra cosa.</p><p><strong>EN YAPE:</strong> Modelas Cuenta (OOP), filtras las activas (Funcional), consultas saldo sin bloquear (Reactivo). ¬°Las 3 juntas!</p>",
      "analogia": "OOP = organizar tu empresa en departamentos. Funcional = recetas exactas de cocina. Reactivo = call center donde nadie espera en hold.",
      "codigo": "// OOP - Modelar la cuenta\nCuenta cuenta = new Cuenta(\"123\", 1500.00);\n\n// FUNCIONAL - Filtrar y transformar\ncuentas.stream()\n    .filter(c -> c.estaActiva())  // Solo activas\n    .map(Cuenta::getSaldo)         // Solo saldos\n    .reduce(BigDecimal::add);      // Sumar\n\n// REACTIVO - Sin bloquear\ncuentaRepo.findById(id)  // No esperas, te avisan\n    .map(this::enriquecer)\n    .subscribe();",
      "frase": "OOP para modelar, Funcional para transformar, Reactivo para no dormir. Usa las 3."
    },
    {
      "id": 75,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "Los 4 pilares de OOP explicados con el BCP.",
      "respuesta": "<p><strong>üì¶ ENCAPSULAMIENTO:</strong> El cajero del BCP no te muestra la b√≥veda. Solo ves la ventanilla (m√©todos p√∫blicos), la plata est√° escondida (private).</p><p><strong>üë®‚Äçüë©‚Äçüëß HERENCIA:</strong> CuentaAhorro y CuentaCorriente son hijas de Cuenta. Heredan comportamiento pero cada una tiene lo suyo.</p><p><strong>üé≠ POLIMORFISMO:</strong> El m√©todo <code>cobrarMantenimiento()</code> existe en todas las cuentas, pero cada tipo cobra diferente. Mismo nombre, diferente acci√≥n.</p><p><strong>üé® ABSTRACCI√ìN:</strong> Usas el app del BCP sin saber c√≥mo funciona el core bancario. Solo ves botones, no el c√≥digo de atr√°s.</p>",
      "analogia": "ENCAPSULAR = b√≥veda cerrada. HEREDAR = apellido de familia. POLIMORFISMO = 'pagar' es diferente en efectivo vs tarjeta. ABSTRACCI√ìN = app simple, backend complejo.",
      "codigo": "// El BCP en c√≥digo\npublic class Cuenta {\n    private BigDecimal saldo;  // ENCAPSULADO - nadie toca directo\n    public BigDecimal getSaldo() { return saldo; }  // Acceso controlado\n}\n\npublic class CuentaAhorro extends Cuenta {  // HERENCIA\n    public void cobrarMantenimiento() {\n        // POLIMORFISMO - cada cuenta cobra diferente\n        this.debitar(5.00);  \n    }\n}\n\n// ABSTRACCI√ìN - usas sin saber c√≥mo funciona\ncuenta.transferir(destino, 100);  // ¬øC√≥mo lo hace? No te importa",
      "frase": "OOP es el BCP: b√≥veda cerrada, cuentas que heredan, cada una cobra diferente, y t√∫ solo ves el app."
    },
    {
      "id": 76,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© trajo Java 11 y por qu√© todos lo usan en empresas?",
      "respuesta": "<p><strong>Java 11 = El Toyota Corolla de Java.</strong> No es el m√°s sexy pero es LTS (Long Term Support) = soporte por A√ëOS, no meses.</p><p><strong>LO NUEVO:</strong></p><ul><li><strong>var en lambdas:</strong> Menos tipeo.</li><li><strong>Strings mejorados:</strong> isBlank(), strip(), repeat().</li><li><strong>HttpClient nuevo:</strong> Adi√≥s al horrible HttpURLConnection.</li><li><strong>Correr sin compilar:</strong> <code>java MiApp.java</code> directo.</li></ul><p><strong>¬øPOR QU√â LTS IMPORTA?</strong> Las empresas quieren ESTABILIDAD. No van a actualizar Java cada 6 meses. LTS = tranquilidad.</p>",
      "analogia": "LTS es Toyota: no es el m√°s nuevo pero hay repuestos por a√±os. Non-LTS es Tesla beta: cool pero arriesgado.",
      "codigo": "// Java 11 goodies\n\"  \".isBlank();        // true - ¬°al fin!\n\"hola\".repeat(3);     // \"holaholahola\"\n\"  hola  \".strip();   // \"hola\" - mejor que trim()\n\n// HttpClient moderno (ya no es 1999)\nvar client = HttpClient.newHttpClient();\nvar request = HttpRequest.newBuilder()\n    .uri(URI.create(\"https://api.yape.com/saldo\"))\n    .GET().build();\nvar response = client.send(request, BodyHandlers.ofString());\n\n// Correr directo sin javac\n// $ java MiScript.java",
      "frase": "Java 11 LTS: el que usan las empresas serias. Estable, soporte largo, cero drama."
    },
    {
      "id": 77,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© trajo Java 17 que hace que todos quieran migrar?",
      "respuesta": "<p><strong>Java 17 = Records y Pattern Matching.</strong> Menos c√≥digo, mismo resultado.</p><p><strong>RECORDS:</strong> DTOs en UNA l√≠nea. Adi√≥s a 50 l√≠neas de getters, setters, equals, hashCode.</p><p><strong>PATTERN MATCHING:</strong> El instanceof ahora hace cast autom√°tico. Ya no escribes el cast manual.</p><p><strong>SEALED CLASSES:</strong> T√∫ decides qui√©n puede heredar de tu clase. Control total.</p><p><strong>TEXT BLOCKS:</strong> Strings multil√≠nea con triple comilla. JSON y SQL legibles.</p><p><strong>¬øPOR QU√â MIGRAR?</strong> Spring Boot 3+ REQUIERE Java 17 m√≠nimo. No hay opci√≥n.</p>",
      "analogia": "Java 17 es escribir 'CuentaDTO' y que Java genere 50 l√≠neas por ti. Menos c√≥digo = menos bugs.",
      "codigo": "// RECORD - DTO en 1 l√≠nea (antes eran 50+)\npublic record CuentaDTO(String id, BigDecimal saldo) {}\n// ¬°Ya tiene constructor, getters, equals, hashCode, toString!\n\n// PATTERN MATCHING - Cast autom√°tico\n// ANTES (Java 11)\nif (obj instanceof Cuenta) {\n    Cuenta c = (Cuenta) obj;  // Cast manual üò¥\n    return c.getSaldo();\n}\n// DESPU√âS (Java 17)\nif (obj instanceof Cuenta c) {  // Cast autom√°tico üî•\n    return c.getSaldo();\n}\n\n// TEXT BLOCKS - JSON legible\nString json = \"\"\"\n    {\"nombre\": \"Juan\", \"saldo\": 1500}\n    \"\"\";",
      "frase": "Java 17: Records eliminan boilerplate, Pattern Matching elimina casts. Spring Boot 3 lo exige."
    },
    {
      "id": 78,
      "categoria": "fundamentos",
      "dificultad": "lead",
      "pregunta": "¬øQu√© son los Virtual Threads de Java 21 y por qu√© cambian todo?",
      "respuesta": "<p><strong>Virtual Threads = MILLONES de hilos sin sudar.</strong></p><p><strong>ANTES (Platform Threads):</strong> Cada hilo = recursos del sistema operativo. M√°ximo ~10,000 hilos antes de que tu servidor llore.</p><p><strong>AHORA (Virtual Threads):</strong> La JVM maneja los hilos. Puedes crear MILLONES. C√≥digo bloqueante se vuelve eficiente.</p><p><strong>¬øQU√â SIGNIFICA?</strong> Puedes escribir c√≥digo simple (bloqueante) y tener performance de c√≥digo reactivo. Lo mejor de ambos mundos.</p><p><strong>¬øADI√ìS WEBFLUX?</strong> Para muchos casos, s√≠. Virtual Threads simplifican todo.</p>",
      "analogia": "Antes ten√≠as 10 empleados caros que cobraban aunque esperaran. Ahora tienes infinitos empleados gratis que solo trabajan cuando hay chamba.",
      "codigo": "// ANTES - M√°ximo ~10,000 hilos\nExecutorService executor = Executors.newFixedThreadPool(100);\n\n// JAVA 21 - Millones de hilos, cero drama\nExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();\n\n// O m√°s simple\nThread.startVirtualThread(() -> {\n    // C√≥digo bloqueante PERO eficiente\n    var saldo = httpClient.send(request);  // Bloquea sin problema\n    database.save(saldo);  // Bloquea sin problema\n    // La JVM maneja todo internamente\n});\n\n// 1 mill√≥n de virtual threads? No hay problema\nfor (int i = 0; i < 1_000_000; i++) {\n    Thread.startVirtualThread(() -> hacerAlgo());\n}",
      "frase": "Virtual Threads: c√≥digo simple con performance de reactivo. Game changer de Java 21."
    },
    {
      "id": 79,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "Spring Boot vs Quarkus: ¬øCu√°l elijo para mi microservicio?",
      "respuesta": "<p><strong>üçÉ SPRING BOOT:</strong> El VETERANO. Todo el mundo lo conoce, documentaci√≥n infinita, librer√≠as para todo. Arranca en 2-5 segundos, usa 200-500MB RAM.</p><p><strong>‚ö° QUARKUS:</strong> El JOVEN VELOZ. Naci√≥ para containers y serverless. Arranca en 0.02 segundos (native), usa 20MB RAM.</p><p><strong>¬øCU√ÅNDO SPRING?</strong> Empresa grande, equipo que ya lo conoce, necesitas TODO el ecosistema.</p><p><strong>¬øCU√ÅNDO QUARKUS?</strong> Kubernetes, serverless, cada milisegundo y MB cuenta, escalar a 0.</p>",
      "analogia": "Spring Boot = Land Cruiser: pesado pero va a cualquier lado. Quarkus = Moto deportiva: arranca en 1 segundo, liviana, perfecta para delivery.",
      "codigo": "// SPRING BOOT - El cl√°sico\n@RestController\npublic class CuentaController {\n    @Autowired CuentaService service;\n    \n    @GetMapping(\"/cuentas/{id}\")\n    public Cuenta get(@PathVariable String id) {\n        return service.findById(id);\n    }\n}\n\n// QUARKUS - El veloz\n@Path(\"/cuentas\")\npublic class CuentaResource {\n    @Inject CuentaService service;\n    \n    @GET @Path(\"/{id}\")\n    public Cuenta get(@PathParam(\"id\") String id) {\n        return service.findById(id);\n    }\n}\n\n// Quarkus native: 50MB ejecutable, 0.02s startup\n# ./mvnw package -Pnative",
      "frase": "Spring Boot cuando necesitas todo. Quarkus cuando cada MB y milisegundo cuenta."
    },
    {
      "id": 80,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es Inyecci√≥n de Dependencias? Expl√≠calo con un ceviche.",
      "respuesta": "<p><strong>SIN INYECCI√ìN:</strong> Eres chef que va al mercado, compra pescado, limones, cebolla, cocina todo. Si cambia el proveedor de pescado, tienes que cambiar TU c√≥digo.</p><p><strong>CON INYECCI√ìN:</strong> Eres chef al que le TRAEN los ingredientes ya listos. Solo cocinas. ¬øCambi√≥ el proveedor? No te importa, te siguen trayendo pescado.</p><p><strong>EN C√ìDIGO:</strong> No haces <code>new MiDependencia()</code>. El framework te la INYECTA. Desacoplado, testeable, flexible.</p>",
      "analogia": "Sin DI: vas al mercado. Con DI: te traen los ingredientes. T√∫ solo cocinas.",
      "codigo": "// ‚ùå SIN INYECCI√ìN - Acoplado, dif√≠cil testear\npublic class TransferenciaService {\n    private CuentaRepo repo = new CuentaRepoImpl();  // T√ö lo creas\n    private Notificador notif = new EmailNotificador();  // T√ö lo creas\n    // ¬øQuieres cambiar a SMS? Tienes que modificar ESTA clase\n}\n\n// ‚úÖ CON INYECCI√ìN - Desacoplado, testeable\n@Service\npublic class TransferenciaService {\n    private final CuentaRepo repo;      // Solo declaras\n    private final Notificador notif;    // Solo declaras\n    \n    public TransferenciaService(CuentaRepo repo, Notificador notif) {\n        this.repo = repo;    // Spring te lo INYECTA\n        this.notif = notif;  // Spring te lo INYECTA\n    }\n}\n\n// En test: inyectas MOCKS f√°cilmente\nvar service = new TransferenciaService(mockRepo, mockNotif);",
      "frase": "DI: t√∫ declaras qu√© necesitas, el framework te lo da. C√≥digo limpio, testeable."
    },
    {
      "id": 81,
      "categoria": "fundamentos",
      "dificultad": "junior",
      "pregunta": "¬øQu√© es Lombok y por qu√© TODOS lo usan?",
      "respuesta": "<p><strong>Lombok = Tu asistente que escribe c√≥digo aburrido.</strong></p><p>Antes escrib√≠as 50 l√≠neas de getters, setters, constructores, equals, hashCode, toString. Ahora pones UNA anotaci√≥n y Lombok lo genera.</p><p><strong>LAS 3 ANOTACIONES QUE USAR√ÅS SIEMPRE:</strong></p><ul><li><strong>@Data:</strong> Getters + Setters + equals + hashCode + toString.</li><li><strong>@Builder:</strong> Patr√≥n Builder autom√°tico.</li><li><strong>@Slf4j:</strong> Logger listo para usar.</li></ul>",
      "analogia": "Lombok es tu practicante que escribe el c√≥digo aburrido. T√∫ dices '@Data' y √©l escribe 50 l√≠neas.",
      "codigo": "// SIN LOMBOK - 50+ l√≠neas de c√≥digo aburrido üò¥\npublic class Cuenta {\n    private String id;\n    private BigDecimal saldo;\n    // + getter getId(), setter setId()\n    // + getter getSaldo(), setter setSaldo()\n    // + equals(), hashCode(), toString()\n    // + constructores...\n    // ABURRIDO.\n}\n\n// CON LOMBOK - 5 l√≠neas y listo üî•\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Cuenta {\n    private String id;\n    private BigDecimal saldo;\n}\n\n// Uso del Builder generado\nCuenta cuenta = Cuenta.builder()\n    .id(\"123\")\n    .saldo(new BigDecimal(\"1500\"))\n    .build();\n\n// @Slf4j te da logger gratis\n@Slf4j\n@Service\npublic class MiServicio {\n    public void hacer() {\n        log.info(\"Funcionando!\");  // log ya existe!\n    }\n}",
      "frase": "@Data + @Builder + @Slf4j en cada clase. Lombok es obligatorio en Java moderno."
    },
    {
      "id": 82,
      "categoria": "seguridad",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es JWT? Expl√≠calo como pase VIP de concierto.",
      "respuesta": "<p><strong>JWT = Tu pase VIP firmado.</strong></p><p>Tiene tu nombre, zona permitida (roles), fecha de vencimiento, y un holograma (firma) que prueba que es real.</p><p><strong>3 PARTES:</strong></p><ul><li><strong>Header:</strong> Tipo de pase y c√≥mo verificar.</li><li><strong>Payload:</strong> Tu info (userId, roles, cu√°ndo expira).</li><li><strong>Signature:</strong> El holograma que prueba que es real.</li></ul><p><strong>FLUJO:</strong> Login ‚Üí Te dan JWT ‚Üí Lo mandas en cada request ‚Üí Servidor verifica holograma y te deja pasar.</p><p><strong>MAGIA:</strong> El servidor NO guarda sesiones. Todo est√° en el token. STATELESS.</p>",
      "analogia": "JWT es tu pase VIP: tiene tu nombre, zona permitida, vencimiento, y holograma. El guardia lo verifica sin llamar a nadie.",
      "codigo": "// JWT se ve as√≠ (3 partes separadas por punto)\n// eyJhbGc.eyJzdWI.firma\n// HEADER.PAYLOAD.SIGNATURE\n\n// GENERAR TOKEN\nString token = Jwts.builder()\n    .setSubject(usuario.getId())        // Qui√©n eres\n    .claim(\"roles\", usuario.getRoles()) // Qu√© puedes hacer\n    .setExpiration(new Date(now + 1hora))  // Cu√°ndo expira\n    .signWith(SECRET_KEY)               // Firmar (holograma)\n    .compact();\n\n// ENVIAR EN CADA REQUEST\n// Authorization: Bearer eyJhbGc.eyJzdWI.firma\n\n// VALIDAR\nClaims claims = Jwts.parser()\n    .setSigningKey(SECRET_KEY)\n    .parseClaimsJws(token)\n    .getBody();\n// Si la firma no cuadra = token falso = 401",
      "frase": "JWT: pase firmado con todo tu info. Servidor no guarda nada, todo est√° en el token."
    },
    {
      "id": 83,
      "categoria": "seguridad",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es OAuth2? Expl√≠calo como valet parking.",
      "respuesta": "<p><strong>OAuth2 = Valet parking para tus datos.</strong></p><p>Le das una llave ESPECIAL (token) al valet (app) para que estacione tu carro. Pero NO le das la llave de tu casa. Acceso LIMITADO y TEMPORAL.</p><p><strong>FLUJOS PRINCIPALES:</strong></p><ul><li><strong>Authorization Code:</strong> Web apps. Usuario aprueba, app recibe c√≥digo, intercambia por token.</li><li><strong>Client Credentials:</strong> M√°quina a m√°quina. Sin usuario. Servicio A habla con Servicio B.</li></ul><p><strong>NO CONFUNDIR:</strong> OAuth2 es AUTORIZACI√ìN (qu√© puedes hacer), no AUTENTICACI√ìN (qui√©n eres).</p>",
      "analogia": "OAuth2 = valet parking: llave especial para estacionar, no para entrar a tu casa. Acceso limitado.",
      "codigo": "// AUTHORIZATION CODE FLOW (Web apps)\n// 1. Usuario va a login\nGET https://auth.banco.com/authorize?\n    response_type=code&\n    client_id=mi-app&\n    redirect_uri=https://mi-app/callback&\n    scope=leer:saldo\n\n// 2. Usuario aprueba, recibe c√≥digo\n// 3. Backend intercambia c√≥digo por token\nPOST https://auth.banco.com/token\n    grant_type=authorization_code&\n    code=ABC123&\n    client_secret=SECRET\n\n// 4. Recibe tokens\n{\"access_token\": \"eyJ...\", \"refresh_token\": \"eyJ...\"}\n\n// CLIENT CREDENTIALS (servicio a servicio)\nPOST https://auth.banco.com/token\n    grant_type=client_credentials&\n    client_id=mi-servicio&\n    client_secret=SECRET\n// No hay usuario, es m√°quina hablando con m√°quina",
      "frase": "Authorization Code para web apps con usuarios. Client Credentials para servicios hablando entre s√≠."
    },
    {
      "id": 84,
      "categoria": "seguridad",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo protejo mis microservicios con Spring Security + JWT?",
      "respuesta": "<p><strong>ARQUITECTURA:</strong></p><ul><li><strong>Gateway:</strong> Valida JWT una vez. Extrae claims.</li><li><strong>Microservicios:</strong> Reciben claims en headers, conf√≠an en Gateway.</li></ul><p><strong>FLUJO:</strong> Request ‚Üí Gateway valida JWT ‚Üí Extrae userId/roles ‚Üí Propaga headers ‚Üí Microservicio conf√≠a y autoriza.</p><p><strong>SPRING SECURITY:</strong> Defines qu√© rutas son p√∫blicas, cu√°les necesitan auth, cu√°les necesitan roles espec√≠ficos.</p>",
      "analogia": "Gateway es recepci√≥n del edificio: valida tu credencial UNA vez. Cada oficina ve tu gafete y decide si te deja pasar.",
      "codigo": "@Configuration\n@EnableWebFluxSecurity\npublic class SecurityConfig {\n    @Bean\n    public SecurityWebFilterChain security(ServerHttpSecurity http) {\n        return http\n            .csrf(c -> c.disable())\n            .authorizeExchange(auth -> auth\n                .pathMatchers(\"/public/**\").permitAll()     // Libre\n                .pathMatchers(\"/admin/**\").hasRole(\"ADMIN\") // Solo admin\n                .pathMatchers(\"/api/**\").authenticated()    // Logueado\n                .anyExchange().authenticated()\n            )\n            .oauth2ResourceServer(oauth -> oauth.jwt())\n            .build();\n    }\n}\n\n// Control fino en m√©todo\n@PreAuthorize(\"hasRole('ADMIN') or #userId == authentication.name\")\npublic Mono<Cuenta> getCuenta(String userId) {\n    return cuentaRepo.findByUserId(userId);\n}",
      "frase": "Gateway valida una vez, microservicios conf√≠an en headers. Defense in depth."
    },
    {
      "id": 85,
      "categoria": "data",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es Kafka? Expl√≠calo como peri√≥dico vs carta.",
      "respuesta": "<p><strong>KAFKA = PERI√ìDICO.</strong> Se imprime una vez, TODOS pueden leerlo, queda en archivo PARA SIEMPRE. Puedes leer el peri√≥dico de ayer.</p><p><strong>RABBITMQ = CARTA.</strong> Se entrega a UNO, confirmas recibido, se destruye.</p><p><strong>CONCEPTOS KAFKA:</strong></p><ul><li><strong>Topic:</strong> El peri√≥dico (ej: 'transferencias').</li><li><strong>Partition:</strong> Secciones del peri√≥dico para leer en paralelo.</li><li><strong>Producer:</strong> El que escribe noticias.</li><li><strong>Consumer:</strong> El que lee noticias.</li><li><strong>Offset:</strong> P√°gina donde te quedaste. Puedes volver atr√°s.</li></ul>",
      "analogia": "Kafka = peri√≥dico: todos leen, queda archivado. RabbitMQ = carta: uno recibe, se destruye.",
      "codigo": "// PRODUCER - Publicar evento\n@Service\npublic class EventPublisher {\n    @Autowired KafkaTemplate<String, Object> kafka;\n    \n    public void publicar(TransferenciaEvent evento) {\n        kafka.send(\"transferencias\",     // Topic\n            evento.getCuentaId(),         // Partition key\n            evento);                      // Mensaje\n    }\n}\n\n// CONSUMER - Leer eventos\n@Service\npublic class EventConsumer {\n    @KafkaListener(topics = \"transferencias\", groupId = \"notificaciones\")\n    public void procesar(TransferenciaEvent evento) {\n        log.info(\"Recibido: {}\", evento);\n        // Procesar...\n    }\n}",
      "frase": "Kafka para eventos que necesitas guardar y replayear. RabbitMQ para colas simples."
    },
    {
      "id": 86,
      "categoria": "data",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo garantizo que Kafka NO pierda mensajes de transferencias?",
      "respuesta": "<p><strong>GARANTIZAR ORDEN:</strong> Usa Partition Key = ID de cuenta. Todas las transferencias de la misma cuenta van a la misma partici√≥n ‚Üí ORDEN garantizado.</p><p><strong>NO PERDER MENSAJES:</strong></p><ul><li><strong>Producer:</strong> <code>acks=all</code> (espera que TODAS las r√©plicas confirmen).</li><li><strong>Producer:</strong> <code>enable.idempotence=true</code> (evita duplicados).</li><li><strong>Consumer:</strong> Commit MANUAL despu√©s de procesar exitosamente.</li></ul><p><strong>SI FALLA MUCHO:</strong> Dead Letter Topic (DLT) para mensajes problem√°ticos.</p>",
      "analogia": "acks=all = carta certificada: no dicen OK hasta que firmaste. Partition key = fila del banco: misma fila, mismo orden.",
      "codigo": "# application.yml - Producer seguro\nspring.kafka.producer:\n  acks: all                    # Espera TODAS las r√©plicas\n  enable-idempotence: true     # No duplica si reintenta\n  retries: 3\n\n// Consumer con commit manual\n@KafkaListener(topics = \"transferencias\")\npublic void procesar(TransferenciaEvent e, Acknowledgment ack) {\n    try {\n        procesar(e);\n        ack.acknowledge();  // Commit SOLO si proces√≥ bien\n    } catch (Exception ex) {\n        // NO hace commit, se reprocesa\n        log.error(\"Fall√≥: {}\", ex.getMessage());\n    }\n}\n\n// Partition key para orden\nkafka.send(\"transferencias\", \n    evento.getCuentaId(),  // KEY: mismo ID = misma partici√≥n = orden\n    evento);",
      "frase": "acks=all, idempotencia, commit manual, partition key. Perder transferencia = perder plata."
    },
    {
      "id": 87,
      "categoria": "data",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es Outbox Pattern y por qu√© lo necesito con Kafka?",
      "respuesta": "<p><strong>EL PROBLEMA:</strong> Guardas en BD y luego publicas a Kafka. ¬øQu√© pasa si la BD guarda pero Kafka falla? Inconsistencia.</p><p><strong>OUTBOX PATTERN:</strong></p><ol><li>En la MISMA transacci√≥n: guarda datos + guarda evento en tabla <code>outbox</code>.</li><li>Debezium (CDC) lee la tabla <code>outbox</code>.</li><li>Debezium publica a Kafka.</li></ol><p><strong>RESULTADO:</strong> Si la transacci√≥n falla, no hay evento. Si pasa, HAY evento. Consistencia garantizada.</p>",
      "analogia": "Outbox = dejar carta en bandeja de salida. La transacci√≥n la deja ah√≠, el cartero (Debezium) la recoge y env√≠a.",
      "codigo": "// Transacci√≥n at√≥mica: datos + evento\n@Transactional\npublic Mono<Transferencia> ejecutar(TransferenciaCmd cmd) {\n    return transferenciaRepo.save(cmd.toEntity())\n        // En la MISMA transacci√≥n, guarda en outbox\n        .flatMap(tx -> outboxRepo.save(OutboxEvent.builder()\n            .aggregateType(\"Transferencia\")\n            .aggregateId(tx.getId())\n            .type(\"TransferenciaCreada\")\n            .payload(toJson(tx))\n            .build())\n            .thenReturn(tx));\n}\n// Si falla cualquier cosa, se hace rollback de TODO\n// Debezium lee outbox y publica a Kafka\n// Consistencia BD + Kafka garantizada",
      "frase": "Outbox: evento en misma transacci√≥n que datos. Debezium lo publica. Consistencia garantizada."
    },
    {
      "id": 88,
      "categoria": "cloud",
      "dificultad": "senior",
      "pregunta": "Docker en 5 comandos: ¬øCu√°les necesito saber s√≠ o s√≠?",
      "respuesta": "<p><strong>LOS 5 COMANDOS QUE USAR√ÅS SIEMPRE:</strong></p><ul><li><code>docker build -t mi-app:v1 .</code> ‚Üí Construir imagen.</li><li><code>docker run -d -p 8080:8080 mi-app</code> ‚Üí Correr container.</li><li><code>docker ps</code> ‚Üí Ver qu√© est√° corriendo.</li><li><code>docker logs -f mi-container</code> ‚Üí Ver logs.</li><li><code>docker exec -it mi-container sh</code> ‚Üí Entrar al container.</li></ul><p><strong>BONUS:</strong> <code>docker-compose up -d</code> para levantar todo el ambiente local.</p>",
      "analogia": "Docker = tupperware de c√≥digo: empacas tu app con TODO, la cierras, funciona igual en cualquier refri (servidor).",
      "codigo": "# DOCKERFILE para Spring Boot\nFROM eclipse-temurin:17-jre-alpine\nCOPY target/*.jar app.jar\nEXPOSE 8080\nCMD [\"java\", \"-jar\", \"app.jar\"]\n\n# Los 5 comandos\ndocker build -t mi-app:v1 .           # Construir\ndocker run -d -p 8080:8080 mi-app:v1  # Correr\ndocker ps                              # Ver corriendo\ndocker logs -f mi-app                  # Ver logs\ndocker exec -it mi-app sh              # Entrar\n\n# docker-compose.yml para desarrollo\nservices:\n  app:\n    build: .\n    ports: [\"8080:8080\"]\n  postgres:\n    image: postgres:15\n    environment:\n      POSTGRES_PASSWORD: secret\n\n# Levantar todo\ndocker-compose up -d",
      "frase": "build, run, ps, logs, exec. Con esos 5 sobrevives. docker-compose para desarrollo local."
    },
    {
      "id": 89,
      "categoria": "cloud",
      "dificultad": "lead",
      "pregunta": "Kubernetes en 6 comandos: ¬øCu√°les me salvan a las 3am?",
      "respuesta": "<p><strong>LOS 6 COMANDOS QUE TE SALVAN:</strong></p><ul><li><code>kubectl get pods</code> ‚Üí ¬øQu√© hay corriendo?</li><li><code>kubectl describe pod X</code> ‚Üí ¬øPor qu√© fall√≥?</li><li><code>kubectl logs -f X</code> ‚Üí ¬øQu√© dice?</li><li><code>kubectl exec -it X -- sh</code> ‚Üí Entrar al pod.</li><li><code>kubectl rollout undo deployment/X</code> ‚Üí ¬°ROLLBACK!</li><li><code>kubectl apply -f X.yaml</code> ‚Üí Desplegar cambios.</li></ul>",
      "analogia": "kubectl = control remoto de tu datacenter. get=ver, describe=detalles, logs=qu√© dice, exec=entrar, rollout=gestionar versiones.",
      "codigo": "# ¬øQu√© est√° pasando?\nkubectl get pods                    # Ver pods\nkubectl get pods -w                 # Watch en vivo\n\n# ¬øPor qu√© falla?\nkubectl describe pod mi-pod-xyz     # Eventos y errores\nkubectl logs -f mi-pod-xyz          # Logs\n\n# Debugging\nkubectl exec -it mi-pod-xyz -- sh   # Entrar\n\n# Deploy y emergencias\nkubectl apply -f k8s/               # Aplicar yamls\nkubectl rollout undo deployment/X   # ¬°ROLLBACK!\nkubectl scale deployment/X --replicas=10  # Escalar\n\n# Matar pod (K8s lo recrea)\nkubectl delete pod mi-pod-xyz",
      "frase": "get, describe, logs, exec, rollout, apply. Los 6 comandos que te salvan a las 3am."
    },
    {
      "id": 90,
      "categoria": "reactivo",
      "dificultad": "lead",
      "pregunta": "¬øPor qu√© Reactivo y no solo Async? ¬øCu√°l es la diferencia real?",
      "respuesta": "<p><strong>ASYNC TRADICIONAL:</strong> 'Av√≠same cuando termine'. Callbacks anidados, callback hell, dif√≠cil componer.</p><p><strong>REACTIVO:</strong> STREAMS de datos con operadores. map, filter, flatMap. Backpressure incluido. Manejo de errores unificado.</p><p><strong>LA DIFERENCIA REAL:</strong> Async es 'espero tu llamada'. Reactivo es 'procesa este FLUJO de datos como quieras'.</p>",
      "analogia": "Async = esperar llamada del delivery. Reactivo = buffet libre donde los platos llegan y t√∫ decides cu√°ntos puedes comer (backpressure).",
      "codigo": "// CALLBACK HELL üòµ\ngetUsuario(id, usuario -> {\n    getCuentas(usuario, cuentas -> {\n        getSaldo(cuentas, saldo -> {\n            // 3 niveles de anidaci√≥n...\n        });\n    });\n});\n\n// REACTIVO üî• - Limpio, declarativo\nMono.just(id)\n    .flatMap(this::getUsuario)\n    .flatMap(this::getCuentas)\n    .flatMap(this::getSaldo)\n    .doOnError(e -> log.error(e.getMessage()))\n    .subscribe();\n\n// Backpressure - \"solo puedo procesar 10 a la vez\"\nFlux.fromIterable(millonDeEventos)\n    .onBackpressureBuffer(100)  // M√°x 100 en cola\n    .flatMap(this::procesar, 10) // M√°x 10 paralelo\n    .subscribe();",
      "frase": "Reactivo = async con superpoderes: streams, operadores, backpressure. No es solo 'no bloquear'."
    }
  ]
}
