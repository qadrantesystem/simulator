{
  "metadata": {
    "version": "1.0",
    "totalPreguntas": 65,
    "categorias": ["arquitectura", "reactivo", "resiliencia", "cloud", "data", "seguridad", "observabilidad", "liderazgo", "patrones", "azure", "fundamentos"]
  },
  "preguntas": [
    {
      "id": 1,
      "categoria": "arquitectura",
      "dificultad": "senior",
      "pregunta": "Si tuvieras que dise√±ar la arquitectura de APIs para una app tipo Yape (saldos, transferencias, pagos), ¬øc√≥mo la estructurar√≠as?",
      "respuesta": "<p>Usar√≠a <strong>3 capas de APIs</strong>:</p><ul><li><strong>API de Experiencia (BFF)</strong> - Es el MOZO. Orquesta llamadas, junta datos y entrega al cliente. Uso WebFlux.</li><li><strong>API de Negocio</strong> - Son las COCINAS especializadas. Un microservicio por dominio.</li><li><strong>API de Sincronizaci√≥n</strong> - El ALMAC√âN VIEJO. Conecta con el core bancario legacy.</li></ul><p>Regla de oro: <strong>NUNCA expones el negocio directamente</strong>.</p>",
      "analogia": "Es como una poller√≠a: el mozo (experiencia) atiende, las cocinas (negocio) preparan, el almac√©n (sincronizaci√≥n) tiene la materia prima.",
      "codigo": "@Bean\npublic RouteLocator routes(RouteLocatorBuilder builder) {\n    return builder.routes()\n        .route(\"saldos\", r -> r\n            .path(\"/api/saldos/**\")\n            .filters(f -> f.circuitBreaker(c -> c.setName(\"saldosCB\")))\n            .uri(\"lb://ms-saldos\"))\n        .build();\n}",
      "frase": "Las APIs de experiencia son el mozo, las de negocio son las cocinas, y las de sincronizaci√≥n van al almac√©n viejo."
    },
    {
      "id": 2,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "Expl√≠came la diferencia entre Arquitectura Hexagonal y Clean Architecture. ¬øCu√°ndo usar√≠as cada una?",
      "respuesta": "<p>Ambas separan negocio de infraestructura:</p><ul><li><strong>Hexagonal (Ports & Adapters)</strong> - Tu negocio es una ISLA. Los puertos son MUELLES donde llegan barcos (adaptadores).</li><li><strong>Clean Architecture</strong> - CAPAS DE CEBOLLA. Centro = negocio, capas externas dependen de internas.</li></ul><p><strong>Hexagonal:</strong> Muchas integraciones externas. <strong>Clean:</strong> Dominio muy complejo.</p>",
      "analogia": "Hexagonal es una isla con muelles para distintos barcos. Clean es una cebolla con capas que protegen el centro.",
      "codigo": "// Puerto (interface)\npublic interface CuentaRepository {\n    Mono<Cuenta> findById(String id);\n}\n\n// Adaptador MongoDB\n@Repository\npublic class CuentaMongoAdapter implements CuentaRepository {\n    public Mono<Cuenta> findById(String id) {\n        return mongoTemplate.findById(id, CuentaDocument.class)\n            .map(this::toDomain);\n    }\n}",
      "frase": "Hexagonal te permite cambiar de MongoDB a PostgreSQL sin tocar una l√≠nea del negocio."
    },
    {
      "id": 3,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es CQRS y cu√°ndo lo aplicar√≠as en un sistema bancario?",
      "respuesta": "<p>CQRS = DOS PIZARRAS:</p><ul><li><strong>Command (Escritura)</strong> - Operaciones complejas, validaciones. PostgreSQL normalizado.</li><li><strong>Query (Lectura)</strong> - Optimizada para mostrar. MongoDB/Redis desnormalizado.</li></ul><p><strong>Usar cuando:</strong> Lees mucho m√°s de lo que escribes (80/20). Historial de movimientos en Yape.</p>",
      "analogia": "Dos pizarras: una para escribir con calma (validaciones) y otra para leer volando (optimizada).",
      "codigo": "// Command - Escribir\npublic Mono<Void> transferir(TransferenciaCmd cmd) {\n    return cuentaRepo.findById(cmd.getOrigen())\n        .flatMap(cuenta -> cuenta.debitar(cmd.getMonto()))\n        .then(eventPublisher.publish(new TransferenciaEvent(cmd)));\n}\n\n// Query - Leer\npublic Flux<MovimientoDTO> getMovimientos(String cuentaId) {\n    return movimientoReadRepo.findByCuentaId(cuentaId);\n}",
      "frase": "Con CQRS, cuando abres Yape la consulta vuela porque va a una base optimizada solo para leer."
    },
    {
      "id": 4,
      "categoria": "arquitectura",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es Event Sourcing y por qu√© es importante en banca?",
      "respuesta": "<p>Guardar TODO lo que pas√≥, no solo el estado actual:</p><ul><li><strong>Sin ES:</strong> Solo s√© que tienes S/1,500.</li><li><strong>Con ES:</strong> Guardo CADA movimiento y puedo reconstruir el saldo.</li></ul><p><strong>En banca:</strong> Auditor√≠a SBS, viaje en el tiempo, detecci√≥n de fraudes, replay de eventos.</p>",
      "analogia": "No solo s√© que tienes S/1,500, s√© EXACTAMENTE c√≥mo llegaste ah√≠ con cada movimiento.",
      "codigo": "public record TransferenciaRealizada(\n    String id, String origen, String destino,\n    BigDecimal monto, Instant timestamp\n) {}\n\npublic Cuenta reconstruir(String cuentaId) {\n    return eventStore.getEvents(cuentaId)\n        .reduce(Cuenta.vacia(), Cuenta::aplicarEvento);\n}",
      "frase": "En banca, Event Sourcing no es opcional. Los reguladores te piden trazabilidad completa."
    },
    {
      "id": 5,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo manejas transacciones distribuidas entre microservicios? Ejemplo: transferencia interbancaria.",
      "respuesta": "<p>En microservicios NO usas ACID tradicional. Usas <strong>SAGA</strong>:</p><ul><li>CTRL+Z para cada paso. Si falla paso 4, deshago 3, 2, 1.</li><li><strong>Orquestada:</strong> Un director controla todo.</li><li><strong>Coreografiada:</strong> Cada servicio reacciona a eventos.</li></ul>",
      "analogia": "SAGA es como comprar en cuotas: si falla el paso 4, te desbloquean el monto y eliminan las cuotas.",
      "codigo": "@Service\npublic class TransferenciaOrquestador {\n    public Mono<Void> ejecutar(TransferenciaCmd cmd) {\n        return validarSaldo(cmd)\n            .then(debitarOrigen(cmd))\n            .then(llamarBancoDestino(cmd))\n            .onErrorResume(e -> compensar(cmd, e));\n    }\n    \n    private Mono<Void> compensar(TransferenciaCmd cmd, Throwable e) {\n        return revertirDebito(cmd)\n            .then(notificarUsuario(cmd, \"Fallido\"));\n    }\n}",
      "frase": "En microservicios no hay transacciones m√°gicas. SAGA es tu CTRL+Z distribuido."
    },
    {
      "id": 6,
      "categoria": "reactivo",
      "dificultad": "senior",
      "pregunta": "¬øPor qu√© usar√≠as programaci√≥n reactiva en Yape? Expl√≠calo para el Gerente de Producto.",
      "respuesta": "<p><strong>TRADICIONAL:</strong> Pollo a la brasa - te quedas PARADO esperando 20 min. 1000 clientes = 1000 cajas.</p><p><strong>REACTIVO:</strong> Food court con BEEPER - pides, te dan beeper, te sientas. Te avisan cuando est√° listo.</p><p><strong>Beneficio:</strong> 100,000 usuarios con 10 servidores (reactivo) vs 100 servidores (tradicional). <strong>90% ahorro.</strong></p>",
      "analogia": "Reactivo es el food court con beeper: no te quedas parado esperando, te avisan cuando est√° listo.",
      "codigo": "// Tradicional - BLOQUEANTE\npublic Saldo getSaldo(String id) {\n    return repository.findById(id); // Hilo BLOQUEADO\n}\n\n// Reactivo - NO BLOQUEANTE\npublic Mono<Saldo> getSaldo(String id) {\n    return repository.findById(id); // Hilo LIBRE\n}",
      "frase": "Reactivo = menos plata en servidores, m√°s clientes atendidos. En hora punta, es caerse o seguir funcionando."
    },
    {
      "id": 7,
      "categoria": "reactivo",
      "dificultad": "senior",
      "pregunta": "¬øCu√°l es la diferencia entre Mono y Flux? Dame ejemplos en Yape.",
      "respuesta": "<p><strong>MONO = Un paquete.</strong> Yapear S/50 = UNA respuesta (√©xito o fall√≥).</p><p><strong>FLUX = Muchos paquetes (streaming).</strong> Ver movimientos = MUCHOS llegan, como suscripci√≥n mensual.</p><p><strong>Ejemplos:</strong> Mono<TransferenciaResponse>, Mono<Saldo>, Flux<Movimiento>, Flux<Notificacion>.</p>",
      "analogia": "Mono es un delivery √∫nico. Flux es una suscripci√≥n donde siguen llegando paquetes.",
      "codigo": "// MONO - Una respuesta\npublic Mono<TransferenciaResponse> yapear(YapeRequest req) {\n    return validar(req)\n        .flatMap(this::ejecutar)\n        .map(this::construirResponse);\n}\n\n// FLUX - Stream\npublic Flux<Movimiento> getMovimientos(String cuentaId) {\n    return movimientoRepo.findByCuentaId(cuentaId).take(50);\n}",
      "frase": "Mono para yapear (una respuesta). Flux para movimientos (stream de datos)."
    },
    {
      "id": 8,
      "categoria": "reactivo",
      "dificultad": "lead",
      "pregunta": "¬øCu√°l es la diferencia entre map y flatMap en programaci√≥n reactiva?",
      "respuesta": "<p><strong>MAP:</strong> Transformas el valor directamente. Naranja ‚Üí jugo. S√≠ncrono.</p><p><strong>FLATMAP:</strong> Tu transformaci√≥n retorna otro Mono/Flux. Aplanas para evitar Mono<Mono<T>>.</p><p><strong>Regla:</strong> ¬øRetorna valor normal? ‚Üí MAP. ¬øRetorna Mono/Flux? ‚Üí FLATMAP.</p>",
      "analogia": "Map es agregarle queso a la pizza. FlatMap es cuando tu pizza trae otra pizza y abres ambas cajas.",
      "codigo": "// MAP - valor directo\nMono<String> nombre = usuarioMono\n    .map(u -> u.getNombre());\n\n// FLATMAP - retorna Mono\nMono<Cuenta> cuenta = usuarioMono\n    .flatMap(u -> cuentaRepo.findByUsuarioId(u.getId()));",
      "frase": "Map para transformar datos, flatMap para llamar otros servicios reactivos."
    },
    {
      "id": 9,
      "categoria": "reactivo",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es backpressure y c√≥mo lo manejas cuando Kafka produce m√°s eventos de los que puedes procesar?",
      "respuesta": "<p>Backpressure = el MOZO le dice a la COCINA: ¬°PARA! No me doy abasto.</p><p><strong>Sin backpressure:</strong> Memoria llena ‚Üí OutOfMemory ‚Üí üíÄ</p><p><strong>Estrategias:</strong> Buffer (cola limitada), Drop (descartar), Latest (solo el reciente), Error (fallar si saturan).</p>",
      "analogia": "El mozo dici√©ndole a la cocina: 'Para, no me doy abasto con tantos platos'.",
      "codigo": "Flux.fromIterable(eventos)\n    .onBackpressureBuffer(1000)\n    .onBackpressureDrop(e -> log.warn(\"Descartado: {}\", e))\n    .flatMap(this::procesar, 10) // Max 10 paralelo\n    .subscribe();",
      "frase": "Sin backpressure, Kafka te ahoga. Con backpressure, t√∫ controlas cu√°ntos puedes masticar."
    },
    {
      "id": 10,
      "categoria": "reactivo",
      "dificultad": "senior",
      "pregunta": "¬øDiferencia entre RxJava y Project Reactor? ¬øCu√°ndo usar cada uno?",
      "respuesta": "<p><strong>RxJava:</strong> Single, Maybe, Observable, Flowable, Completable. Naci√≥ para Android.</p><p><strong>Reactor:</strong> Mono, Flux. Naci√≥ para Spring. Integraci√≥n nativa con WebFlux.</p><p><strong>Usar:</strong> RxJava para Android/legacy. Reactor para Spring/proyectos nuevos.</p>",
      "analogia": "RxJava tiene muchos tipos de vasos. Reactor es m√°s simple: vaso chico (Mono) y vaso grande (Flux).",
      "codigo": "// RxJava\nSingle<Usuario> usuario = Single.just(new Usuario());\nMaybe<Cuenta> cuenta = Maybe.empty();\nFlowable<Evento> eventos = Flowable.fromIterable(lista);\n\n// Reactor\nMono<Usuario> usuario = Mono.just(new Usuario());\nFlux<Evento> eventos = Flux.fromIterable(lista);",
      "frase": "Si tu stack es Spring, usa Reactor. No mezcles ambos en el mismo proyecto."
    },
    {
      "id": 11,
      "categoria": "resiliencia",
      "dificultad": "senior",
      "pregunta": "El servicio de pago de luz en Yape est√° lento o ca√≠do. ¬øC√≥mo evitas que se caiga toda la app?",
      "respuesta": "<p>Patrones de resiliencia con Resilience4j:</p><ul><li><strong>Circuit Breaker:</strong> Fusible - 5 fallas seguidas, abro circuito.</li><li><strong>Timeout:</strong> 5 segundos m√°ximo, corto.</li><li><strong>Retry:</strong> 3 intentos con backoff (1s, 2s, 4s).</li><li><strong>Fallback:</strong> Cache o mensaje 'No disponible'.</li><li><strong>Bulkhead:</strong> Pool separado, no afecta otros servicios.</li></ul>",
      "analogia": "Circuit Breaker es el fusible de tu casa: si hay cortocircuito, corta para que no se queme todo.",
      "codigo": "@CircuitBreaker(name = \"servicioLuz\", fallbackMethod = \"fallback\")\n@Retry(name = \"servicioLuz\")\n@TimeLimiter(name = \"servicioLuz\")\npublic Mono<DeudaDTO> consultarDeuda(String suministro) {\n    return webClient.get()\n        .uri(\"/deudas/{s}\", suministro)\n        .retrieve()\n        .bodyToMono(DeudaDTO.class);\n}\n\npublic Mono<DeudaDTO> fallback(String s, Throwable t) {\n    return cacheService.getUltimaDeuda(s);\n}",
      "frase": "Dise√±a para el FALLO, no para el √©xito. Tu app no debe caerse con el servicio externo."
    },
    {
      "id": 12,
      "categoria": "resiliencia",
      "dificultad": "lead",
      "pregunta": "Expl√≠came los estados del Circuit Breaker y c√≥mo configurar√≠as umbrales para pagos.",
      "respuesta": "<p><strong>3 estados:</strong></p><ul><li><strong>CLOSED:</strong> Normal, requests pasan, cuento fallas.</li><li><strong>OPEN:</strong> Muchas fallas, cort√©. Requests fallan inmediato.</li><li><strong>HALF-OPEN:</strong> Probando si se recuper√≥.</li></ul><p><strong>Config pagos:</strong> 50% fallas abre, 30s espera, 3 requests de prueba, ventana de 10.</p>",
      "analogia": "Fusible: CERRADO = corriente pasa. ABIERTO = cort√≥. SEMI-ABIERTO = probando si ya se arregl√≥.",
      "codigo": "resilience4j:\n  circuitbreaker:\n    instances:\n      servicioPagos:\n        failureRateThreshold: 50\n        waitDurationInOpenState: 30s\n        permittedNumberOfCallsInHalfOpenState: 3\n        slidingWindowSize: 10\n        slowCallRateThreshold: 80\n        slowCallDurationThreshold: 3s",
      "frase": "Circuit Breaker mal configurado es peor que no tener. Muy sensible = se abre por nada. Muy tolerante = no protege."
    },
    {
      "id": 13,
      "categoria": "resiliencia",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es el patr√≥n Bulkhead y c√≥mo lo aplicar√≠as en banca?",
      "respuesta": "<p>Bulkhead = compartimentos de un BARCO. Si uno se inunda, los dem√°s no se hunden.</p><p><strong>En Yape:</strong> Pool saldos: 20 hilos. Pool transferencias: 30 hilos. Pool pagos: 15 hilos. Si pagos se satura, saldos sigue funcionando.</p>",
      "analogia": "Compartimentos del barco: si uno se inunda, los dem√°s siguen a flote.",
      "codigo": "@Bulkhead(name = \"pagoServicios\", type = Bulkhead.Type.THREADPOOL)\npublic Mono<PagoResponse> pagarServicio(PagoRequest req) {\n    return servicioExternoClient.pagar(req);\n}\n\n# Config\nresilience4j.bulkhead.instances.pagoServicios:\n  maxConcurrentCalls: 15\n  maxWaitDuration: 500ms",
      "frase": "Sin Bulkhead, un servicio lento consume todos los hilos y tumba toda la app."
    },
    {
      "id": 14,
      "categoria": "cloud",
      "dificultad": "senior",
      "pregunta": "¬øC√≥mo dise√±ar√≠as un pipeline CI/CD para microservicios bancarios?",
      "respuesta": "<p>Pipeline seguro y auditable:</p><ul><li><strong>Build & Test:</strong> Compilar, unit tests, cobertura 80%.</li><li><strong>Security:</strong> SonarQube (SAST), Snyk (deps), Trivy (container).</li><li><strong>Build Image:</strong> Docker, tag sem√°ntico.</li><li><strong>Deploy DEV:</strong> Autom√°tico.</li><li><strong>Deploy QA:</strong> Aprobaci√≥n manual.</li><li><strong>Deploy PROD:</strong> Doble aprobaci√≥n + Blue-Green.</li></ul>",
      "analogia": "L√≠nea de producci√≥n de autos: cada estaci√≥n verifica algo, si falla una inspecci√≥n, el auto no sale.",
      "codigo": "name: CI/CD Pipeline\non: [push]\njobs:\n  build-test:\n    steps:\n      - run: ./gradlew build test\n      - run: ./gradlew sonarqube\n      - uses: snyk/actions/gradle@master\n  \n  deploy-prod:\n    needs: build-test\n    environment: production\n    steps:\n      - run: ./scripts/blue-green-deploy.sh",
      "frase": "En banca, el pipeline es tu primera l√≠nea de defensa. Si pasa, deber√≠a ser seguro para producci√≥n."
    },
    {
      "id": 15,
      "categoria": "cloud",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo gestionas secretos en microservicios desplegados en Kubernetes?",
      "respuesta": "<p>NUNCA secretos en c√≥digo. Usar:</p><ul><li><strong>Azure Key Vault / AWS Secrets Manager / Vault:</strong> Almac√©n centralizado con rotaci√≥n.</li><li><strong>External Secrets Operator:</strong> Sincroniza del Vault a K8s.</li><li><strong>Workload Identity:</strong> Pod se autentica sin credenciales hardcodeadas.</li></ul>",
      "analogia": "Secretos son llaves de la b√≥veda: no las dejas pegadas en la puerta. Las guardas en caja fuerte.",
      "codigo": "apiVersion: external-secrets.io/v1beta1\nkind: ExternalSecret\nmetadata:\n  name: db-credentials\nspec:\n  refreshInterval: 1h\n  secretStoreRef:\n    name: azure-keyvault\n  data:\n    - secretKey: password\n      remoteRef:\n        key: db-password",
      "frase": "Secreto hardcodeado en c√≥digo = red flag. En banca, puede costarte la certificaci√≥n PCI-DSS."
    },
    {
      "id": 16,
      "categoria": "cloud",
      "dificultad": "senior",
      "pregunta": "¬øDiferencia entre HPA y VPA en Kubernetes? ¬øCu√°ndo usar cada uno?",
      "respuesta": "<p><strong>HPA (Horizontal):</strong> Agrega M√ÅS pods. Abrir m√°s cajas en el banco.</p><p><strong>VPA (Vertical):</strong> Hace cada pod M√ÅS POTENTE. Poner cajero m√°s r√°pido.</p><p><strong>Usar:</strong> HPA para microservicios stateless (mayor√≠a). VPA para apps que no escalan horizontal (BD).</p>",
      "analogia": "HPA = abrir m√°s cajas. VPA = poner cajero m√°s r√°pido. En banca digital, casi siempre queremos m√°s cajas.",
      "codigo": "apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: ms-transferencias\nspec:\n  scaleTargetRef:\n    kind: Deployment\n    name: ms-transferencias\n  minReplicas: 3\n  maxReplicas: 20\n  metrics:\n    - type: Resource\n      resource:\n        name: cpu\n        target:\n          averageUtilization: 70",
      "frase": "En hora punta, HPA escala de 3 a 15 pods autom√°ticamente. Pagas solo lo que usas."
    },
    {
      "id": 17,
      "categoria": "data",
      "dificultad": "senior",
      "pregunta": "¬øCu√°ndo usar√≠as Redis en arquitectura bancaria y qu√© patrones implementar√≠as?",
      "respuesta": "<p>Redis = memoria de corto plazo s√∫per r√°pida:</p><ul><li><strong>Cache saldos:</strong> Consulta instant√°nea, TTL 30s.</li><li><strong>Rate Limiting:</strong> M√°x 100 consultas/usuario/minuto.</li><li><strong>Sesiones:</strong> Tokens distribuidos entre pods.</li><li><strong>Locks distribuidos:</strong> Evitar doble procesamiento.</li></ul><p><strong>Patrones:</strong> Cache-Aside (busco cache, si no BD), Write-Through.</p>",
      "analogia": "Redis es memoria de trabajo: guardas lo que necesitas r√°pido, lo importante est√° en el disco (BD).",
      "codigo": "@Cacheable(value = \"saldos\", key = \"#cuentaId\")\npublic Mono<Saldo> getSaldo(String cuentaId) {\n    return saldoRepository.findByCuentaId(cuentaId);\n}\n\n@CacheEvict(value = \"saldos\", key = \"#cuentaId\")\npublic Mono<Void> actualizarSaldo(String cuentaId, BigDecimal nuevo) {\n    return saldoRepository.actualizar(cuentaId, nuevo);\n}",
      "frase": "Sin Redis, cada consulta va a BD. Con Redis, 90% se responden en milisegundos desde memoria."
    },
    {
      "id": 18,
      "categoria": "data",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo garantizas el orden de mensajes en Kafka para transacciones bancarias?",
      "respuesta": "<p>Orden garantizado SOLO dentro de una partici√≥n:</p><ul><li><strong>Partition Key = ID cuenta:</strong> Todas las tx de misma cuenta ‚Üí misma partici√≥n ‚Üí orden.</li><li><strong>Un consumer por partici√≥n:</strong> 10 particiones = m√°x 10 consumers.</li><li><strong>Idempotencia:</strong> Si reprocesa, no duplica.</li></ul><p><strong>Config:</strong> acks=all, enable.idempotence=true.</p>",
      "analogia": "Kafka es filas del banco: cada fila (partici√≥n) mantiene su orden. Tu DNI (cuenta) define tu fila.",
      "codigo": "// Productor con partition key\npublic Mono<Void> publicarTransaccion(Transaccion tx) {\n    return Mono.fromFuture(\n        kafkaTemplate.send(\"transacciones\",\n            tx.getCuentaId(),  // Partition key\n            tx)\n        .toCompletableFuture()\n    ).then();\n}",
      "frase": "En Kafka, orden es por partici√≥n. Usa ID de cuenta como partition key para orden garantizado."
    },
    {
      "id": 19,
      "categoria": "seguridad",
      "dificultad": "senior",
      "pregunta": "¬øCu√°les son las vulnerabilidades OWASP Top 10 m√°s comunes en APIs bancarias?",
      "respuesta": "<p>Las m√°s comunes:</p><ul><li><strong>A01 Broken Access Control:</strong> Usuario accede a datos de otro. Validar ownership.</li><li><strong>A02 Cryptographic Failures:</strong> Datos sin encriptar. TLS 1.3, no loggear PII.</li><li><strong>A03 Injection:</strong> SQL injection. Queries parametrizados.</li><li><strong>A07 Security Misconfiguration:</strong> Headers faltantes, errores verbosos.</li></ul><p><strong>Herramientas:</strong> SonarQube (SAST), OWASP ZAP (DAST), Snyk.</p>",
      "analogia": "OWASP es checklist de seguridad del banco: cerraduras (auth), c√°maras (logging), b√≥veda (cifrado).",
      "codigo": "// MAL - Broken Access Control\n@GetMapping(\"/cuentas/{id}\")\npublic Mono<Cuenta> getCuenta(@PathVariable String id) {\n    return cuentaRepo.findById(id); // Cualquiera accede!\n}\n\n// BIEN\n@GetMapping(\"/cuentas/{id}\")\npublic Mono<Cuenta> getCuenta(@PathVariable String id, Principal p) {\n    return cuentaRepo.findById(id)\n        .filter(c -> c.getUsuarioId().equals(p.getName()))\n        .switchIfEmpty(Mono.error(new AccessDeniedException(\"No\")));\n}",
      "frase": "Vulnerabilidad OWASP en banca no es solo bug, es riesgo regulatorio. La SBS puede multarte."
    },
    {
      "id": 20,
      "categoria": "seguridad",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementas estrategia de testing completa para microservicios bancarios?",
      "respuesta": "<p>Pir√°mide de testing:</p><ul><li><strong>Unit (70%):</strong> L√≥gica aislada, mocks, cobertura 80%.</li><li><strong>Integration (20%):</strong> BD real (Testcontainers), APIs mockeadas (WireMock).</li><li><strong>E2E (10%):</strong> Flujos cr√≠ticos completos.</li></ul><p><strong>Adicional:</strong> Contract (Pact), Performance (Gatling), Chaos, Security (SAST/DAST).</p>",
      "analogia": "Control de calidad en f√°brica: unit revisa piezas, integration el ensamblaje, E2E el producto final.",
      "codigo": "// Unit Test\n@Test\nvoid debeRechazarSinSaldo() {\n    when(cuentaRepo.findById(\"123\")).thenReturn(Mono.just(cuentaSaldo0));\n    StepVerifier.create(service.transferir(cmd))\n        .expectError(SaldoInsuficienteException.class)\n        .verify();\n}\n\n// Integration con Testcontainers\n@Testcontainers\nclass TransferenciaIT {\n    @Container\n    static PostgreSQLContainer<?> pg = new PostgreSQLContainer<>(\"postgres:15\");\n}",
      "frase": "Bug en producci√≥n puede costar millones. Invertir en testing es m√°s barato que transferencia duplicada."
    },
    {
      "id": 21,
      "categoria": "observabilidad",
      "dificultad": "senior",
      "pregunta": "¬øC√≥mo implementas los 3 pilares de observabilidad (logs, m√©tricas, traces)?",
      "respuesta": "<p><strong>LOGS:</strong> Qu√© pas√≥. JSON estructurado, correlation ID. ELK/CloudWatch.</p><p><strong>M√âTRICAS:</strong> Cu√°nto pas√≥. Latencia, throughput, errores. Prometheus + Grafana.</p><p><strong>TRACES:</strong> C√≥mo pas√≥. Flujo del request. Jaeger/Zipkin + OpenTelemetry.</p><p><strong>Correlation ID:</strong> Un ID √∫nico que se propaga a TODOS los servicios.</p>",
      "analogia": "Investigar crimen: logs son testimonios, m√©tricas son estad√≠sticas del barrio, traces son c√°maras de seguridad.",
      "codigo": "@Component\npublic class CorrelationIdFilter implements WebFilter {\n    public Mono<Void> filter(ServerWebExchange ex, WebFilterChain chain) {\n        String corrId = ex.getRequest().getHeaders()\n            .getFirst(\"X-Correlation-ID\");\n        if (corrId == null) corrId = UUID.randomUUID().toString();\n        return chain.filter(ex)\n            .contextWrite(ctx -> ctx.put(\"correlationId\", corrId));\n    }\n}",
      "frase": "Sin observabilidad, debuggear microservicios es buscar aguja en pajar. Con correlation ID, sigues un hilo rojo."
    },
    {
      "id": 22,
      "categoria": "observabilidad",
      "dificultad": "lead",
      "pregunta": "¬øQu√© m√©tricas RED y USE monitorear√≠as para servicio de transferencias?",
      "respuesta": "<p><strong>RED (servicios):</strong></p><ul><li><strong>Rate:</strong> Requests/seg. Alerta: >2000 o <100.</li><li><strong>Errors:</strong> % errores. Normal <1%, alerta >5%.</li><li><strong>Duration:</strong> Latencia p95. Normal <200ms, alerta >500ms.</li></ul><p><strong>USE (recursos):</strong> Utilization >80%, Saturation (queue >100), Errors.</p>",
      "analogia": "RED es tablero del auto: velocidad, warnings, temperatura. USE es revisar el motor.",
      "codigo": "groups:\n  - name: transferencias\n    rules:\n      - alert: AltaLatencia\n        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket{service=\"ms-transferencias\"}[5m])) > 0.5\n        for: 2m\n        labels:\n          severity: warning\n      \n      - alert: AltaTasaErrores\n        expr: rate(http_requests_total{status=~\"5..\"}[5m]) / rate(http_requests_total[5m]) > 0.05\n        for: 1m\n        labels:\n          severity: critical",
      "frase": "RED dice si usuarios est√°n felices. USE dice si infraestructura est√° sufriendo. Necesitas ambas."
    },
    {
      "id": 23,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Un developer senior no sigue est√°ndares y hace todo a su manera. ¬øC√≥mo manejas la situaci√≥n?",
      "respuesta": "<p>NO confrontar p√∫blicamente:</p><ul><li><strong>1. Conversaci√≥n 1 a 1:</strong> 'Axel, veo oportunidad de alto impacto.'</li><li><strong>2. Involucrarlo:</strong> '¬øCreamos p√≠ldoras de conocimiento juntos?'</li><li><strong>3. Darle ownership:</strong> Responsable de est√°ndares de su √°rea.</li><li><strong>4. Reconocimiento p√∫blico:</strong> 'Gracias a Axel tenemos gu√≠as que todos usan.'</li></ul><p><strong>Clave:</strong> Canalizar experiencia hacia el bien del equipo.</p>",
      "analogia": "Senior rebelde es l√≠der sin direcci√≥n. Mi trabajo es darle direcci√≥n. No cambio personas, canalizo talentos.",
      "codigo": null,
      "frase": "Ya no quiero ser el mejor developer. Quiero ser el l√≠der del mejor equipo de developers."
    },
    {
      "id": 24,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Est√°s en medio del sprint y llega un pedido urgente no planificado. ¬øQu√© haces?",
      "respuesta": "<p>Proceso para urgencias:</p><ul><li><strong>1. Evaluar:</strong> ¬øEs urgente o solo importante? ¬øQui√©n pide y por qu√©?</li><li><strong>2. Negociar scope:</strong> 'Podemos hacerlo, pero sacamos X del sprint.'</li><li><strong>3. Transparencia:</strong> Explicar al equipo el cambio y el porqu√©.</li><li><strong>4. Proteger:</strong> Si es muy disruptivo, negociar para siguiente sprint.</li><li><strong>5. Documentar:</strong> Para la retro.</li></ul>",
      "analogia": "Sprint es un vuelo: ya despegaste con cierta carga. Si metes m√°s equipaje, algo tiene que salir.",
      "codigo": null,
      "frase": "Mi trabajo es ser el escudo del equipo. Filtro urgencias falsas y solo dejo pasar las que importan."
    },
    {
      "id": 25,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo haces code reviews efectivos sin desmotivar al equipo?",
      "respuesta": "<p>Principios:</p><ul><li><strong>1. Criticar c√≥digo, no persona:</strong> 'Este m√©todo podr√≠a...' vs 'Hiciste mal...'</li><li><strong>2. Preguntar, no afirmar:</strong> '¬øConsideraste usar X?'</li><li><strong>3. Explicar el porqu√©:</strong> 'Esto puede causar memory leak porque...'</li><li><strong>4. Reconocer lo bueno:</strong> Si algo est√° bien, decirlo.</li><li><strong>5. Ser oportuno:</strong> Review en 24h.</li></ul>",
      "analogia": "Code review es ser coach: se√±alas jugadas a mejorar pero celebras los goles. Solo criticar mata motivaci√≥n.",
      "codigo": "// MAL\n\"Esto est√° mal. Deber√≠as saber que no se hace as√≠.\"\n\n// BIEN\n\"¬øQu√© te parece extraer este bloque a un m√©todo privado?\nMejorar√≠a legibilidad y facilitar√≠a testearlo.\n\nprivate Mono<Saldo> validarSaldo(Cuenta cuenta) {\n    // l√≥gica\n}\n\n¬øQu√© opinas?\"",
      "frase": "Buen code review ense√±a. Mal code review humilla. La diferencia est√° en c√≥mo formulas el feedback."
    },
    {
      "id": 26,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "¬øPor qu√© quieres ser Technical Leader y no seguir como Developer Senior?",
      "respuesta": "<p>Motivaci√≥n:</p><ul><li><strong>Multiplicar impacto:</strong> Un developer escribe X l√≠neas. Un l√≠der que forma 5 developers multiplica por 5.</li><li><strong>Del singular al plural:</strong> No es 'lo que yo hice', es 'lo que CONSTRUIMOS'.</li><li><strong>Madurez:</strong> Ya recib√≠ premios. Ahora quiero que mi equipo los reciba.</li><li><strong>Visi√≥n:</strong> El c√≥digo es legacy ma√±ana. La cultura t√©cnica perdura.</li></ul>",
      "analogia": "Pasar de jugador estrella a entrenador: ya no metes los goles, pero entrenas al equipo que mete m√°s que nunca.",
      "codigo": null,
      "frase": "Ya recib√≠ palmadas en la espalda. Lleg√≥ el momento de conducir a personas que crean cosas maravillosas."
    },
    {
      "id": 27,
      "categoria": "liderazgo",
      "dificultad": "senior",
      "pregunta": "Cu√©ntame el proyecto m√°s desafiante que hayas liderado. Usa el m√©todo STAR.",
      "respuesta": "<p><strong>SITUACI√ìN:</strong> 'En 2019, Ministerio de Trabajo necesitaba Certificado √önico Laboral, consolidando 4 entidades.'</p><p><strong>TAREA:</strong> 'Dise√±ar integraci√≥n con PIDE y garantizar demanda nacional.'</p><p><strong>ACCI√ìN:</strong> 'Implement√© colas, jerarqu√≠a de excepciones, firma digital, logs centralizados.'</p><p><strong>RESULTADO:</strong> 'Premio Innovaci√≥n 2018, millones de peruanos lo usan.'</p>",
      "analogia": "STAR es tu estructura para historias de impacto. Sin estructura divagamos, con STAR somos memorables.",
      "codigo": null,
      "frase": "Dise√±ar para el fallo, no para el √©xito. Integrar sistemas es armar rompecabezas donde cada pieza puede cambiar."
    },
    {
      "id": 28,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementar√≠as Contract-First con OpenAPI en microservicios bancarios?",
      "respuesta": "<p>Contract-First = definir el contrato ANTES de codear:</p><ul><li><strong>1. Definir OpenAPI YAML</strong> con endpoints, schemas, errores.</li><li><strong>2. Generar c√≥digo</strong> del contrato (interfaces, DTOs).</li><li><strong>3. Implementar</strong> las interfaces generadas.</li><li><strong>4. Validar</strong> que el c√≥digo cumple el contrato.</li></ul><p><strong>Beneficios:</strong> Frontend y backend trabajan en paralelo, documentaci√≥n siempre actualizada.</p>",
      "analogia": "Es como construir una casa: primero los planos (contrato), luego la construcci√≥n (c√≥digo). No al rev√©s.",
      "codigo": "# openapi.yaml\npaths:\n  /cuentas/{id}/saldo:\n    get:\n      operationId: getSaldo\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: string\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Saldo'\n\n# Genera interface que implementas\npublic interface CuentasApi {\n    Mono<Saldo> getSaldo(String id);\n}",
      "frase": "Con Contract-First, frontend y backend pueden trabajar en paralelo. El contrato es el acuerdo."
    },
    {
      "id": 29,
      "categoria": "seguridad",
      "dificultad": "senior",
      "pregunta": "¬øC√≥mo implementar√≠as autenticaci√≥n y autorizaci√≥n en microservicios con JWT?",
      "respuesta": "<p>Flujo JWT en microservicios:</p><ul><li><strong>1. Login:</strong> Usuario se autentica, recibe JWT firmado.</li><li><strong>2. API Gateway:</strong> Valida firma del JWT, extrae claims.</li><li><strong>3. Propagaci√≥n:</strong> Claims se propagan a microservicios downstream.</li><li><strong>4. Autorizaci√≥n:</strong> Cada servicio valida permisos seg√∫n roles/scopes.</li></ul><p><strong>Seguridad:</strong> Tokens cortos (15min), refresh tokens, blacklist para revocaci√≥n.</p>",
      "analogia": "JWT es como tu pase del concierto: en la entrada validan que sea real, adentro cada zona valida si tu pase tiene acceso VIP.",
      "codigo": "@Bean\nSecurityWebFilterChain security(ServerHttpSecurity http) {\n    return http\n        .oauth2ResourceServer(oauth -> oauth.jwt())\n        .authorizeExchange(ex -> ex\n            .pathMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n            .pathMatchers(\"/api/**\").authenticated()\n            .anyExchange().permitAll())\n        .build();\n}\n\n// Extraer usuario del JWT\n@GetMapping(\"/mi-saldo\")\npublic Mono<Saldo> miSaldo(@AuthenticationPrincipal Jwt jwt) {\n    String userId = jwt.getSubject();\n    return saldoService.getSaldo(userId);\n}",
      "frase": "JWT en microservicios: el gateway valida la firma, cada servicio valida los permisos. Defensa en profundidad."
    },
    {
      "id": 30,
      "categoria": "reactivo",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo manejas errores en programaci√≥n reactiva? Explica los operadores principales.",
      "respuesta": "<p>Operadores de error en Reactor:</p><ul><li><strong>onErrorReturn:</strong> Valor por defecto. 'Toma pastilla y sigue.'</li><li><strong>onErrorResume:</strong> Flujo alternativo. 'Ve a otro doctor (plan B).'</li><li><strong>onErrorMap:</strong> Transformar excepci√≥n. 'Te transfiero a especialista.'</li><li><strong>retry:</strong> Reintentar. 'Intenta de nuevo.'</li><li><strong>timeout:</strong> L√≠mite de tiempo. 'Si no te atienden en 5s, vete.'</li></ul>",
      "analogia": "Manejo de errores es como hospital: onErrorReturn=pastilla, onErrorResume=otro doctor, retry=vuelve a intentar, timeout=vete si no te atienden.",
      "codigo": "public Mono<Saldo> getSaldoSeguro(String id) {\n    return cuentaRepo.findById(id)\n        .map(Cuenta::getSaldo)\n        .timeout(Duration.ofSeconds(5))\n        .retry(3)\n        .onErrorResume(TimeoutException.class, e -> \n            cacheService.getSaldoCache(id))\n        .onErrorReturn(Saldo.NO_DISPONIBLE)\n        .doOnError(e -> log.error(\"Error: {}\", e.getMessage()));\n}",
      "frase": "En reactivo, el manejo de errores es first-class citizen. Cada operador tiene su prop√≥sito."
    },
    {
      "id": 31,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo aplicar√≠as Domain-Driven Design (DDD) en un sistema bancario? Explica Bounded Contexts, Aggregates y Domain Events.",
      "respuesta": "<p><strong>DDD organiza c√≥digo por DOMINIOS de negocio:</strong></p><ul><li><strong>Bounded Context:</strong> Fronteras claras. 'Cuentas' es un contexto, 'Pr√©stamos' es otro. Cada uno tiene su lenguaje.</li><li><strong>Aggregate:</strong> Grupo de entidades que se modifican juntas. Cuenta + Movimientos = un aggregate.</li><li><strong>Domain Events:</strong> 'TransferenciaRealizada' notifica a otros contextos sin acoplamiento.</li><li><strong>Anti-Corruption Layer:</strong> Traductor entre tu dominio y sistemas legacy.</li></ul>",
      "analogia": "DDD es organizar el banco: Cuentas, Pr√©stamos, Tarjetas son departamentos separados. Se comunican por memos (eventos), no entrando a la oficina del otro.",
      "codigo": "// Aggregate Root\n@AggregateRoot\npublic class Cuenta {\n    private String id;\n    private List<Movimiento> movimientos;\n    private Saldo saldo;\n    \n    public DomainEvent debitar(BigDecimal monto) {\n        if (saldo.menor(monto)) throw new SaldoInsuficiente();\n        saldo = saldo.restar(monto);\n        return new CuentaDebitada(id, monto, Instant.now());\n    }\n}\n\n// Domain Event\npublic record CuentaDebitada(String cuentaId, BigDecimal monto, Instant when) {}",
      "frase": "DDD no es sobre c√≥digo, es sobre ENTENDER el negocio. Si no hablas el idioma del banco, tu c√≥digo ser√° confuso."
    },
    {
      "id": 32,
      "categoria": "cloud",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es un Service Mesh (Istio/Linkerd) y cu√°ndo lo necesitas en microservicios bancarios?",
      "respuesta": "<p><strong>Service Mesh = infraestructura dedicada para comunicaci√≥n entre servicios:</strong></p><ul><li><strong>Sidecar proxy:</strong> Cada pod tiene un Envoy que intercepta tr√°fico.</li><li><strong>mTLS autom√°tico:</strong> Todo cifrado sin cambiar c√≥digo.</li><li><strong>Traffic Management:</strong> Canary, blue-green, circuit breaker a nivel infra.</li><li><strong>Observabilidad:</strong> Traces distribuidos autom√°ticos.</li></ul><p><strong>¬øCu√°ndo?</strong> +30 microservicios, necesitas zero-trust networking, equipos separados manejan servicios.</p>",
      "analogia": "Service Mesh es como tener guardaespaldas para cada servicio: interceptan todo, verifican identidad, registran movimientos. T√∫ te enfocas en tu trabajo.",
      "codigo": "# VirtualService para Canary release\napiVersion: networking.istio.io/v1beta1\nkind: VirtualService\nmetadata:\n  name: ms-transferencias\nspec:\n  hosts:\n    - ms-transferencias\n  http:\n    - match:\n        - headers:\n            x-canary:\n              exact: \"true\"\n      route:\n        - destination:\n            host: ms-transferencias\n            subset: v2\n    - route:\n        - destination:\n            host: ms-transferencias\n            subset: v1\n          weight: 90\n        - destination:\n            subset: v2\n          weight: 10",
      "frase": "Service Mesh mueve complejidad del c√≥digo a la infraestructura. Menos c√≥digo = menos bugs en tu app."
    },
    {
      "id": 33,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "System Design: Dise√±a el sistema de notificaciones push para Yape que env√≠a millones de notificaciones diarias.",
      "respuesta": "<p><strong>Componentes:</strong></p><ul><li><strong>API Gateway:</strong> Recibe eventos (transferencia, pago).</li><li><strong>Kafka:</strong> Cola de eventos, particiona por usuario para orden.</li><li><strong>Notification Workers:</strong> Consumers que procesan y formatean mensajes.</li><li><strong>Provider Abstraction:</strong> Firebase (Android), APNS (iOS), Email, SMS.</li><li><strong>Redis:</strong> Preferencias de usuario, device tokens, rate limiting.</li><li><strong>Dead Letter Queue:</strong> Reintentos para fallos.</li></ul><p><strong>Escala:</strong> 10 particiones, 10 consumers, batch processing de 100 mensajes.</p>",
      "analogia": "Sistema de correos del banco: eventos llegan a central (Kafka), carteros (workers) los distribuyen seg√∫n preferencia (push, email, SMS).",
      "codigo": "@Service\npublic class NotificationWorker {\n    @KafkaListener(topics = \"eventos-notificacion\")\n    public Mono<Void> procesar(List<EventoNotificacion> batch) {\n        return Flux.fromIterable(batch)\n            .flatMap(this::obtenerPreferencias)\n            .flatMap(this::enviarPorCanal)\n            .onErrorContinue((e, o) -> dlq.enviar(o))\n            .then();\n    }\n    \n    private Mono<Void> enviarPorCanal(NotificacionEnriquecida n) {\n        return switch(n.canal()) {\n            case PUSH -> firebaseClient.send(n);\n            case EMAIL -> emailClient.send(n);\n            case SMS -> smsClient.send(n);\n        };\n    }\n}",
      "frase": "Millones de notificaciones = Kafka + Workers escalables + Proveedores abstractos. Nunca llames a Firebase directamente."
    },
    {
      "id": 34,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Es viernes 5pm y hay un incidente P1 en producci√≥n. ¬øC√≥mo lo manejas como Tech Lead?",
      "respuesta": "<p><strong>Protocolo de Incidentes:</strong></p><ul><li><strong>1. Comunicar:</strong> Abrir canal de War Room (Slack/Teams), notificar stakeholders.</li><li><strong>2. Triaje:</strong> ¬øQu√© est√° fallando? ¬øImpacto? ¬øDesde cu√°ndo?</li><li><strong>3. Mitigar:</strong> Rollback, feature flag off, escalar recursos. PARAR LA HEMORRAGIA.</li><li><strong>4. Diagnosticar:</strong> Logs, m√©tricas, traces. ¬øQu√© cambi√≥?</li><li><strong>5. Resolver:</strong> Fix + deploy o mantener mitigaci√≥n hasta lunes.</li><li><strong>6. Post-mortem:</strong> Sin culpar. ¬øQu√© aprendimos? ¬øC√≥mo prevenimos?</li></ul>",
      "analogia": "Incidente es como incendio: primero evacuar (mitigar), luego apagar (fix), despu√©s investigar causa. No investigas mientras se quema.",
      "codigo": "// Feature Flag para mitigar r√°pido\n@PostMapping(\"/transferencias\")\npublic Mono<Response> transferir(@RequestBody TransferenciaCmd cmd) {\n    if (!featureFlags.isEnabled(\"transferencias-interbancarias\")) {\n        return Mono.just(Response.servicioTemporalmenteNoDisponible());\n    }\n    return transferenciaService.ejecutar(cmd);\n}\n\n// Rollback inmediato\n$ kubectl rollout undo deployment/ms-transferencias",
      "frase": "En un P1, primero MITIGA, despu√©s INVESTIGA. Usuarios no les importa el root cause, quieren que funcione."
    },
    {
      "id": 35,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo gestionas la deuda t√©cnica en tu equipo? ¬øCu√°ndo pagas y cu√°ndo la aceptas?",
      "respuesta": "<p><strong>Estrategia de Deuda T√©cnica:</strong></p><ul><li><strong>Inventariar:</strong> Documentar toda deuda en backlog t√©cnico con impacto.</li><li><strong>Clasificar:</strong> Cr√≠tica (seguridad, estabilidad), Alta (velocidad dev), Media (mantenibilidad), Baja (nice-to-have).</li><li><strong>Regla 20%:</strong> 20% del sprint para pagar deuda t√©cnica.</li><li><strong>Boy Scout:</strong> Deja el c√≥digo mejor de lo que lo encontraste.</li></ul><p><strong>Pagar cuando:</strong> Afecta velocidad, causa incidentes, bloquea features. <strong>Aceptar cuando:</strong> Es temporal, no afecta usuarios, se pagar√° pronto.</p>",
      "analogia": "Deuda t√©cnica es como deuda de tarjeta: poquito est√° bien, acumular intereses te quiebra. El 20% del sprint es tu pago mensual.",
      "codigo": null,
      "frase": "Deuda t√©cnica SIEMPRE se paga: o la pagas t√∫ a tu ritmo, o la pagan tus usuarios con ca√≠das y lentitud."
    },
    {
      "id": 36,
      "categoria": "data",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo dise√±ar√≠as la estrategia de base de datos para microservicios? ¬øDatabase per service o shared?",
      "respuesta": "<p><strong>Database per Service (recomendado):</strong></p><ul><li><strong>Autonom√≠a:</strong> Cada servicio controla su esquema, puede escalar independiente.</li><li><strong>Aislamiento:</strong> Fallo en una BD no afecta otras.</li><li><strong>Pol√≠glotas:</strong> PostgreSQL para transacciones, MongoDB para flexibilidad, Redis para cache.</li></ul><p><strong>Desaf√≠os:</strong> Consistencia eventual, joins distribuidos, transacciones SAGA.</p><p><strong>Shared solo si:</strong> Equipo peque√±o, dominio simple, migraci√≥n gradual de monolito.</p>",
      "analogia": "Cada departamento del banco tiene su archivo propio. Se comparten informaci√≥n por memos (APIs/eventos), no entrando al archivo del otro.",
      "codigo": "// Servicio Cuentas - PostgreSQL\n@Repository\npublic interface CuentaRepository extends ReactiveCrudRepository<Cuenta, String> {}\n\n// Servicio Movimientos - MongoDB (alto volumen)\n@Repository  \npublic interface MovimientoRepository extends ReactiveMongoRepository<Movimiento, String> {\n    Flux<Movimiento> findByCuentaIdOrderByFechaDesc(String cuentaId);\n}\n\n// Servicio Notificaciones - Redis (ef√≠mero)\n@Repository\npublic class NotificacionRedisRepository {\n    public Mono<Boolean> marcarLeida(String notifId) {\n        return redisTemplate.opsForValue().set(notifId, \"leida\", Duration.ofDays(7));\n    }\n}",
      "frase": "Database per service es el camino. S√≠, es m√°s complejo, pero la alternativa es un monolito distribuido."
    },
    {
      "id": 37,
      "categoria": "resiliencia",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es Chaos Engineering y c√≥mo lo aplicar√≠as en sistemas bancarios?",
      "respuesta": "<p><strong>Chaos Engineering = romper cosas a prop√≥sito para encontrar debilidades:</strong></p><ul><li><strong>1. Hip√≥tesis:</strong> 'Si cae el servicio de saldos, transferencias debe mostrar fallback.'</li><li><strong>2. Experimento:</strong> Matar pods de saldos en ambiente controlado.</li><li><strong>3. Medir:</strong> ¬øCircuit breaker se abri√≥? ¬øLatencia? ¬øErrores usuarios?</li><li><strong>4. Aprender:</strong> Documentar y mejorar.</li></ul><p><strong>Herramientas:</strong> Chaos Monkey, Litmus, Gremlin. <strong>En banca:</strong> Primero en staging, nunca en horario pico.</p>",
      "analogia": "Es simulacro de incendio: mejor descubrir que la puerta de emergencia est√° trabada en simulacro que en incendio real.",
      "codigo": "# Chaos experiment con Litmus\napiVersion: litmuschaos.io/v1alpha1\nkind: ChaosEngine\nmetadata:\n  name: saldos-chaos\nspec:\n  appinfo:\n    appns: banking\n    applabel: app=ms-saldos\n  chaosServiceAccount: litmus-admin\n  experiments:\n    - name: pod-delete\n      spec:\n        components:\n          env:\n            - name: TOTAL_CHAOS_DURATION\n              value: '60'\n            - name: CHAOS_INTERVAL\n              value: '10'",
      "frase": "Chaos Engineering en banca no es irresponsable, es profesional. Mejor que descubras t√∫ las debilidades a que las descubran tus usuarios."
    },
    {
      "id": 38,
      "categoria": "observabilidad",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementar√≠as distributed tracing con OpenTelemetry en microservicios?",
      "respuesta": "<p><strong>OpenTelemetry unifica traces, m√©tricas y logs:</strong></p><ul><li><strong>Instrumentaci√≥n:</strong> SDK autom√°tico intercepta HTTP, BD, Kafka.</li><li><strong>Propagaci√≥n:</strong> Trace ID se pasa en headers (W3C Trace Context).</li><li><strong>Exportaci√≥n:</strong> Env√≠a a Jaeger, Zipkin, Tempo, X-Ray.</li><li><strong>Sampling:</strong> 10% normal, 100% en errores.</li></ul><p><strong>Beneficio:</strong> Ver TODO el flujo de un request: API Gateway ‚Üí BFF ‚Üí Servicio ‚Üí BD ‚Üí Kafka.</p>",
      "analogia": "OpenTelemetry es GPS del request: sabes exactamente por d√≥nde pas√≥, cu√°nto demor√≥ en cada parada, y d√≥nde se atasc√≥.",
      "codigo": "// build.gradle\nimplementation 'io.opentelemetry:opentelemetry-api'\nimplementation 'io.opentelemetry.instrumentation:opentelemetry-spring-webflux'\n\n// application.yml\notel:\n  traces:\n    exporter: jaeger\n  exporter:\n    jaeger:\n      endpoint: http://jaeger:14250\n  resource:\n    attributes:\n      service.name: ms-transferencias\n      deployment.environment: production\n\n// Span personalizado\n@WithSpan(\"validar-saldo-suficiente\")\npublic Mono<Boolean> validarSaldo(String cuentaId, BigDecimal monto) {\n    return saldoService.getSaldo(cuentaId)\n        .map(s -> s.compareTo(monto) >= 0);\n}",
      "frase": "Sin distributed tracing, debuggear microservicios es imposible. OpenTelemetry es el est√°ndar, no inventes."
    },
    {
      "id": 39,
      "categoria": "seguridad",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementar√≠as Rate Limiting y protecci√≥n contra DDoS en APIs bancarias?",
      "respuesta": "<p><strong>Capas de protecci√≥n:</strong></p><ul><li><strong>1. CDN/WAF:</strong> Cloudflare, AWS Shield. Primera l√≠nea contra DDoS.</li><li><strong>2. API Gateway:</strong> Rate limit por IP, usuario, API key.</li><li><strong>3. Aplicaci√≥n:</strong> Resilience4j RateLimiter por operaci√≥n cr√≠tica.</li></ul><p><strong>Estrategia:</strong></p><ul><li>Consulta saldo: 100/min por usuario.</li><li>Transferencias: 10/min por usuario.</li><li>Login: 5 intentos, luego bloqueo 15 min.</li></ul>",
      "analogia": "Rate limiting es el guardia del banco: si alguien entra y sale 100 veces en un minuto, algo raro pasa. Lo paras.",
      "codigo": "// Redis-based Rate Limiter\n@RateLimiter(name = \"transferencias\")\npublic Mono<TransferenciaResponse> transferir(TransferenciaCmd cmd) {\n    return transferenciaService.ejecutar(cmd);\n}\n\n# application.yml\nresilience4j:\n  ratelimiter:\n    instances:\n      transferencias:\n        limitForPeriod: 10\n        limitRefreshPeriod: 1m\n        timeoutDuration: 0\n\n// Custom con Redis para distribuido\npublic Mono<Boolean> permitir(String userId, String operacion) {\n    String key = \"rate:\" + operacion + \":\" + userId;\n    return redisTemplate.opsForValue()\n        .increment(key)\n        .flatMap(count -> {\n            if (count == 1) redisTemplate.expire(key, Duration.ofMinutes(1));\n            return Mono.just(count <= 10);\n        });\n}",
      "frase": "Sin rate limiting, un bot puede vaciar cuentas. En banca, es obligatorio, no opcional."
    },
    {
      "id": 40,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Tu equipo tiene 2 seniors que no se llevan bien y afectan la din√°mica. ¬øC√≥mo lo resuelves?",
      "respuesta": "<p><strong>Proceso de mediaci√≥n:</strong></p><ul><li><strong>1. Observar:</strong> ¬øEs personal o profesional? ¬øAfecta entregas?</li><li><strong>2. Individual:</strong> Hablar con cada uno por separado. Escuchar sin juzgar.</li><li><strong>3. Encontrar ra√≠z:</strong> ¬øTerritorio? ¬øEgo? ¬øComunicaci√≥n?</li><li><strong>4. Mediaci√≥n:</strong> Reuni√≥n conjunta enfocada en objetivos del equipo.</li><li><strong>5. Acuerdos:</strong> Reglas claras de colaboraci√≥n.</li><li><strong>6. Seguimiento:</strong> Check-ins peri√≥dicos.</li></ul><p><strong>Si persiste:</strong> Escalar a HR, considerar reorganizaci√≥n.</p>",
      "analogia": "Conflicto entre seniors es como dos pilotos peleando en cabina. Primero aterrizar el avi√≥n (entregas), luego resolver el conflicto.",
      "codigo": null,
      "frase": "Conflictos no resueltos son c√°ncer de equipos. No ignores se√±ales, act√∫a r√°pido pero con tacto."
    },
    {
      "id": 41,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo migrar√≠as un monolito bancario a microservicios sin detener operaciones?",
      "respuesta": "<p><strong>Estrategia Strangler Fig:</strong></p><ul><li><strong>1. Identificar bounded contexts:</strong> Mapear dominios del monolito.</li><li><strong>2. Empezar por los bordes:</strong> Features nuevas como microservicios.</li><li><strong>3. Extraer gradualmente:</strong> Un dominio a la vez (ej: Notificaciones).</li><li><strong>4. Anti-Corruption Layer:</strong> Traductor entre micro y mono.</li><li><strong>5. Database splitting:</strong> Primero replicar, luego separar.</li></ul><p><strong>Regla:</strong> Nunca big bang. Migraci√≥n de 2-3 a√±os es normal en banca.</p>",
      "analogia": "Strangler Fig es una planta que crece alrededor de un √°rbol hasta reemplazarlo. Los microservicios crecen alrededor del monolito.",
      "codigo": "// Anti-Corruption Layer\n@Service\npublic class CuentaAntiCorruptionLayer {\n    private final MonolitoClient monolito;\n    private final NuevoCuentaService nuevoServicio;\n    private final FeatureFlags flags;\n    \n    public Mono<Cuenta> getCuenta(String id) {\n        if (flags.isEnabled(\"usar-nuevo-servicio-cuentas\")) {\n            return nuevoServicio.getCuenta(id);\n        }\n        return monolito.getCuenta(id)\n            .map(this::traducirANuevoModelo);\n    }\n}",
      "frase": "Migrar monolito es marat√≥n, no sprint. Paciencia, feature flags, y nunca apagar el monolito hasta que est√© vac√≠o."
    },
    {
      "id": 42,
      "categoria": "data",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementar√≠as Outbox Pattern para garantizar consistencia entre base de datos y Kafka?",
      "respuesta": "<p><strong>Problema:</strong> Si guardas en BD y luego publicas a Kafka, puede fallar despu√©s del commit.</p><p><strong>Outbox Pattern:</strong></p><ul><li><strong>1.</strong> Transacci√≥n at√≥mica: INSERT en tabla + INSERT en outbox_events.</li><li><strong>2.</strong> Debezium/poller lee outbox_events.</li><li><strong>3.</strong> Publica a Kafka.</li><li><strong>4.</strong> Marca como procesado.</li></ul><p><strong>Beneficio:</strong> At-least-once delivery garantizado. Consumers deben ser idempotentes.</p>",
      "analogia": "Outbox es como dejar carta en bandeja de salida: la transacci√≥n la deja ah√≠, el cartero (Debezium) la recoge y env√≠a.",
      "codigo": "// Transacci√≥n at√≥mica\n@Transactional\npublic Mono<Transferencia> ejecutar(TransferenciaCmd cmd) {\n    return cuentaRepo.debitar(cmd.origen(), cmd.monto())\n        .then(cuentaRepo.acreditar(cmd.destino(), cmd.monto()))\n        .then(transferenciaRepo.guardar(cmd))\n        .then(outboxRepo.save(OutboxEvent.builder()\n            .aggregateType(\"Transferencia\")\n            .aggregateId(cmd.id())\n            .type(\"TransferenciaRealizada\")\n            .payload(toJson(cmd))\n            .build()));\n}\n\n// Debezium CDC captura cambios en outbox y publica a Kafka\n// Consumer debe ser idempotente (usar idempotency key)",
      "frase": "Sin Outbox, pierdes eventos. Con Outbox, puede duplicar. Prefiero duplicados que eventos perdidos (idempotencia)."
    },
    {
      "id": 43,
      "categoria": "reactivo",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementar√≠as Server-Sent Events (SSE) para notificaciones en tiempo real en banca?",
      "respuesta": "<p><strong>SSE vs WebSocket:</strong></p><ul><li><strong>SSE:</strong> Unidireccional servidor‚Üícliente. M√°s simple, reconexi√≥n autom√°tica.</li><li><strong>WebSocket:</strong> Bidireccional. M√°s complejo pero m√°s flexible.</li></ul><p><strong>En banca:</strong> SSE para notificaciones push (transferencias recibidas, alertas). WebSocket solo si necesitas chat o bidireccional.</p><p><strong>Implementaci√≥n:</strong> Flux que emite eventos, MediaType TEXT_EVENT_STREAM.</p>",
      "analogia": "SSE es radio: el banco transmite, t√∫ escuchas. WebSocket es tel√©fono: ambos hablan. Para notificaciones, radio basta.",
      "codigo": "@GetMapping(value = \"/notificaciones/stream\", produces = MediaType.TEXT_EVENT_STREAM_VALUE)\npublic Flux<ServerSentEvent<NotificacionDTO>> streamNotificaciones(\n        @AuthenticationPrincipal Jwt jwt) {\n    String userId = jwt.getSubject();\n    \n    return Flux.merge(\n        // Notificaciones existentes\n        notificacionService.getPendientes(userId),\n        // Nuevas notificaciones en tiempo real\n        notificacionSink.asFlux()\n            .filter(n -> n.getUserId().equals(userId))\n    )\n    .map(n -> ServerSentEvent.<NotificacionDTO>builder()\n        .id(n.getId())\n        .event(n.getTipo())\n        .data(n)\n        .build())\n    .doOnCancel(() -> log.info(\"SSE cerrado: {}\", userId));\n}",
      "frase": "SSE es subestimado. Para notificaciones unidireccionales es m√°s simple y robusto que WebSocket."
    },
    {
      "id": 44,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo mides la productividad de tu equipo de desarrollo sin caer en m√©tricas t√≥xicas?",
      "respuesta": "<p><strong>M√©tricas a EVITAR:</strong> Lines of code, commits/d√≠a, horas trabajadas.</p><p><strong>M√©tricas DORA (recomendadas):</strong></p><ul><li><strong>Deployment Frequency:</strong> ¬øCada cu√°nto desplegamos? (meta: diario)</li><li><strong>Lead Time:</strong> Commit ‚Üí producci√≥n. (meta: <1 d√≠a)</li><li><strong>Change Failure Rate:</strong> % deploys que causan incidentes. (meta: <15%)</li><li><strong>MTTR:</strong> Tiempo para recuperarse de incidente. (meta: <1 hora)</li></ul><p><strong>Complementar con:</strong> Satisfacci√≥n del equipo, deuda t√©cnica trending, cobertura tests.</p>",
      "analogia": "M√©tricas t√≥xicas son como medir chef por platos/hora: produce basura r√°pido. DORA mide si los platos llegan bien al cliente.",
      "codigo": null,
      "frase": "Si mides l√≠neas de c√≥digo, obtendr√°s c√≥digo inflado. Mide IMPACTO: qu√© tan r√°pido entregamos VALOR sin romper cosas."
    },
    {
      "id": 45,
      "categoria": "arquitectura",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo implementar√≠as idempotencia en APIs de transferencias para evitar cobros duplicados?",
      "respuesta": "<p><strong>Idempotencia = misma request, mismo resultado, sin efectos duplicados.</strong></p><p><strong>Implementaci√≥n:</strong></p><ul><li><strong>1. Idempotency Key:</strong> Cliente env√≠a UUID √∫nico en header.</li><li><strong>2. Almacenar:</strong> Redis con TTL (24h) guarda key + respuesta.</li><li><strong>3. Verificar:</strong> Si key existe, retorna respuesta guardada.</li><li><strong>4. Procesar:</strong> Si no existe, procesa y guarda.</li></ul><p><strong>Casos de uso:</strong> Transferencias, pagos, cualquier operaci√≥n no-idempotente.</p>",
      "analogia": "Es como recibo de pago: si ya pagaste (key existe), te muestro el recibo anterior. No te cobro dos veces.",
      "codigo": "@PostMapping(\"/transferencias\")\npublic Mono<TransferenciaResponse> transferir(\n        @RequestHeader(\"Idempotency-Key\") String idempotencyKey,\n        @RequestBody TransferenciaCmd cmd) {\n    \n    return idempotencyService.get(idempotencyKey)\n        .switchIfEmpty(\n            transferenciaService.ejecutar(cmd)\n                .flatMap(response -> \n                    idempotencyService.save(idempotencyKey, response, Duration.ofHours(24))\n                        .thenReturn(response))\n        );\n}\n\n// IdempotencyService con Redis\npublic Mono<TransferenciaResponse> get(String key) {\n    return redisTemplate.opsForValue()\n        .get(\"idempotency:\" + key)\n        .map(json -> fromJson(json, TransferenciaResponse.class));\n}",
      "frase": "En banca, transferencia duplicada es p√©rdida de dinero. Idempotencia no es opcional, es OBLIGATORIA."
    },
    {
      "id": 46,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es ACID en bases de datos? Expl√≠calo como si fuera una transferencia en Yape.",
      "respuesta": "<p><strong>ACID = las 4 garant√≠as de una transacci√≥n de BD:</strong></p><ul><li><strong>A - Atomicity (Atomicidad):</strong> TODO O NADA. Si yapeas S/100, o se descuenta Y llega, o ninguno. No puede quedar a medias.</li><li><strong>C - Consistency (Consistencia):</strong> REGLAS SIEMPRE SE CUMPLEN. Si tienes S/50, no puedes yapear S/100. La BD no permite estados inv√°lidos.</li><li><strong>I - Isolation (Aislamiento):</strong> CADA UNO EN SU COLA. Si t√∫ y tu hermano yapean al mismo tiempo, cada transacci√≥n es independiente.</li><li><strong>D - Durability (Durabilidad):</strong> LO QUE SE GUARD√ì, SE GUARD√ì. Si el banco dice 'transferencia exitosa', aunque se caiga el servidor, tu plata est√° segura.</li></ul>",
      "analogia": "ACID es el contrato del banco: TODO o NADA (A), respeta tus reglas (C), cada cliente en su ventanilla (I), lo firmado es ley (D).",
      "codigo": "@Transactional // Spring garantiza ACID\npublic Mono<Void> transferir(String origen, String destino, BigDecimal monto) {\n    return cuentaRepo.debitar(origen, monto)    // Si esto falla...\n        .then(cuentaRepo.acreditar(destino, monto)) // ...esto NO se ejecuta\n        .then();  // TODO O NADA (Atomicity)\n}",
      "frase": "Sin ACID, tu yape podr√≠a descontar pero no llegar. ACID es la promesa de que eso NUNCA pase."
    },
    {
      "id": 47,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Explica los patrones de microservicios por categor√≠a: Comunicaci√≥n, Datos, Resiliencia y Observabilidad.",
      "respuesta": "<p><strong>üîó COMUNICACI√ìN (c√≥mo hablan entre s√≠):</strong></p><ul><li><strong>API Gateway:</strong> Portero √∫nico de entrada.</li><li><strong>Service Discovery:</strong> P√°ginas amarillas de servicios.</li><li><strong>Sidecar:</strong> Asistente que acompa√±a a cada servicio.</li></ul><p><strong>üíæ DATOS (c√≥mo manejan info):</strong></p><ul><li><strong>Database per Service:</strong> Cada uno su BD.</li><li><strong>CQRS:</strong> Una BD para leer, otra para escribir.</li><li><strong>Event Sourcing:</strong> Guardar TODO lo que pas√≥.</li><li><strong>Saga:</strong> CTRL+Z distribuido.</li></ul><p><strong>üõ°Ô∏è RESILIENCIA (c√≥mo sobreviven):</strong></p><ul><li><strong>Circuit Breaker:</strong> Fusible que corta.</li><li><strong>Retry:</strong> Volver a intentar.</li><li><strong>Bulkhead:</strong> Compartimentos del barco.</li><li><strong>Timeout:</strong> No esperar forever.</li></ul><p><strong>üëÅÔ∏è OBSERVABILIDAD (c√≥mo los vigilas):</strong></p><ul><li><strong>Log Aggregation:</strong> Todos los logs en un lugar.</li><li><strong>Distributed Tracing:</strong> GPS del request.</li><li><strong>Health Check:</strong> ¬øEst√°s vivo?</li></ul>",
      "analogia": "Microservicios son como departamentos de empresa: COMUNICACI√ìN es c√≥mo se mandan memos, DATOS es c√≥mo guardan archivos, RESILIENCIA es plan de emergencia, OBSERVABILIDAD es las c√°maras de seguridad.",
      "codigo": "// Ejemplo combinando patrones\n@CircuitBreaker(name = \"pagos\")  // RESILIENCIA\n@Retry(name = \"pagos\")           // RESILIENCIA  \npublic Mono<PagoResponse> pagar(PagoCmd cmd) {\n    return webClient.post()      // COMUNICACI√ìN (via API Gateway)\n        .bodyValue(cmd)\n        .retrieve()\n        .bodyToMono(PagoResponse.class)\n        .doOnSuccess(r -> log.info(\"Pago OK\"))  // OBSERVABILIDAD\n        .doOnError(e -> log.error(\"Pago FAIL\")); // OBSERVABILIDAD\n}",
      "frase": "No memorices patrones, entiende QU√â PROBLEMA resuelven. Cada categor√≠a ataca un dolor espec√≠fico de microservicios."
    },
    {
      "id": 48,
      "categoria": "patrones",
      "dificultad": "senior",
      "pregunta": "¬øCu√°les son los 3 tipos de patrones de dise√±o GoF (Gang of Four)? Dame ejemplos en Java.",
      "respuesta": "<p><strong>Los 23 patrones GoF se dividen en 3 familias:</strong></p><p><strong>üèóÔ∏è CREACIONALES (c√≥mo CREAR objetos):</strong></p><ul><li><strong>Singleton:</strong> Solo UNO en todo el sistema (Config, Logger).</li><li><strong>Factory:</strong> F√°brica que decide qu√© objeto crear.</li><li><strong>Builder:</strong> Construir paso a paso (objetos complejos).</li></ul><p><strong>üß± ESTRUCTURALES (c√≥mo ORGANIZAR clases):</strong></p><ul><li><strong>Adapter:</strong> Enchufe adaptador entre incompatibles.</li><li><strong>Decorator:</strong> Agregar funcionalidad sin modificar.</li><li><strong>Facade:</strong> Fachada simple para sistema complejo.</li></ul><p><strong>üé≠ COMPORTAMIENTO (c√≥mo INTERACT√öAN):</strong></p><ul><li><strong>Strategy:</strong> Cambiar algoritmo en runtime.</li><li><strong>Observer:</strong> Notificar cuando algo cambia.</li><li><strong>Template Method:</strong> Esqueleto con pasos personalizables.</li></ul>",
      "analogia": "GoF son recetas de cocina probadas: CREACIONALES = c√≥mo preparar ingredientes, ESTRUCTURALES = c√≥mo armar el plato, COMPORTAMIENTO = c√≥mo servir y presentar.",
      "codigo": "// CREACIONAL - Builder\nTransferencia t = Transferencia.builder()\n    .origen(\"123\").destino(\"456\").monto(100).build();\n\n// ESTRUCTURAL - Adapter\npublic class LegacyBankAdapter implements ModernBankPort {\n    private LegacyBank legacy;\n    public Mono<Saldo> getSaldo(String id) {\n        return Mono.fromCallable(() -> legacy.consultarSaldo(id));\n    }\n}\n\n// COMPORTAMIENTO - Strategy\npublic interface ComisionStrategy {\n    BigDecimal calcular(BigDecimal monto);\n}\n// Cambias estrategia sin tocar c√≥digo",
      "frase": "No uses patrones por usarlos. Primero el PROBLEMA, luego buscas si hay patr√≥n que lo resuelva."
    },
    {
      "id": 49,
      "categoria": "reactivo",
      "dificultad": "senior",
      "pregunta": "¬øCu√°l es la diferencia entre operadores INTERMEDIOS y TERMINALES en programaci√≥n reactiva?",
      "respuesta": "<p><strong>üîÑ INTERMEDIOS (transforman el flujo, NO ejecutan):</strong></p><ul><li><strong>map():</strong> Transforma cada elemento.</li><li><strong>filter():</strong> Filtra elementos.</li><li><strong>flatMap():</strong> Transforma y aplana.</li><li><strong>take(n):</strong> Toma solo n elementos.</li><li><strong>distinct():</strong> Elimina duplicados.</li><li><strong>doOnNext():</strong> Side effect sin modificar.</li></ul><p><strong>üèÅ TERMINALES (disparan la ejecuci√≥n):</strong></p><ul><li><strong>subscribe():</strong> ¬°ARRANCA!</li><li><strong>block():</strong> Espera resultado (¬°evitar!).</li><li><strong>collectList():</strong> Junta todo en lista.</li><li><strong>count():</strong> Cuenta elementos.</li><li><strong>then():</strong> Cuando termine, haz esto.</li></ul><p><strong>REGLA DE ORO:</strong> Sin operador terminal, NADA se ejecuta. Es como armar receta pero nunca cocinar.</p>",
      "analogia": "Intermedios son INSTRUCCIONES de la receta (picar, mezclar, sazonar). Terminales son COCINAR (meter al horno). Sin cocinar, solo tienes papel con instrucciones.",
      "codigo": "// NADA se ejecuta (solo intermedios)\nFlux.just(1, 2, 3)\n    .map(n -> n * 2)      // Intermedio\n    .filter(n -> n > 2);   // Intermedio - ¬°RECETA SIN COCINAR!\n\n// AHORA S√ç se ejecuta (terminal)\nFlux.just(1, 2, 3)\n    .map(n -> n * 2)      // Intermedio\n    .filter(n -> n > 2)    // Intermedio  \n    .subscribe(System.out::println);  // TERMINAL = ¬°ARRANCA!",
      "frase": "Sin subscribe(), tu c√≥digo reactivo es letra muerta. Es el bot√≥n de PLAY."
    },
    {
      "id": 50,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es programaci√≥n funcional y cu√°les son sus principios? Expl√≠calo con ejemplos de Yape.",
      "respuesta": "<p><strong>Programaci√≥n Funcional = c√≥digo como FUNCIONES MATEM√ÅTICAS:</strong></p><p><strong>üìå PRINCIPIOS:</strong></p><ul><li><strong>Inmutabilidad:</strong> Datos NO se modifican, se crean nuevos. Tu saldo no se 'modifica', se crea nuevo estado.</li><li><strong>Funciones Puras:</strong> Mismo input = mismo output. calcularComision(100) SIEMPRE = 2.</li><li><strong>Sin Side Effects:</strong> Funci√≥n no modifica nada externo.</li><li><strong>First-Class Functions:</strong> Funciones son valores, se pasan como par√°metros.</li><li><strong>Higher-Order Functions:</strong> Funciones que reciben/retornan funciones (map, filter, reduce).</li></ul><p><strong>BENEFICIOS:</strong> C√≥digo predecible, f√°cil de testear, paralelizable.</p>",
      "analogia": "Funcional es cocina de RECETAS EXACTAS: mismos ingredientes = mismo plato. No hay 'a ojo'. Imperativo es cocina de abuelita: '√©chale hasta que sepa bien'.",
      "codigo": "// IMPERATIVO (mutable, side effects)\nList<Movimiento> filtrados = new ArrayList<>();\nfor (Movimiento m : movimientos) {\n    if (m.getMonto() > 100) {\n        filtrados.add(m);  // Muta lista externa\n    }\n}\n\n// FUNCIONAL (inmutable, puro)\nList<Movimiento> filtrados = movimientos.stream()\n    .filter(m -> m.getMonto() > 100)  // Funci√≥n pura\n    .collect(Collectors.toList());     // Nueva lista, no muta",
      "frase": "Funcional no es moda, es PREDICTIBILIDAD. En banca, necesitas saber que 2+2 siempre ser√° 4."
    },
    {
      "id": 51,
      "categoria": "azure",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es Azure Data Factory y cu√°ndo lo usar√≠as en un proyecto bancario?",
      "respuesta": "<p><strong>Azure Data Factory (ADF) = ORQUESTADOR de movimiento de datos:</strong></p><ul><li><strong>ETL/ELT:</strong> Extrae de BD, archivos, APIs ‚Üí Transforma ‚Üí Carga a destino.</li><li><strong>Pipelines:</strong> Flujos visuales de datos con actividades.</li><li><strong>Conectores:</strong> +90 fuentes (SQL, Oracle, SAP, S3, APIs REST).</li><li><strong>Triggers:</strong> Por horario, evento, o tumbling window.</li></ul><p><strong>EN BANCA:</strong></p><ul><li>Migraci√≥n nocturna de transacciones a Data Lake.</li><li>Consolidaci√≥n de datos de m√∫ltiples cores bancarios.</li><li>Alimentar dashboards de riesgo con data de producci√≥n.</li></ul>",
      "analogia": "ADF es el CAMI√ìN DE MUDANZA de datos: recoge cajas (datos) de varias casas (fuentes), las reorganiza en el camino (transforma), y las deja en la nueva casa (destino).",
      "codigo": "// Pipeline ADF (JSON simplificado)\n{\n  \"name\": \"MigracionTransaccionesDiaria\",\n  \"activities\": [\n    {\n      \"name\": \"CopiarDesdeOracle\",\n      \"type\": \"Copy\",\n      \"source\": { \"type\": \"OracleSource\", \"query\": \"SELECT * FROM TXN WHERE fecha = @today\" },\n      \"sink\": { \"type\": \"AzureBlobSink\", \"path\": \"raw/transacciones/\" }\n    },\n    {\n      \"name\": \"TransformarConDataflow\",\n      \"type\": \"DataFlow\",\n      \"dependsOn\": [\"CopiarDesdeOracle\"]\n    }\n  ],\n  \"trigger\": { \"type\": \"Schedule\", \"recurrence\": \"0 2 * * *\" }\n}",
      "frase": "ADF no es para tiempo real, es para BATCH. Si necesitas mover TB de datos cada noche, ADF es tu amigo."
    },
    {
      "id": 52,
      "categoria": "azure",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es Azure Functions y cu√°ndo lo usar√≠as vs un microservicio tradicional?",
      "respuesta": "<p><strong>Azure Functions = SERVERLESS, c√≥digo que corre sin servidor:</strong></p><ul><li><strong>Event-Driven:</strong> Se ejecuta cuando pasa algo (HTTP, Queue, Timer, Blob).</li><li><strong>Pay-per-execution:</strong> Solo pagas cuando corre.</li><li><strong>Auto-scale:</strong> Escala de 0 a miles autom√°ticamente.</li><li><strong>Cold Start:</strong> Primera ejecuci√≥n puede demorar (desventaja).</li></ul><p><strong>USAR FUNCTIONS:</strong> Tareas cortas, event-driven, tr√°fico impredecible.</p><p><strong>USAR MICROSERVICIO:</strong> Procesos largos, estado, tr√°fico constante, latencia cr√≠tica.</p>",
      "analogia": "Functions es TAXI: lo llamas cuando necesitas, pagas el viaje, se va. Microservicio es AUTO PROPIO: siempre disponible pero pagas parking aunque no lo uses.",
      "codigo": "// Azure Function - Trigger HTTP\n@FunctionName(\"ValidarTransferencia\")\npublic HttpResponseMessage validar(\n    @HttpTrigger(name = \"req\", methods = {HttpMethod.POST}) HttpRequestMessage<TransferenciaDTO> request,\n    ExecutionContext context) {\n    \n    TransferenciaDTO tx = request.getBody();\n    boolean valida = tx.getMonto().compareTo(BigDecimal.ZERO) > 0;\n    \n    return request.createResponseBuilder(valida ? HttpStatus.OK : HttpStatus.BAD_REQUEST)\n        .body(valida ? \"OK\" : \"Monto inv√°lido\")\n        .build();\n}\n\n// Trigger por Cola (procesar eventos)\n@FunctionName(\"ProcesarNotificacion\")\npublic void procesar(\n    @QueueTrigger(name = \"msg\", queueName = \"notificaciones\") String mensaje) {\n    // Se ejecuta cada vez que llega mensaje a la cola\n}",
      "frase": "Functions para picos impredecibles y eventos. Microservicio para carga constante. No todo debe ser serverless."
    },
    {
      "id": 53,
      "categoria": "azure",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es ACR (Azure Container Registry) y c√≥mo se integra con AKS?",
      "respuesta": "<p><strong>ACR = tu ALMAC√âN PRIVADO de im√°genes Docker:</strong></p><ul><li><strong>Registry privado:</strong> Como Docker Hub pero solo para tu empresa.</li><li><strong>Geo-replicaci√≥n:</strong> Im√°genes cerca de donde despliegas.</li><li><strong>Escaneo de vulnerabilidades:</strong> Detecta CVEs en tus im√°genes.</li><li><strong>Integraci√≥n nativa AKS:</strong> AKS jala im√°genes sin config extra.</li></ul><p><strong>FLUJO CI/CD:</strong></p><ol><li>Build imagen en pipeline.</li><li>Push a ACR con tag (v1.2.3).</li><li>AKS hace pull de ACR.</li><li>Kubernetes despliega pods.</li></ol>",
      "analogia": "ACR es tu BODEGA PRIVADA de contenedores. AKS es el PUERTO que descarga los contenedores y los pone a trabajar.",
      "codigo": "# Build y push a ACR\naz acr build --registry miregistro --image ms-transferencias:v1.2.3 .\n\n# Kubernetes deployment jalando de ACR\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: ms-transferencias\nspec:\n  template:\n    spec:\n      containers:\n        - name: app\n          image: miregistro.azurecr.io/ms-transferencias:v1.2.3\n          # AKS ya tiene permisos a ACR (managed identity)",
      "frase": "ACR + AKS es el combo nativo de Azure para contenedores. Integraci√≥n sin dolor de cabeza."
    },
    {
      "id": 54,
      "categoria": "azure",
      "dificultad": "senior",
      "pregunta": "¬øCu√°l es la diferencia entre Web App for Containers y AKS? ¬øCu√°ndo usar cada uno?",
      "respuesta": "<p><strong>üåê WEB APP FOR CONTAINERS (App Service):</strong></p><ul><li><strong>PaaS simple:</strong> Subes contenedor, Azure maneja todo.</li><li><strong>Sin orquestaci√≥n:</strong> Un contenedor por app.</li><li><strong>Auto-scale b√°sico:</strong> Por CPU/memoria.</li><li><strong>Ideal para:</strong> APIs simples, equipos peque√±os, MVPs.</li></ul><p><strong>‚ò∏Ô∏è AKS (Azure Kubernetes Service):</strong></p><ul><li><strong>Orquestaci√≥n completa:</strong> Kubernetes managed.</li><li><strong>Multi-contenedor:</strong> Pods, sidecars, service mesh.</li><li><strong>Control total:</strong> Networking, storage, scaling avanzado.</li><li><strong>Ideal para:</strong> Microservicios complejos, equipos grandes, producci√≥n enterprise.</li></ul>",
      "analogia": "Web App es DEPARTAMENTO AMOBLADO: llegas y vives. AKS es TERRENO + MATERIALES: construyes como quieras pero t√∫ armas todo.",
      "codigo": "# Web App for Containers - Simple\naz webapp create --name mi-api \\\n  --resource-group mi-rg \\\n  --plan mi-plan \\\n  --deployment-container-image-name miregistro.azurecr.io/mi-api:latest\n\n# AKS - M√°s control pero m√°s config\nkubectl apply -f deployment.yaml\nkubectl apply -f service.yaml\nkubectl apply -f ingress.yaml\nkubectl apply -f hpa.yaml\n# ... y m√°s manifiestos",
      "frase": "¬øTienes 1-5 servicios simples? Web App. ¬øTienes 20+ microservicios con service mesh? AKS."
    },
    {
      "id": 55,
      "categoria": "azure",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es Azure Key Vault y c√≥mo lo usar√≠as para secretos en microservicios?",
      "respuesta": "<p><strong>Key Vault = CAJA FUERTE de Azure para secretos:</strong></p><ul><li><strong>Secrets:</strong> Passwords, connection strings, API keys.</li><li><strong>Keys:</strong> Llaves criptogr√°ficas (encrypt/decrypt).</li><li><strong>Certificates:</strong> SSL/TLS certificates.</li><li><strong>Access Policies:</strong> Qui√©n puede leer qu√©.</li><li><strong>Audit Logs:</strong> Qui√©n accedi√≥ a qu√© secreto.</li></ul><p><strong>INTEGRACI√ìN:</strong></p><ul><li><strong>Managed Identity:</strong> App se autentica sin credenciales.</li><li><strong>AKS + CSI Driver:</strong> Secretos se montan como archivos.</li><li><strong>Spring Boot:</strong> @Value lee directo de Key Vault.</li></ul>",
      "analogia": "Key Vault es la B√ìVEDA del banco donde guardas las llaves de las otras b√≥vedas. Nadie tiene la llave pegada en la puerta.",
      "codigo": "// Spring Boot con Azure Key Vault\n// application.yml\nazure:\n  keyvault:\n    uri: https://mi-vault.vault.azure.net/\n\n// Uso en c√≥digo - el secreto se jala autom√°tico\n@Value(\"${db-password}\")\nprivate String dbPassword;\n\n// AKS con CSI Driver\napiVersion: v1\nkind: Pod\nspec:\n  containers:\n    - name: app\n      volumeMounts:\n        - name: secrets\n          mountPath: \"/mnt/secrets\"\n          readOnly: true\n  volumes:\n    - name: secrets\n      csi:\n        driver: secrets-store.csi.k8s.io\n        volumeAttributes:\n          secretProviderClass: azure-keyvault",
      "frase": "Secreto en c√≥digo = despido. Secreto en Key Vault = pr√°ctica profesional. En banca, es requisito regulatorio."
    },
    {
      "id": 56,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Explica el patr√≥n Saga con sus dos variantes: Orquestada y Coreografiada.",
      "respuesta": "<p><strong>SAGA = Transacci√≥n distribuida con compensaciones (CTRL+Z):</strong></p><p><strong>üé≠ ORQUESTADA (Director de orquesta):</strong></p><ul><li>Un COORDINADOR central controla todo el flujo.</li><li>Llama servicio A ‚Üí si OK ‚Üí llama B ‚Üí si OK ‚Üí llama C.</li><li>Si falla C ‚Üí compensa B ‚Üí compensa A.</li><li><strong>Pro:</strong> F√°cil de debuggear, flujo claro.</li><li><strong>Con:</strong> Coordinador es punto de fallo.</li></ul><p><strong>üíÉ COREOGRAFIADA (Baile sin director):</strong></p><ul><li>Cada servicio REACCIONA a eventos.</li><li>A publica evento ‚Üí B escucha y act√∫a ‚Üí B publica ‚Üí C escucha.</li><li><strong>Pro:</strong> Desacoplado, no hay punto central de fallo.</li><li><strong>Con:</strong> Dif√≠cil seguir el flujo, debugging complejo.</li></ul>",
      "analogia": "ORQUESTADA es director de orquesta: √©l dice qui√©n toca cu√°ndo. COREOGRAFIADA es jam session: cada m√∫sico escucha y reacciona.",
      "codigo": "// ORQUESTADA - Coordinador\n@Service\npublic class TransferenciaSagaOrquestador {\n    public Mono<Void> ejecutar(TransferenciaCmd cmd) {\n        return paso1_ValidarSaldo(cmd)\n            .then(paso2_DebitarOrigen(cmd))\n            .then(paso3_AcreditarDestino(cmd))\n            .onErrorResume(e -> compensar(cmd, e));\n    }\n}\n\n// COREOGRAFIADA - Eventos\n@KafkaListener(topics = \"cuenta-debitada\")\npublic void onCuentaDebitada(CuentaDebitadaEvent e) {\n    // Servicio destino reacciona al evento\n    acreditarCuenta(e.getDestino(), e.getMonto())\n        .subscribe();\n}",
      "frase": "Orquestada para flujos cr√≠ticos que necesitas controlar. Coreografiada para sistemas muy distribuidos y desacoplados."
    },
    {
      "id": 57,
      "categoria": "patrones",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es el patr√≥n Sidecar y c√≥mo se usa en Kubernetes/Service Mesh?",
      "respuesta": "<p><strong>SIDECAR = Contenedor ASISTENTE que acompa√±a a tu app:</strong></p><ul><li>Vive en el mismo Pod que tu aplicaci√≥n.</li><li>Comparte red y storage con el contenedor principal.</li><li>Maneja concerns transversales SIN modificar tu c√≥digo.</li></ul><p><strong>USOS COMUNES:</strong></p><ul><li><strong>Envoy (Istio):</strong> mTLS, traffic management, observability.</li><li><strong>Log collector:</strong> Fluent Bit recoge logs.</li><li><strong>Secret injector:</strong> Vault Agent inyecta secretos.</li><li><strong>Proxy:</strong> Autenticaci√≥n, rate limiting.</li></ul>",
      "analogia": "Sidecar es tu GUARDAESPALDAS: va contigo a todos lados, maneja la seguridad, t√∫ te enfocas en tu trabajo.",
      "codigo": "# Pod con Sidecar (Envoy para Service Mesh)\napiVersion: v1\nkind: Pod\nmetadata:\n  name: ms-transferencias\n  annotations:\n    sidecar.istio.io/inject: \"true\"  # Istio inyecta Envoy\nspec:\n  containers:\n    - name: app\n      image: ms-transferencias:v1\n      ports:\n        - containerPort: 8080\n    # Istio inyecta autom√°ticamente:\n    # - name: istio-proxy\n    #   image: envoy\n    #   # Intercepta TODO el tr√°fico",
      "frase": "Sidecar mueve complejidad FUERA de tu c√≥digo. Tu app hace negocio, el sidecar hace infraestructura."
    },
    {
      "id": 58,
      "categoria": "resiliencia",
      "dificultad": "senior",
      "pregunta": "Explica el patr√≥n Retry con Exponential Backoff. ¬øPor qu√© es mejor que retry simple?",
      "respuesta": "<p><strong>RETRY SIMPLE:</strong> Falla ‚Üí espera 1s ‚Üí reintenta ‚Üí espera 1s ‚Üí reintenta...</p><p><strong>PROBLEMA:</strong> Si 1000 clientes reintentan cada 1s, BOMBARDEAS al servicio ca√≠do.</p><p><strong>EXPONENTIAL BACKOFF:</strong></p><ul><li>1er retry: espera 1s</li><li>2do retry: espera 2s</li><li>3er retry: espera 4s</li><li>4to retry: espera 8s</li></ul><p><strong>+ JITTER (ruido aleatorio):</strong> A√±ade variaci√≥n para que no todos reintenten al mismo tiempo.</p>",
      "analogia": "Retry simple es 1000 personas llamando al mismo tiempo cuando se cae la l√≠nea. Backoff con jitter es cada uno esperando diferente tiempo antes de volver a llamar.",
      "codigo": "// Resilience4j con Exponential Backoff\nresilience4j:\n  retry:\n    instances:\n      servicioPagos:\n        maxAttempts: 4\n        waitDuration: 1s\n        enableExponentialBackoff: true\n        exponentialBackoffMultiplier: 2\n        enableRandomizedWait: true  # Jitter\n        randomizedWaitFactor: 0.5\n\n// Resultado: 1s, 2s (¬±50%), 4s (¬±50%), 8s (¬±50%)",
      "frase": "Backoff exponencial + jitter evita 'thundering herd'. Sin esto, tus retries pueden tumbar al servicio que intentas recuperar."
    },
    {
      "id": 59,
      "categoria": "observabilidad",
      "dificultad": "senior",
      "pregunta": "¬øQu√© es un Correlation ID y por qu√© es CR√çTICO en microservicios?",
      "respuesta": "<p><strong>Correlation ID = UUID √∫nico que viaja por TODOS los servicios:</strong></p><ul><li>Usuario hace request ‚Üí Gateway genera UUID.</li><li>UUID se propaga: Gateway ‚Üí BFF ‚Üí Servicio A ‚Üí Servicio B ‚Üí BD.</li><li>TODOS los logs incluyen ese UUID.</li><li>Cuando hay error, buscas por UUID y ves TODO el flujo.</li></ul><p><strong>SIN CORRELATION ID:</strong> 'Hay error en producci√≥n' ‚Üí buscar aguja en pajar entre millones de logs.</p><p><strong>CON CORRELATION ID:</strong> 'Error con ID abc-123' ‚Üí filtras y ves exactamente qu√© pas√≥.</p>",
      "analogia": "Correlation ID es como n√∫mero de TRACKING de tu paquete: sabes exactamente por d√≥nde pas√≥ y d√≥nde est√°.",
      "codigo": "// WebFilter que propaga Correlation ID\n@Component\npublic class CorrelationIdFilter implements WebFilter {\n    public Mono<Void> filter(ServerWebExchange ex, WebFilterChain chain) {\n        String correlationId = ex.getRequest().getHeaders()\n            .getFirst(\"X-Correlation-ID\");\n        \n        if (correlationId == null) {\n            correlationId = UUID.randomUUID().toString();\n        }\n        \n        // Agregar a response y contexto\n        ex.getResponse().getHeaders().add(\"X-Correlation-ID\", correlationId);\n        MDC.put(\"correlationId\", correlationId);  // Para logs\n        \n        return chain.filter(ex);\n    }\n}\n\n// Log autom√°ticamente incluye correlationId\nlog.info(\"Procesando transferencia\");  // {correlationId: abc-123, msg: ...}",
      "frase": "Sin Correlation ID, debuggear microservicios es IMPOSIBLE. Es tu hilo de Ariadna en el laberinto."
    },
    {
      "id": 60,
      "categoria": "data",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es consistencia eventual y c√≥mo la manejas en microservicios bancarios?",
      "respuesta": "<p><strong>CONSISTENCIA EVENTUAL = los datos EVENTUALMENTE ser√°n consistentes:</strong></p><ul><li>En sistemas distribuidos, NO puedes tener consistencia inmediata + disponibilidad + tolerancia a particiones (CAP).</li><li>Eliges: Disponibilidad + consistencia eventual.</li></ul><p><strong>EJEMPLO YAPE:</strong></p><ul><li>Yapeas S/100 ‚Üí tu saldo baja inmediatamente (tu vista).</li><li>Destino ve el dinero 2 segundos despu√©s (eventual).</li><li>Ambos estados son 'correctos' en su momento.</li></ul><p><strong>T√âCNICAS:</strong></p><ul><li><strong>Eventos + Idempotencia:</strong> Procesar eventos aunque lleguen duplicados.</li><li><strong>Compensaci√≥n:</strong> Si algo falla, revertir.</li><li><strong>Read-your-writes:</strong> Usuario siempre ve SUS cambios inmediatamente.</li></ul>",
      "analogia": "Es como transferencia bancaria: t√∫ ves menos saldo inmediatamente, el otro lo ve despu√©s. No es 'inconsistente', es 'eventualmente consistente'.",
      "codigo": "// Read-your-writes con cache local\npublic Mono<Saldo> getSaldo(String cuentaId, String usuarioId) {\n    // Primero revisa cache local del usuario (ve sus cambios)\n    return cacheLocal.get(cuentaId + \":\" + usuarioId)\n        .switchIfEmpty(\n            // Si no hay, va a la BD (consistencia eventual)\n            saldoRepository.findByCuentaId(cuentaId)\n        );\n}\n\npublic Mono<Void> transferir(TransferenciaCmd cmd) {\n    return ejecutarTransferencia(cmd)\n        .then(cacheLocal.put(cmd.origen(), nuevoSaldo))  // Usuario ve su cambio\n        .then(publicarEvento(new TransferenciaRealizada(cmd)));  // Eventual\n}",
      "frase": "En microservicios, consistencia inmediata es mentira costosa. Acepta eventual, dise√±a para ella, y duerme tranquilo."
    },
    {
      "id": 61,
      "categoria": "azure",
      "dificultad": "lead",
      "pregunta": "Dise√±a una arquitectura completa en Azure para un sistema bancario de pagos.",
      "respuesta": "<p><strong>üèóÔ∏è ARQUITECTURA AZURE PARA PAGOS:</strong></p><p><strong>ENTRADA:</strong></p><ul><li><strong>Azure Front Door:</strong> CDN + WAF + Load Balancing global.</li><li><strong>API Management:</strong> Rate limiting, auth, throttling.</li></ul><p><strong>C√ìMPUTO:</strong></p><ul><li><strong>AKS:</strong> Microservicios en Kubernetes.</li><li><strong>Azure Functions:</strong> Eventos async (notificaciones).</li></ul><p><strong>DATOS:</strong></p><ul><li><strong>Azure SQL:</strong> Transacciones ACID.</li><li><strong>Cosmos DB:</strong> Lecturas r√°pidas, global distribution.</li><li><strong>Redis Cache:</strong> Sesiones, rate limiting.</li></ul><p><strong>MENSAJER√çA:</strong></p><ul><li><strong>Service Bus:</strong> Colas transaccionales.</li><li><strong>Event Hub:</strong> Streaming alto volumen.</li></ul><p><strong>SEGURIDAD:</strong></p><ul><li><strong>Key Vault:</strong> Secretos.</li><li><strong>Managed Identity:</strong> Auth sin passwords.</li><li><strong>Private Link:</strong> Todo en red privada.</li></ul><p><strong>OBSERVABILIDAD:</strong></p><ul><li><strong>Application Insights:</strong> APM.</li><li><strong>Log Analytics:</strong> Logs centralizados.</li><li><strong>Azure Monitor:</strong> Alertas.</li></ul>",
      "analogia": "Es como construir un banco f√≠sico: Front Door es la fachada con seguridad, AKS son las ventanillas, SQL es la b√≥veda, Redis es la caja chica, Key Vault guarda las llaves maestras.",
      "codigo": "# Terraform simplificado\nresource \"azurerm_kubernetes_cluster\" \"aks\" {\n  name                = \"aks-pagos\"\n  kubernetes_version  = \"1.28\"\n  default_node_pool {\n    vm_size    = \"Standard_D4s_v3\"\n    node_count = 3\n  }\n}\n\nresource \"azurerm_redis_cache\" \"cache\" {\n  name     = \"redis-pagos\"\n  sku_name = \"Premium\"\n}\n\nresource \"azurerm_key_vault\" \"vault\" {\n  name = \"kv-pagos\"\n  sku_name = \"premium\"\n}",
      "frase": "Azure te da los Legos, t√∫ armas el castillo. Esta arquitectura escala a millones de transacciones."
    },
    {
      "id": 62,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "¬øQu√© significa BASE vs ACID en bases de datos distribuidas?",
      "respuesta": "<p><strong>ACID (SQL tradicional):</strong></p><ul><li><strong>A</strong>tomicity - Todo o nada</li><li><strong>C</strong>onsistency - Reglas siempre v√°lidas</li><li><strong>I</strong>solation - Transacciones aisladas</li><li><strong>D</strong>urability - Persistencia garantizada</li></ul><p><strong>BASE (NoSQL/Distribuido):</strong></p><ul><li><strong>BA</strong>sically Available - Siempre responde algo</li><li><strong>S</strong>oft state - Estado puede cambiar sin input</li><li><strong>E</strong>ventual consistency - Eventualmente consistente</li></ul><p><strong>CU√ÅNDO USAR:</strong></p><ul><li><strong>ACID:</strong> Transferencias, pagos, inventario cr√≠tico.</li><li><strong>BASE:</strong> Likes, vistas, analytics, cache.</li></ul>",
      "analogia": "ACID es notario: todo legal, firmado, sellado. BASE es WhatsApp: el mensaje llegar√° eventualmente, pero siempre puedes enviar.",
      "codigo": "// ACID - PostgreSQL transaccional\n@Transactional(isolation = Isolation.SERIALIZABLE)\npublic void transferir(String origen, String destino, BigDecimal monto) {\n    cuentaRepo.debitar(origen, monto);\n    cuentaRepo.acreditar(destino, monto);\n}  // Commit o rollback autom√°tico\n\n// BASE - MongoDB eventual\npublic Mono<Void> registrarVista(String videoId) {\n    return mongoTemplate.updateFirst(\n        query(where(\"id\").is(videoId)),\n        new Update().inc(\"vistas\", 1),  // Eventual, no cr√≠tico\n        Video.class\n    ).then();\n}",
      "frase": "No todo necesita ACID. Pagar s√≠. Contar likes no. Usa la herramienta correcta para el problema."
    },
    {
      "id": 63,
      "categoria": "reactivo",
      "dificultad": "lead",
      "pregunta": "¬øCu√°l es la diferencia entre Cold y Hot Publishers en programaci√≥n reactiva?",
      "respuesta": "<p><strong>ü•∂ COLD PUBLISHER (Perezoso):</strong></p><ul><li>NO hace nada hasta que alguien se suscribe.</li><li>Cada suscriptor recibe su PROPIA ejecuci√≥n desde el inicio.</li><li>Ejemplo: Consulta a BD, llamada HTTP.</li></ul><p><strong>üî• HOT PUBLISHER (Activo):</strong></p><ul><li>Emite datos aunque nadie escuche.</li><li>Suscriptores reciben datos desde cuando se conectan (se pierden los anteriores).</li><li>Ejemplo: Eventos de mouse, precios de acciones en tiempo real, WebSocket.</li></ul><p><strong>CONVERTIR:</strong> .share() o .cache() convierten Cold ‚Üí Hot.</p>",
      "analogia": "COLD es Netflix: la pel√≠cula empieza cuando T√ö le das play. HOT es TV en vivo: est√° transmitiendo, te conectas y ves desde ah√≠.",
      "codigo": "// COLD - Cada suscriptor ejecuta la consulta\nMono<Usuario> coldMono = usuarioRepo.findById(\"123\");\ncoldMono.subscribe();  // Ejecuta query\ncoldMono.subscribe();  // Ejecuta query OTRA VEZ\n\n// HOT con cache - Una ejecuci√≥n, m√∫ltiples suscriptores\nMono<Usuario> hotMono = usuarioRepo.findById(\"123\").cache();\nhotMono.subscribe();  // Ejecuta query\nhotMono.subscribe();  // USA CACHE, no re-ejecuta\n\n// HOT con share - Comparte ejecuci√≥n en curso\nFlux<Precio> precios = precioService.streamPrecios().share();\nprecios.subscribe(p -> log.info(\"Suscriptor 1: {}\", p));\nprecios.subscribe(p -> log.info(\"Suscriptor 2: {}\", p));  // Mismo stream",
      "frase": "Cold para consultas (cada uno su resultado). Hot para eventos en tiempo real (todos ven lo mismo)."
    },
    {
      "id": 64,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "¬øQu√© es el patr√≥n Strangler Fig y c√≥mo migras un monolito sin downtime?",
      "respuesta": "<p><strong>STRANGLER FIG = Migraci√≥n gradual rodeando al monolito:</strong></p><ol><li><strong>Identificar bounded context:</strong> ¬øQu√© dominio extraer primero?</li><li><strong>Crear microservicio nuevo:</strong> Implementa la funcionalidad.</li><li><strong>Facade/Proxy:</strong> Router decide: ¬ømonolito o micro?</li><li><strong>Migrar tr√°fico gradual:</strong> 10% ‚Üí 50% ‚Üí 100% al micro.</li><li><strong>Eliminar c√≥digo del monolito:</strong> Cuando 100% migrado.</li><li><strong>Repetir:</strong> Siguiente dominio.</li></ol><p><strong>DURACI√ìN T√çPICA:</strong> 2-4 a√±os en banca. NO es sprint, es marat√≥n.</p>",
      "analogia": "Strangler Fig es planta que crece ALREDEDOR del √°rbol viejo hasta reemplazarlo. El √°rbol (monolito) sigue vivo mientras la planta (micros) crece.",
      "codigo": "// Facade que decide monolito vs microservicio\n@Service\npublic class TransferenciaFacade {\n    @Value(\"${feature.usar-nuevo-servicio}\") \n    private int porcentajeNuevo;  // 0, 10, 50, 100\n    \n    public Mono<TransferenciaResponse> transferir(TransferenciaCmd cmd) {\n        if (shouldUseNewService()) {\n            return nuevoMicroservicio.transferir(cmd);  // Nuevo\n        }\n        return monolitoClient.transferir(cmd);  // Legacy\n    }\n    \n    private boolean shouldUseNewService() {\n        return random.nextInt(100) < porcentajeNuevo;\n    }\n}",
      "frase": "Migrar monolito de golpe es suicidio. Strangler te da red de seguridad: si el micro falla, el monolito sigue ah√≠."
    },
    {
      "id": 65,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "¬øC√≥mo documentas decisiones arquitect√≥nicas? Explica ADR (Architecture Decision Records).",
      "respuesta": "<p><strong>ADR = Documento corto que explica UNA decisi√≥n t√©cnica:</strong></p><p><strong>ESTRUCTURA:</strong></p><ul><li><strong>T√≠tulo:</strong> ADR-001: Usar PostgreSQL como BD principal.</li><li><strong>Estado:</strong> Propuesto ‚Üí Aceptado ‚Üí Deprecado ‚Üí Reemplazado.</li><li><strong>Contexto:</strong> ¬øQu√© problema enfrentamos?</li><li><strong>Decisi√≥n:</strong> ¬øQu√© decidimos?</li><li><strong>Consecuencias:</strong> Pros, contras, trade-offs.</li><li><strong>Alternativas consideradas:</strong> ¬øQu√© m√°s evaluamos?</li></ul><p><strong>BENEFICIOS:</strong> Nuevos devs entienden el 'por qu√©', evitas re-discutir decisiones, documentaci√≥n viva.</p>",
      "analogia": "ADR es como acta de reuni√≥n de arquitectura: qued√≥ documentado QU√â se decidi√≥, POR QU√â, y QU√â se descart√≥. No hay 'yo no sab√≠a'.",
      "codigo": "# docs/adr/ADR-001-usar-postgresql.md\n\n# ADR-001: Usar PostgreSQL como base de datos principal\n\n## Estado\nAceptado (2024-01-15)\n\n## Contexto\nNecesitamos BD para transacciones bancarias. \nRequisitos: ACID, JSON support, performance.\n\n## Decisi√≥n\nUsaremos PostgreSQL 15.\n\n## Consecuencias\n### Positivas\n- ACID completo para transacciones\n- JSON/JSONB para flexibilidad\n- Ecosistema maduro, buen soporte\n\n### Negativas\n- Escala vertical principalmente\n- Sharding manual si crecemos mucho\n\n## Alternativas Consideradas\n- MySQL: Descartado por JSON support inferior\n- MongoDB: Descartado por necesidad de ACID\n- CockroachDB: Descartado por costo y complejidad",
      "frase": "C√≥digo sin ADRs es como edificio sin planos: nadie sabe por qu√© se construy√≥ as√≠. Documenta decisiones, no solo c√≥digo."
    }
  ]
}
