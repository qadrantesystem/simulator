{
  "metadata": {
    "version": "2.0",
    "estilo": "PÃ­ldoras Narrativas - Tech Lead Edition",
    "autor": "WorldReactive",
    "totalPreguntas": 40,
    "categorias": ["fundamentos", "paradigmas", "java-evolution", "funcional", "reactivo", "frameworks", "seguridad", "mensajeria", "cloud", "patrones", "liderazgo"]
  },
  "preguntas": [
    {
      "id": 1,
      "categoria": "fundamentos",
      "dificultad": "junior",
      "pregunta": "Â¿QuÃ© son JVM, JRE y JDK?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Cocina de JavaLandia</p><p class='narrador'>En el reino de JavaLandia existe una cocina legendaria...</p><div class='personaje'><strong>ğŸ‘¨â€ğŸ³ JVM = EL COCINERO</strong><p>Lee tu receta (bytecode) y prepara el plato. No le importa si viene de Windows o Mac, Ã©l cocina igual.</p></div><div class='personaje'><strong>ğŸ½ï¸ JRE = EL RESTAURANTE</strong><p>Cocina equipada: cocinero + ollas + platos. Solo puedes COMER (ejecutar), no crear recetas.</p></div><div class='personaje'><strong>ğŸ­ JDK = LA ESCUELA DE CHEFS</strong><p>Instituto completo: restaurante + aulas + cuchillos pro (compilador). AquÃ­ CREAS recetas.</p></div></div>",
      "codigo": "# Â¿QuÃ© tienes?\njava -version   # JRE (ejecutar)\njavac -version  # JDK (compilar)\n\n# Flujo:\n# MiApp.java â†’ javac â†’ MiApp.class â†’ java â†’ Ejecuta",
      "frase": "Usuario = JRE. Developer = JDK. Ambos llevan JVM."
    },
    {
      "id": 2,
      "categoria": "java-evolution",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© trajo Java 8 que cambiÃ³ todo?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La RevoluciÃ³n de 2014</p><p class='narrador'>Era un tiempo oscuro. Los developers escribÃ­an 50 lÃ­neas para filtrar una lista...</p><div class='heroe'><strong>âš¡ JAVA 8 - EL REVOLUCIONARIO</strong><p>LlegÃ³ con poderes nunca vistos:</p><ul><li><strong>LAMBDAS:</strong> Funciones en 1 lÃ­nea â†’ <code>(x) -> x * 2</code></li><li><strong>STREAMS:</strong> Datos que fluyen, se filtran, se transforman</li><li><strong>OPTIONAL:</strong> AdiÃ³s NullPointerException</li><li><strong>INTERFACES FUNCIONALES:</strong> Predicate, Consumer, Function, Supplier</li></ul></div></div>",
      "codigo": "// ANTES - Sufrimiento\nList<String> filtrados = new ArrayList<>();\nfor (Cuenta c : cuentas) {\n    if (c.getSaldo() > 1000) filtrados.add(c.getTitular());\n}\n\n// JAVA 8 - IluminaciÃ³n âœ¨\nList<String> filtrados = cuentas.stream()\n    .filter(c -> c.getSaldo() > 1000)\n    .map(Cuenta::getTitular)\n    .collect(Collectors.toList());",
      "frase": "Java 8 no fue versiÃ³n, fue REVOLUCIÃ“N."
    },
    {
      "id": 3,
      "categoria": "java-evolution",
      "dificultad": "senior",
      "pregunta": "Â¿Por quÃ© Java 11 es LTS?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Toyota Corolla</p><p class='narrador'>En el concesionario, los arquitectos buscaban confiabilidad...</p><div class='personaje'><strong>ğŸš— JAVA 11 LTS</strong><p>No es sexy pero es LTS = soporte por AÃ‘OS.</p><p><em>\"Las empresas serias quieren Corolla, no Tesla beta\"</em></p><ul><li><strong>var en lambdas</strong></li><li><strong>String:</strong> isBlank(), strip(), repeat()</li><li><strong>HttpClient moderno</strong></li><li><strong>Ejecutar directo:</strong> java MiApp.java</li></ul></div><div class='alerta'><strong>LTS:</strong> 8, 11, 17, 21 - Las Ãºnicas con soporte largo.</div></div>",
      "codigo": "// Java 11 goodies\n\"  \".isBlank();        // true\n\"ja\".repeat(3);        // \"jajaja\"\n\"  hola  \".strip();    // \"hola\"\n\n// HttpClient moderno\nvar client = HttpClient.newHttpClient();\nvar response = client.send(request, BodyHandlers.ofString());",
      "frase": "Java 11 LTS: el Corolla. Estable, soporte largo, cero drama."
    },
    {
      "id": 4,
      "categoria": "java-evolution",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© tiene Java 17 que todos quieren?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Mago del Boilerplate</p><p class='narrador'>Los developers estaban hartos de escribir 50 lÃ­neas para un DTO...</p><div class='heroe'><strong>âœ¨ JAVA 17</strong><p><em>\"Â¿50 lÃ­neas para getters? Observa esto...\"</em></p><ul><li><strong>RECORDS:</strong> DTOs en 1 lÃ­nea</li><li><strong>PATTERN MATCHING:</strong> Cast automÃ¡tico</li><li><strong>SEALED CLASSES:</strong> Controlas quiÃ©n hereda</li><li><strong>TEXT BLOCKS:</strong> Strings multilÃ­nea</li></ul></div><div class='alerta'>âš ï¸ Spring Boot 3+ REQUIERE Java 17</div></div>",
      "codigo": "// RECORD - 1 lÃ­nea = constructor + getters + equals + hashCode + toString\npublic record CuentaDTO(String id, BigDecimal saldo) {}\n\n// PATTERN MATCHING\nif (obj instanceof Cuenta c) {  // Cast automÃ¡tico!\n    return c.getSaldo();\n}\n\n// TEXT BLOCKS\nString json = \"\"\"\n    {\"nombre\": \"Juan\", \"saldo\": 1500}\n    \"\"\";",
      "frase": "Records + Pattern Matching = 40% menos cÃ³digo."
    },
    {
      "id": 5,
      "categoria": "java-evolution",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© son Virtual Threads en Java 21?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Batalla de los Hilos</p><p class='narrador'>Lord Caos lanzÃ³ un millÃ³n de requests. Los Platform Threads caÃ­an...</p><div class='villano'><strong>ğŸ˜µ PLATFORM THREADS</strong><p>Cada hilo = 1MB memoria. 10,000 hilos = servidor muerto.</p></div><div class='heroe'><strong>âš¡ VIRTUAL THREADS (Java 21)</strong><p>Hilos manejados por JVM. Crea MILLONES sin sudar.</p><p><em>\"CÃ³digo bloqueante simple con performance de reactivo\"</em></p></div><div class='revelacion'><strong>ğŸ¯ Â¿AdiÃ³s WebFlux?</strong><p>Para muchos casos, sÃ­. Virtual Threads simplifica todo.</p></div></div>",
      "codigo": "// ANTES - MÃ¡ximo ~10,000 hilos\nExecutors.newFixedThreadPool(100);\n\n// JAVA 21 - Millones, cero drama\nExecutors.newVirtualThreadPerTaskExecutor();\n\n// Simple\nThread.startVirtualThread(() -> {\n    var saldo = httpClient.send(request);  // Bloquea SIN PROBLEMA\n    database.save(saldo);                   // Bloquea SIN PROBLEMA\n});",
      "frase": "Virtual Threads: cÃ³digo simple, performance de reactivo."
    },
    {
      "id": 6,
      "categoria": "paradigmas",
      "dificultad": "senior",
      "pregunta": "Â¿CuÃ¡les son los 3 paradigmas y cuÃ¡ndo uso cada uno?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Los 3 Reinos</p><p class='narrador'>En el mundo del cÃ³digo existen 3 reinos...</p><div class='reino'><strong>ğŸ° OOP</strong><p><em>\"Todo es OBJETO con datos y comportamiento\"</em></p><p>Usa cuando: Modelas entidades (Cuenta, Usuario)</p></div><div class='reino'><strong>âš¡ FUNCIONAL</strong><p><em>\"Funciones puras, sin efectos, datos inmutables\"</em></p><p>Usa cuando: Transformas datos (filter, map, reduce)</p></div><div class='reino'><strong>ğŸŒŠ REACTIVO</strong><p><em>\"Reacciona a eventos, nunca bloquees\"</em></p><p>Usa cuando: Alta concurrencia, I/O intensivo</p></div><div class='sabiduria'><strong>ğŸ§™ En Java moderno:</strong> Los 3 conviven. OOP modela, Funcional transforma, Reactivo escala.</div></div>",
      "codigo": "// ğŸ° OOP - Modelar\npublic class Cuenta {\n    private BigDecimal saldo;\n    public void depositar(BigDecimal m) { this.saldo = saldo.add(m); }\n}\n\n// âš¡ FUNCIONAL - Transformar\ncuentas.stream().filter(c -> c.estaActiva()).map(Cuenta::getSaldo).collect(toList());\n\n// ğŸŒŠ REACTIVO - No bloquear\ncuentaRepo.findById(id).map(this::enriquecer).subscribe();",
      "frase": "OOP modela, Funcional transforma, Reactivo escala. Usa los 3."
    },
    {
      "id": 7,
      "categoria": "paradigmas",
      "dificultad": "senior",
      "pregunta": "Â¿CÃ³mo combino POO con Funcional?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Alianza</p><p class='narrador'>Los sabios descubrieron que OOP y Funcional son aliados perfectos...</p><div class='alianza'><strong>ğŸ¤ LA ALIANZA:</strong><p>OOP = ESTRUCTURA (clases, entidades)</p><p>Funcional = COMPORTAMIENTO (quÃ© hacer con datos)</p></div><div class='patron'><strong>ğŸ“ EL PATRÃ“N:</strong><ol><li>Modelas con clases (OOP)</li><li>MÃ©todos usan Streams (Funcional)</li><li>Pasas comportamiento como parÃ¡metro (Lambdas)</li></ol></div></div>",
      "codigo": "// Clase OOP con comportamiento Funcional\n@Service\npublic class CuentaService {\n    // Predicates (Funcional)\n    private final Predicate<Cuenta> estaActiva = c -> \"ACTIVA\".equals(c.getEstado());\n    private final Predicate<Cuenta> tieneSaldo = c -> c.getSaldo().compareTo(ZERO) > 0;\n    \n    // MÃ©todo OOP que usa Funcional\n    public List<CuentaDTO> getCuentasParaYape(List<Cuenta> cuentas) {\n        return cuentas.stream()\n            .filter(estaActiva.and(tieneSaldo))\n            .map(this::toDTO)\n            .collect(toList());\n    }\n}",
      "frase": "OOP estructura, Funcional comporta. Juntos = poder total."
    },
    {
      "id": 8,
      "categoria": "paradigmas",
      "dificultad": "senior",
      "pregunta": "Â¿CuÃ¡les son los 4 pilares de OOP?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Los 4 Guardianes del BCP</p><p class='narrador'>En las bÃ³vedas del BCP, 4 guardianes protegen los secretos...</p><div class='guardian'><strong>ğŸ”’ ENCAPSULAMIENTO</strong><p>El cliente ve ventanilla, no bÃ³veda. Private adentro, public afuera.</p></div><div class='guardian'><strong>ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ HERENCIA</strong><p>CuentaAhorro hereda de Cuenta, pero tiene su propia tasa.</p></div><div class='guardian'><strong>ğŸ­ POLIMORFISMO</strong><p>calcularInteres() existe en todas, pero cada una calcula diferente.</p></div><div class='guardian'><strong>ğŸ¨ ABSTRACCIÃ“N</strong><p>Usas el app sin saber cÃ³mo funciona el core.</p></div></div>",
      "codigo": "// ğŸ”’ ENCAPSULAMIENTO\nprivate BigDecimal saldo;  // Oculto\npublic BigDecimal getSaldo() { return saldo; }  // Controlado\n\n// ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ HERENCIA\npublic class CuentaAhorro extends Cuenta { }\n\n// ğŸ­ POLIMORFISMO\ninterface Notificador { void enviar(String msg); }\nclass EmailNotificador implements Notificador { /*...*/ }\nclass SmsNotificador implements Notificador { /*...*/ }\n\n// ğŸ¨ ABSTRACCIÃ“N\nabstract class Transaccion { abstract void ejecutar(); }",
      "frase": "ENCAPSULAR oculta, HEREDAR comparte, POLIMORFISMO adapta, ABSTRACCIÃ“N simplifica."
    },
    {
      "id": 9,
      "categoria": "funcional",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© son las Interfaces Funcionales?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Los 4 Jinetes del Club</p><p class='narrador'>En una noche de fiesta, 4 personajes controlan el flujo...</p><div class='personaje'><strong>ğŸšª PREDICATE = Portero</strong><p>\"Â¿Cumples? SÃ­ o No\" â†’ <code>boolean test(T)</code></p></div><div class='personaje'><strong>ğŸ“¬ CONSUMER = Camarero</strong><p>\"Dame, lo proceso, no esperes respuesta\" â†’ <code>void accept(T)</code></p></div><div class='personaje'><strong>ğŸ° SUPPLIER = MÃ¡quina</strong><p>\"No me des nada, solo pide\" â†’ <code>T get()</code></p></div><div class='personaje'><strong>ğŸ”„ FUNCTION = DJ</strong><p>\"Dame algo, lo transformo\" â†’ <code>R apply(T)</code></p></div></div>",
      "codigo": "// ğŸšª PREDICATE - Â¿Pasa?\nPredicate<Cuenta> activa = c -> \"ACTIVA\".equals(c.getEstado());\nboolean pasa = activa.test(cuenta);  // true/false\n\n// ğŸ“¬ CONSUMER - Ejecuta sin retorno\nConsumer<Transferencia> log = tx -> log.info(\"TX: {}\", tx);\nlog.accept(transferencia);  // No retorna nada\n\n// ğŸ° SUPPLIER - Genera\nSupplier<String> uuid = () -> UUID.randomUUID().toString();\nString id = uuid.get();  // Genera cuando pides\n\n// ğŸ”„ FUNCTION - Transforma\nFunction<Cuenta, CuentaDTO> toDTO = c -> new CuentaDTO(c.getId());\nCuentaDTO dto = toDTO.apply(cuenta);",
      "frase": "Predicate=filtra, Consumer=ejecuta, Supplier=genera, Function=transforma."
    },
    {
      "id": 10,
      "categoria": "funcional",
      "dificultad": "senior",
      "pregunta": "Â¿Operadores Intermedios vs Terminales?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Cocina del Chef Stream</p><p class='narrador'>El Chef Stream prepara platos con un proceso especial...</p><div class='etapa'><strong>ğŸ“ INTERMEDIOS = Instrucciones</strong><p>\"Picar, mezclar, sazonar... NADA se cocina aÃºn\"</p><p>Son LAZY. Solo preparan. Retornan otro Stream.</p><ul><li>filter(), map(), flatMap(), sorted(), distinct(), limit()</li></ul></div><div class='etapa'><strong>ğŸ”¥ TERMINALES = Â¡Al Horno!</strong><p>\"Â¡COCINAR! AquÃ­ se ejecuta todo\"</p><p>Disparan la ejecuciÃ³n. Solo UNO al final.</p><ul><li>collect(), forEach(), count(), reduce(), findFirst()</li></ul></div><div class='alerta'>âš ï¸ SIN TERMINAL = NADA PASA</div></div>",
      "codigo": "// âŒ NADA SE EJECUTA - Solo intermedios\ncuentas.stream()\n    .filter(c -> c.estaActiva())   // Lazy\n    .map(Cuenta::getSaldo);         // Lazy\n// Receta escrita, nadie cocinÃ³\n\n// âœ… AHORA SÃ - Terminal dispara todo\nList<BigDecimal> saldos = cuentas.stream()\n    .filter(c -> c.estaActiva())   // Intermedio\n    .map(Cuenta::getSaldo)          // Intermedio\n    .collect(toList());             // TERMINAL - Â¡Ejecuta!",
      "frase": "Sin terminal, tu Stream es letra muerta. Es el botÃ³n PLAY."
    },
    {
      "id": 11,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "Â¿CuÃ¡l es la jerarquÃ­a de Excepciones?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Ãrbol de los Errores</p><p class='narrador'>Todas las catÃ¡strofes tienen un ancestro: Throwable...</p><div class='arbol'><pre>ğŸ‘‘ THROWABLE\nâ”œâ”€â”€ âŒ ERROR (Desastres - No manejes)\nâ”‚   â””â”€â”€ OutOfMemoryError, StackOverflowError\nâ””â”€â”€ âš ï¸ EXCEPTION (Manejables)\n    â”œâ”€â”€ ğŸ”´ Checked (Obligatorio try-catch)\n    â”‚   â””â”€â”€ IOException, SQLException\n    â””â”€â”€ ğŸŸ¡ RuntimeException (Unchecked - Opcional)\n        â””â”€â”€ NullPointerException, IllegalArgumentException</pre></div><div class='regla'><strong>ğŸ¯ REGLA:</strong><p>Checked = Problemas externos (archivo, BD)</p><p>Unchecked = Bugs tuyos (null, Ã­ndice)</p></div></div>",
      "codigo": "// ğŸ”´ CHECKED - Obligatorio manejar\ntry {\n    new FileReader(\"datos.txt\");\n} catch (FileNotFoundException e) {  // OBLIGATORIO\n    log.error(\"No existe\");\n}\n\n// ğŸŸ¡ UNCHECKED - Opcional (RuntimeException)\npublic void transferir(Cuenta c, BigDecimal m) {\n    if (c == null) throw new IllegalArgumentException(\"Cuenta null\");\n    if (m.compareTo(ZERO) <= 0) throw new IllegalArgumentException(\"Monto invÃ¡lido\");\n}\n\n// âŒ ERROR - No manejes, deja que muera\n// catch (OutOfMemoryError e) { } // Â¡NO!",
      "frase": "Checked=mundo. Unchecked=tÃº. Error=apocalipsis."
    },
    {
      "id": 12,
      "categoria": "reactivo",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es ProgramaciÃ³n Reactiva?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Restaurante vs Food Court</p><p class='narrador'>Dos formas de servir a miles de clientes...</p><div class='comparacion'><div class='opcion'><strong>ğŸ– TRADICIONAL (Bloqueante)</strong><p>Pides pollo, te quedas PARADO 20 min esperando.</p><p>1,000 clientes = 1,000 meseros = ğŸ’¸ğŸ’¸ğŸ’¸</p></div><div class='opcion'><strong>ğŸ• REACTIVO (No Bloqueante)</strong><p>Pides, te dan BEEPER, te sientas. Te avisan cuando estÃ¡.</p><p>1,000 clientes = 10 meseros = ğŸ’° (90% ahorro)</p></div></div><div class='impacto'><strong>ğŸš€ EN YAPE:</strong><p>100,000 usuarios en hora punta.</p><p>Tradicional: 100 servidores. Reactivo: 10 servidores.</p></div></div>",
      "codigo": "// ğŸ– BLOQUEANTE - Hilo muerto esperando\npublic Saldo getSaldo(String id) {\n    return repository.findById(id);  // ğŸ˜´ Esperando...\n}\n\n// ğŸ• REACTIVO - Hilo libre\npublic Mono<Saldo> getSaldo(String id) {\n    return repository.findById(id);  // ğŸƒ Sigue trabajando\n}\n\n// FLUJO COMPLETO\npublic Mono<Response> yapear(YapeRequest req) {\n    return validarCuenta(req)         // No bloquea\n        .flatMap(this::validarSaldo)  // No bloquea\n        .flatMap(this::ejecutar)      // No bloquea\n        .map(this::response);         // Transforma\n}",
      "frase": "Reactivo = beeper. No esperas, te avisan. Escala 10x."
    },
    {
      "id": 13,
      "categoria": "reactivo",
      "dificultad": "senior",
      "pregunta": "Â¿Mono vs Flux?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Delivery Reactivo</p><p class='narrador'>Dos tipos de paquetes en el delivery...</p><div class='paquete'><strong>ğŸ“¦ MONO = Un Paquete</strong><p>\"Pediste UNA pizza, te llega UNA (o ninguna)\"</p><p>Emite: 0 o 1 elemento</p><ul><li>Buscar por ID â†’ Mono&lt;Cuenta&gt;</li><li>Guardar â†’ Mono&lt;Cuenta&gt;</li><li>Transferir â†’ Mono&lt;Transferencia&gt;</li></ul></div><div class='paquete'><strong>ğŸ“¬ FLUX = SuscripciÃ³n</strong><p>\"Te suscribiste a revista. Llegan MUCHOS nÃºmeros.\"</p><p>Emite: 0 a N elementos</p><ul><li>Listar movimientos â†’ Flux&lt;Movimiento&gt;</li><li>Notificaciones real-time â†’ Flux&lt;Notif&gt;</li></ul></div></div>",
      "codigo": "// ğŸ“¦ MONO - Una respuesta\npublic Mono<Cuenta> buscar(String id) {\n    return repo.findById(id);  // 0 o 1\n}\n\n// ğŸ“¬ FLUX - MÃºltiples\npublic Flux<Movimiento> getMovimientos(String cuentaId) {\n    return repo.findByCuentaId(cuentaId);  // 0 a N\n}\n\n// CONVERSIONES\nMono<List<Mov>> lista = flux.collectList();  // Flux â†’ Mono<List>\nFlux<Cuenta> flujo = Flux.just(c1, c2);      // Varios â†’ Flux",
      "frase": "Mono=UNA cosa. Flux=MUCHAS cosas."
    },
    {
      "id": 14,
      "categoria": "frameworks",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es InyecciÃ³n de Dependencias?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Chef y los Ingredientes</p><p class='narrador'>Dos chefs preparan ceviche diferente...</p><div class='chef'><strong>ğŸ‘¨â€ğŸ³ SIN INYECCIÃ“N</strong><p>\"Yo voy al mercado, compro pescado, limones...\"</p><p>CambiÃ³ proveedor = cambio MI cÃ³digo. Para testear = ingredientes REALES.</p></div><div class='chef'><strong>ğŸ‘¨â€ğŸ³ CON INYECCIÃ“N</strong><p>\"Me TRAEN ingredientes. Yo solo cocino.\"</p><p>CambiÃ³ proveedor = no me importa. Para testear = ingredientes FALSOS (mocks).</p></div><div class='regla'><strong>ğŸ¯ REGLA:</strong> No hagas <code>new Dependencia()</code>. Declara quÃ© necesitas, el framework te lo da.</div></div>",
      "codigo": "// âŒ SIN DI - Acoplado\npublic class TransferenciaService {\n    private CuentaRepo repo = new CuentaRepoImpl();  // YO creo\n}\n\n// âœ… CON DI - Desacoplado\n@Service\npublic class TransferenciaService {\n    private final CuentaRepo repo;  // Solo DECLARO\n    \n    public TransferenciaService(CuentaRepo repo) {\n        this.repo = repo;  // Spring INYECTA\n    }\n}\n\n// TEST con mocks\nvar service = new TransferenciaService(mockRepo);",
      "frase": "DI: declaras quÃ© necesitas, el framework te lo da."
    },
    {
      "id": 15,
      "categoria": "frameworks",
      "dificultad": "junior",
      "pregunta": "Â¿QuÃ© es Lombok?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Practicante MÃ¡gico</p><p class='narrador'>Los developers hartos de cÃ³digo aburrido...</p><div class='problema'><strong>ğŸ˜« PROBLEMA:</strong><p>Una clase Cuenta = 50+ lÃ­neas de getters, setters, equals, hashCode, toString...</p></div><div class='heroe'><strong>âœ¨ LOMBOK</strong><p>\"Ponme una anotaciÃ³n, yo escribo todo.\"</p><ul><li><strong>@Data</strong> = Getters + Setters + equals + hashCode + toString</li><li><strong>@Builder</strong> = PatrÃ³n Builder</li><li><strong>@Slf4j</strong> = Logger gratis</li></ul></div></div>",
      "codigo": "// ğŸ˜« SIN LOMBOK - 50 lÃ­neas\npublic class Cuenta {\n    private String id;\n    // + getters, setters, equals, hashCode, toString...\n}\n\n// âœ¨ CON LOMBOK - 5 lÃ­neas\n@Data @Builder @NoArgsConstructor @AllArgsConstructor\npublic class Cuenta {\n    private String id;\n    private BigDecimal saldo;\n}\n\n// Uso\nCuenta c = Cuenta.builder().id(\"123\").saldo(new BigDecimal(\"1500\")).build();\n\n// @Slf4j\n@Slf4j @Service\npublic class MiServicio {\n    public void x() { log.info(\"Funciona!\"); }  // log ya existe\n}",
      "frase": "@Data + @Builder + @Slf4j = obligatorio en Java moderno."
    },
    {
      "id": 16,
      "categoria": "seguridad",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es JWT?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Pase VIP</p><p class='narrador'>En el concierto, demuestras quiÃ©n eres con un pase especial...</p><div class='vip'><strong>ğŸ« JWT = Pase VIP Firmado</strong><p>3 partes: HEADER.PAYLOAD.SIGNATURE</p><ul><li><strong>Header:</strong> Tipo de pase</li><li><strong>Payload:</strong> Tu info (nombre, roles, expiraciÃ³n)</li><li><strong>Signature:</strong> Holograma que prueba es real</li></ul></div><div class='flujo'><strong>ğŸ”„ FLUJO:</strong><p>Login â†’ Te dan JWT â†’ Lo envÃ­as en cada request â†’ Servidor verifica holograma</p></div><div class='magia'><strong>âœ¨ MAGIA:</strong> Servidor NO guarda sesiones. Todo en el token. STATELESS.</div></div>",
      "codigo": "// ESTRUCTURA\n// eyJhbGc.eyJzdWI.firma\n// HEADER.PAYLOAD.SIGNATURE\n\n// GENERAR\nString token = Jwts.builder()\n    .setSubject(usuario.getId())\n    .claim(\"roles\", usuario.getRoles())\n    .setExpiration(new Date(now + 3600000))\n    .signWith(SECRET_KEY)\n    .compact();\n\n// VALIDAR\nClaims claims = Jwts.parser()\n    .setSigningKey(SECRET_KEY)\n    .parseClaimsJws(token)\n    .getBody();\n\n// ENVIAR: Authorization: Bearer eyJhbGc...",
      "frase": "JWT: pase firmado. Servidor no guarda nada. Stateless = escala infinito."
    },
    {
      "id": 17,
      "categoria": "seguridad",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es OAuth2?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Valet Parking</p><p class='narrador'>En el hotel, accedes al carro de forma especial...</p><div class='concepto'><strong>ğŸš— OAUTH2 = Valet Parking para Datos</strong><p>Das llave ESPECIAL (token) al valet (app) para estacionar.</p><p>Pero NO le das llave de tu casa. Acceso LIMITADO y TEMPORAL.</p></div><div class='flujos'><strong>ğŸ“‹ FLUJOS:</strong><ul><li><strong>Authorization Code:</strong> Web apps con backend (mÃ¡s seguro)</li><li><strong>Client Credentials:</strong> MÃ¡quina a mÃ¡quina (microservicios)</li></ul></div><div class='alerta'>âš ï¸ OAuth2 = AUTORIZACIÃ“N (quÃ© puedes hacer), no AUTENTICACIÃ“N (quiÃ©n eres)</div></div>",
      "codigo": "// AUTHORIZATION CODE\n// 1. Redirect\nGET https://auth.banco.com/authorize?response_type=code&client_id=app\n\n// 2. Usuario aprueba, recibe cÃ³digo\n// 3. Backend intercambia cÃ³digo por token\nPOST https://auth.banco.com/token\ngrant_type=authorization_code&code=ABC123&client_secret=SECRET\n\n// 4. Recibe tokens\n{\"access_token\": \"eyJ...\", \"refresh_token\": \"eyJ...\"}\n\n// CLIENT CREDENTIALS (servicio a servicio)\nPOST /token grant_type=client_credentials&client_id=ms-x&client_secret=SECRET",
      "frase": "Auth Code para usuarios. Client Credentials para microservicios."
    },
    {
      "id": 18,
      "categoria": "mensajeria",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es Kafka?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: PeriÃ³dico vs Carta</p><p class='narrador'>Dos formas de comunicarse entre servicios...</p><div class='comparacion'><div class='opcion'><strong>ğŸ“° KAFKA = PeriÃ³dico</strong><p>Se imprime UNA vez, TODOS leen, queda ARCHIVADO.</p><p>Puedes leer el de ayer, de la semana pasada...</p></div><div class='opcion'><strong>ğŸ’Œ RABBITMQ = Carta</strong><p>Se entrega a UNO, confirmas, se destruye.</p></div></div><div class='conceptos'><strong>ğŸ“š CONCEPTOS:</strong><ul><li><strong>Topic:</strong> El periÃ³dico</li><li><strong>Partition:</strong> Secciones para paralelo</li><li><strong>Producer:</strong> Publica</li><li><strong>Consumer:</strong> Lee</li><li><strong>Offset:</strong> PÃ¡gina donde te quedaste</li></ul></div></div>",
      "codigo": "// PRODUCER\n@Service\npublic class EventPublisher {\n    @Autowired KafkaTemplate<String, Object> kafka;\n    \n    public void publicar(TransferenciaEvent e) {\n        kafka.send(\"transferencias\", e.getCuentaId(), e);\n    }\n}\n\n// CONSUMER\n@KafkaListener(topics = \"transferencias\", groupId = \"notif\")\npublic void procesar(TransferenciaEvent e) {\n    log.info(\"Recibido: {}\", e);\n}",
      "frase": "Kafka=periÃ³dico (todos leen, archivado). RabbitMQ=carta (uno recibe)."
    },
    {
      "id": 19,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es DDD?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Departamentos del Banco</p><p class='narrador'>Cada departamento tiene su idioma y territorio...</p><div class='concepto'><strong>ğŸ›ï¸ DDD = CÃ³digo como el Negocio</strong><p>\"El cÃ³digo debe hablar el idioma del negocio\"</p></div><div class='bloques'><strong>ğŸ§± BLOQUES:</strong><ul><li><strong>Bounded Context:</strong> Departamento. Cuentas â‰  PrÃ©stamos.</li><li><strong>Aggregate:</strong> Grupo que se modifica junto. Cuenta + Movimientos.</li><li><strong>Domain Event:</strong> NotificaciÃ³n. \"TransferenciaRealizada\"</li><li><strong>Anti-Corruption Layer:</strong> Traductor con sistemas legacy.</li></ul></div></div>",
      "codigo": "// AGGREGATE ROOT\n@AggregateRoot\npublic class Cuenta {\n    private CuentaId id;\n    private Saldo saldo;\n    private List<Movimiento> movimientos;\n    \n    public DomainEvent debitar(Monto monto) {\n        if (saldo.menorQue(monto)) throw new SaldoInsuficienteException();\n        saldo = saldo.restar(monto);\n        return new CuentaDebitada(id, monto, Instant.now());\n    }\n}\n\n// DOMAIN EVENT\npublic record CuentaDebitada(CuentaId id, Monto monto, Instant cuando) {}",
      "frase": "DDD: cÃ³digo que habla el idioma del negocio."
    },
    {
      "id": 20,
      "categoria": "liderazgo",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es Conventional Commits?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Caos de Commits</p><p class='narrador'>Los commits eran un desastre...</p><div class='caos'><strong>ğŸ˜± CAOS:</strong><pre>\"arreglÃ© algo\" / \"WIP\" / \"asdf\" / \"cambios\"</pre></div><div class='heroe'><strong>âœ¨ CONVENTIONAL COMMITS</strong><p>Formato: <code>tipo(alcance): descripciÃ³n</code></p></div><div class='tipos'><strong>ğŸ·ï¸ TIPOS:</strong><ul><li><strong>feat:</strong> Nueva funcionalidad</li><li><strong>fix:</strong> Bug fix</li><li><strong>docs:</strong> DocumentaciÃ³n</li><li><strong>refactor:</strong> RefactorizaciÃ³n</li><li><strong>test:</strong> Tests</li><li><strong>chore:</strong> Mantenimiento</li></ul></div></div>",
      "codigo": "# âœ… BUENOS\ngit commit -m \"feat(auth): agregar login con Google\"\ngit commit -m \"fix(transfer): corregir cÃ¡lculo comisiÃ³n\"\ngit commit -m \"docs(readme): actualizar instalaciÃ³n\"\ngit commit -m \"refactor(cuenta): extraer validaciones\"\ngit commit -m \"test(transfer): tests transferencias fallidas\"\n\n# BREAKING CHANGE\ngit commit -m \"feat(api)!: cambiar estructura respuesta\"\n\n# âŒ MALOS\ngit commit -m \"fix\" / \"cambios\" / \"WIP\"",
      "frase": "feat=feature, fix=bug, docs=docs. AsÃ­ de simple."
    },
    {
      "id": 21,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es GitHub Actions?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La FÃ¡brica Automatizada</p><p class='narrador'>Antes todo era manual. Ahora hay robots...</p><div class='antes'><strong>ğŸ˜° ANTES:</strong><p>Push â†’ Â¿Alguien corre tests? â†’ Â¿Alguien hace build? â†’ Â¿Alguien despliega?</p></div><div class='despues'><strong>ğŸ¤– DESPUÃ‰S:</strong><p>Push â†’ ROBOT tests â†’ ROBOT build â†’ ROBOT quality â†’ ROBOT deploy</p><p>\"Imposible desplegar cÃ³digo roto\"</p></div></div>",
      "codigo": "# .github/workflows/ci.yml\nname: CI/CD\non:\n  push:\n    branches: [main]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-java@v4\n        with:\n          distribution: 'temurin'\n          java-version: '17'\n      - run: ./gradlew test\n      - run: ./gradlew build\n  \n  deploy:\n    needs: build\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - run: echo \"Desplegando...\"",
      "frase": "Push â†’ Tests â†’ Build â†’ Deploy. Todo automÃ¡tico."
    },
    {
      "id": 22,
      "categoria": "cloud",
      "dificultad": "senior",
      "pregunta": "Docker en 5 comandos",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Tupperware de CÃ³digo</p><p class='narrador'>Empacas tu app para que funcione igual en todos lados...</p><div class='concepto'><strong>ğŸ“¦ DOCKER = Tupperware</strong><p>Empacas app + todo lo que necesita. Funciona IGUAL en cualquier servidor.</p></div><div class='comandos'><strong>ğŸ”§ LOS 5:</strong><ol><li><code>docker build -t app:v1 .</code> â†’ Construir</li><li><code>docker run -d -p 8080:8080 app</code> â†’ Ejecutar</li><li><code>docker ps</code> â†’ Ver corriendo</li><li><code>docker logs -f container</code> â†’ Ver logs</li><li><code>docker exec -it container sh</code> â†’ Entrar</li></ol></div></div>",
      "codigo": "# DOCKERFILE\nFROM eclipse-temurin:17-jre-alpine\nCOPY target/*.jar app.jar\nCMD [\"java\", \"-jar\", \"app.jar\"]\n\n# COMANDOS\ndocker build -t app:v1 .\ndocker run -d -p 8080:8080 app:v1\ndocker ps\ndocker logs -f mi-container\ndocker exec -it mi-container sh\n\n# COMPOSE\ndocker-compose up -d",
      "frase": "build, run, ps, logs, exec. Con esos 5 sobrevives."
    },
    {
      "id": 23,
      "categoria": "cloud",
      "dificultad": "lead",
      "pregunta": "Kubernetes en 6 comandos",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Incidente 3am</p><p class='narrador'>ProducciÃ³n caÃ­do. Solo tienes kubectl y cafÃ©...</p><div class='comandos'><strong>ğŸ†˜ LOS 6 QUE TE SALVAN:</strong><ol><li><code>kubectl get pods</code> â†’ Â¿QuÃ© hay?</li><li><code>kubectl describe pod X</code> â†’ Â¿Por quÃ© fallÃ³?</li><li><code>kubectl logs -f X</code> â†’ Â¿QuÃ© dice?</li><li><code>kubectl exec -it X -- sh</code> â†’ Entrar</li><li><code>kubectl rollout undo deployment/X</code> â†’ Â¡ROLLBACK!</li><li><code>kubectl apply -f X.yaml</code> â†’ Desplegar</li></ol></div><div class='emergencia'><strong>ğŸš¨ EMERGENCIA:</strong><p><code>kubectl rollout undo</code> = tu mejor amigo</p></div></div>",
      "codigo": "kubectl get pods                      # Ver\nkubectl get pods -w                   # Watch\nkubectl describe pod mi-pod           # Detalles\nkubectl logs -f mi-pod                # Logs\nkubectl exec -it mi-pod -- sh         # Entrar\nkubectl rollout undo deployment/app   # ROLLBACK\nkubectl apply -f k8s/                 # Desplegar",
      "frase": "get, describe, logs, exec, rollout, apply. Te salvan a las 3am."
    },
    {
      "id": 24,
      "categoria": "frameworks",
      "dificultad": "senior",
      "pregunta": "Â¿Spring Boot o Quarkus?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Concesionario</p><p class='narrador'>Dos vehÃ­culos compiten...</p><div class='vehiculo'><strong>ğŸš™ SPRING BOOT = Land Cruiser</strong><ul><li>Veterano, todos lo conocen</li><li>DocumentaciÃ³n infinita</li><li>Startup: 2-5s, RAM: 200-500MB</li></ul></div><div class='vehiculo'><strong>ğŸï¸ QUARKUS = Moto Deportiva</strong><ul><li>Joven, naciÃ³ para containers</li><li>Startup: 0.02s (native), RAM: 20MB</li><li>GraalVM nativo desde dÃ­a 1</li></ul></div><div class='decision'><strong>ğŸ¯ DECISIÃ“N:</strong><p>Spring: Equipo grande, ecosistema completo</p><p>Quarkus: Kubernetes, serverless, cada ms cuenta</p></div></div>",
      "codigo": "// SPRING BOOT\n@RestController\npublic class CuentaController {\n    @Autowired CuentaService service;\n    @GetMapping(\"/{id}\")\n    public Cuenta get(@PathVariable String id) { return service.find(id); }\n}\n\n// QUARKUS\n@Path(\"/cuentas\")\npublic class CuentaResource {\n    @Inject CuentaService service;\n    @GET @Path(\"/{id}\")\n    public Cuenta get(@PathParam(\"id\") String id) { return service.find(id); }\n}\n\n# QUARKUS NATIVE\n./mvnw package -Pnative  # 50MB, 0.02s startup",
      "frase": "Spring=todo. Quarkus=velocidad. No hay malo, hay contexto."
    },
    {
      "id": 25,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿Patrones de resiliencia para microservicios?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Los 5 Guardianes</p><p class='narrador'>5 guardianes protegen contra el caos...</p><div class='guardian'><strong>âš¡ CIRCUIT BREAKER</strong><p>Fusible. 5 fallas â†’ Corta circuito.</p></div><div class='guardian'><strong>ğŸ”„ RETRY</strong><p>Reintenta con backoff: 1s, 2s, 4s...</p></div><div class='guardian'><strong>â±ï¸ TIMEOUT</strong><p>5s mÃ¡ximo. Si no responde, siguiente.</p></div><div class='guardian'><strong>ğŸš¢ BULKHEAD</strong><p>Compartimentos. Si uno se inunda, otros siguen.</p></div><div class='guardian'><strong>ğŸ›Ÿ FALLBACK</strong><p>Plan B. Â¿No hay real-time? Muestro cache.</p></div></div>",
      "codigo": "@CircuitBreaker(name = \"pagos\", fallbackMethod = \"fallback\")\n@Retry(name = \"pagos\")\n@TimeLimiter(name = \"pagos\")\n@Bulkhead(name = \"pagos\")\npublic Mono<Response> pagar(Request req) {\n    return webClient.post().bodyValue(req).retrieve().bodyToMono(Response.class);\n}\n\npublic Mono<Response> fallback(Request req, Throwable t) {\n    return Mono.just(Response.pendiente(\"Reintentando...\"));\n}\n\n# Config\nresilience4j.circuitbreaker.instances.pagos:\n  failureRateThreshold: 50\n  waitDurationInOpenState: 30s",
      "frase": "DiseÃ±a para el FALLO. CircuitBreaker+Retry+Timeout+Fallback=sobrevives."
    },
    {
      "id": 26,
      "categoria": "patrones",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© son los principios SOLID?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Las 5 Leyes del CÃ³digo Limpio</p><p class='narrador'>Escritas en piedra por los arquitectos ancestrales...</p><div class='ley'><strong>S - Single Responsibility</strong><p>\"Una clase, UN trabajo. El chef cocina, no lava platos.\"</p></div><div class='ley'><strong>O - Open/Closed</strong><p>\"Abierto a extensiÃ³n, cerrado a modificaciÃ³n. Agrega, no cambies.\"</p></div><div class='ley'><strong>L - Liskov Substitution</strong><p>\"Hijo debe poder reemplazar al padre sin romper nada.\"</p></div><div class='ley'><strong>I - Interface Segregation</strong><p>\"Interfaces pequeÃ±as. No obligues a implementar lo que no usas.\"</p></div><div class='ley'><strong>D - Dependency Inversion</strong><p>\"Depende de abstracciones, no de concretos.\"</p></div></div>",
      "codigo": "// S - Una responsabilidad\n@Service class ValidadorTransferencia { boolean esValida(Transfer t); }\n@Service class EjecutorTransferencia { void ejecutar(Transfer t); }\n\n// O - ExtensiÃ³n sin modificar\ninterface Notificador { void enviar(String msg); }\nclass EmailNotif implements Notificador { /*...*/ }\nclass SmsNotif implements Notificador { /*...*/ }  // Nuevo sin tocar cÃ³digo\n\n// D - Depender de abstracciÃ³n\npublic TransferenciaService(NotificadorPort notif) {} // Interface, no impl",
      "frase": "S=un trabajo. O=extiende. L=reemplazable. I=pequeÃ±o. D=abstracto."
    },
    {
      "id": 27,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "Â¿CÃ³mo funciona la memoria en Java?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Condominio y el Escritorio</p><p class='narrador'>Tu programa tiene dos espacios de trabajo...</p><div class='espacio'><strong>ğŸ“š STACK = Tu Escritorio</strong><p>PequeÃ±o, rÃ¡pido, ordenado.</p><ul><li>Variables locales, parÃ¡metros</li><li>Referencias (punteros a objetos)</li><li>Cada hilo tiene el suyo</li><li>Se limpia solo al salir del mÃ©todo</li></ul></div><div class='espacio'><strong>ğŸ¢ HEAP = El Condominio</strong><p>Grande, compartido, necesita limpieza.</p><ul><li>Objetos (new Cuenta())</li><li>Compartido entre hilos</li><li>El GC limpia los departamentos vacÃ­os</li></ul></div></div>",
      "codigo": "public void transferir(Cuenta origen, BigDecimal monto) {\n    // STACK: origen (referencia), monto (referencia)\n    // HEAP: donde viven los objetos Cuenta y BigDecimal\n    \n    String id = UUID.randomUUID().toString();  // STACK: id (ref)\n                                                // HEAP: String obj\n}  // Fin: Stack se limpia. Heap espera al GC.\n\n// TIPOS MEMORIA\n// Stack: primitivos (int, boolean) + referencias\n// Heap: objetos (new X()), arrays, String pool",
      "frase": "Stack=tu escritorio (rÃ¡pido, privado). Heap=condominio (GC limpia)."
    },
    {
      "id": 28,
      "categoria": "fundamentos",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© hace el Garbage Collector?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El SeÃ±or de la Limpieza</p><p class='narrador'>En el condominio Heap, alguien limpia los departamentos abandonados...</p><div class='personaje'><strong>ğŸ§¹ GC = SeÃ±or Limpieza</strong><p>\"Â¿Nadie te referencia? Â¡Fuera!\"</p></div><div class='generaciones'><strong>ğŸ  GENERACIONES:</strong><ul><li><strong>Young Gen:</strong> Objetos nuevos. GC frecuente (Minor GC)</li><li><strong>Old Gen:</strong> Sobrevivientes. GC raro pero pesado (Major GC)</li><li><strong>Metaspace:</strong> Clases, metadata</li></ul></div><div class='tipos'><strong>ğŸ”§ TIPOS:</strong><ul><li><strong>G1GC:</strong> Default Java 11+. Balance.</li><li><strong>ZGC:</strong> Pausas < 1ms. Heaps enormes.</li><li><strong>Shenandoah:</strong> Similar a ZGC.</li></ul></div></div>",
      "codigo": "// MONITOREAR\njava -Xlog:gc* -jar app.jar\njvisualvm / JConsole\n\n// CONFIGURAR\njava -Xms512m -Xmx2g -XX:+UseG1GC app.jar\n\n// G1GC (default Java 11+)\n-XX:+UseG1GC\n\n// ZGC (pausas < 1ms, Java 15+)\n-XX:+UseZGC\n\n// FORZAR (NUNCA EN PROD)\nSystem.gc();  // Solo sugiere, no garantiza",
      "frase": "G1GC=balance. ZGC=low latency. El GC es tu amigo, no tu enemigo."
    },
    {
      "id": 29,
      "categoria": "mensajeria",
      "dificultad": "senior",
      "pregunta": "Â¿Kafka vs RabbitMQ?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: PeriÃ³dico vs Cartero</p><p class='narrador'>Dos filosofÃ­as de entregar mensajes...</p><div class='versus'><div class='opcion'><strong>ğŸ“° KAFKA</strong><ul><li>PeriÃ³dico: TODOS leen, queda guardado</li><li>Replay: puedes leer mensajes viejos</li><li>Throughput: millones/seg</li><li>Usa cuando: eventos, analytics, logs</li></ul></div><div class='opcion'><strong>ğŸ° RABBITMQ</strong><ul><li>Cartero: entrega a UNO, confirma, destruye</li><li>Routing: flexible, exchanges</li><li>Acknowledge: garantiza procesamiento</li><li>Usa cuando: tareas, workflows, RPC</li></ul></div></div><div class='decision'><strong>ğŸ¯ REGLA:</strong> Eventos/stream = Kafka. Tareas/comandos = RabbitMQ.</div></div>",
      "codigo": "// KAFKA - Eventos\n@KafkaListener(topics = \"transferencias\")\npublic void onTransfer(TransferenciaEvent e) {\n    // MÃºltiples consumers pueden leer el MISMO evento\n}\n\n// RABBITMQ - Tareas\n@RabbitListener(queues = \"enviar-email\")\npublic void process(EmailTask task) {\n    emailService.send(task);  // Solo UN consumer procesa\n    // ACK automÃ¡tico al terminar\n}",
      "frase": "Kafka=eventos (todos leen). RabbitMQ=tareas (uno procesa)."
    },
    {
      "id": 30,
      "categoria": "frameworks",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© son los scopes de Spring?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Vida de los Beans</p><p class='narrador'>Cada bean tiene su ciclo de vida...</p><div class='scope'><strong>ğŸŒ SINGLETON (default)</strong><p>\"Nace UNO, todos comparten ese mismo.\"</p><p>Usa: Services, Repositories (stateless)</p></div><div class='scope'><strong>ğŸ”„ PROTOTYPE</strong><p>\"Cada vez que pides, nace uno nuevo.\"</p><p>Usa: Builders, objetos con estado</p></div><div class='scope'><strong>ğŸŒ REQUEST</strong><p>\"Vive durante UN request HTTP.\"</p></div><div class='scope'><strong>ğŸ“‹ SESSION</strong><p>\"Vive durante la sesiÃ³n del usuario.\"</p></div><div class='alerta'>âš ï¸ Singleton + estado mutable = BUG de concurrencia</div></div>",
      "codigo": "// SINGLETON (default) - Compartido\n@Service\npublic class CuentaService { }  // UNA instancia\n\n// PROTOTYPE - Nueva cada vez\n@Scope(\"prototype\")\n@Component\npublic class ReporteBuilder { }  // NUEVA cada inyecciÃ³n\n\n// REQUEST - Por peticiÃ³n HTTP\n@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)\n@Component\npublic class RequestContext { }",
      "frase": "Singleton=compartido. Prototype=nuevo. Request=por peticiÃ³n."
    },
    {
      "id": 31,
      "categoria": "frameworks",
      "dificultad": "senior",
      "pregunta": "Â¿CÃ³mo manejar transacciones en Spring?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Todo o Nada</p><p class='narrador'>Una transferencia tiene DOS operaciones...</p><div class='problema'><strong>âŒ SIN TRANSACCIÃ“N:</strong><p>DÃ©bito âœ… â†’ Error â†’ CrÃ©dito âŒ</p><p>Â¡Dinero desapareciÃ³!</p></div><div class='solucion'><strong>âœ… CON TRANSACCIÃ“N:</strong><p>DÃ©bito â†’ Error â†’ ROLLBACK â†’ Todo vuelve atrÃ¡s</p></div><div class='propagacion'><strong>ğŸ“‹ PROPAGACIÃ“N:</strong><ul><li><strong>REQUIRED:</strong> Usa existente o crea nueva</li><li><strong>REQUIRES_NEW:</strong> SIEMPRE nueva (independiente)</li><li><strong>MANDATORY:</strong> DEBE existir una</li></ul></div></div>",
      "codigo": "@Service\npublic class TransferenciaService {\n    \n    @Transactional  // Todo o nada\n    public void transferir(String origen, String destino, BigDecimal monto) {\n        cuentaRepo.debitar(origen, monto);   // Si esto falla...\n        cuentaRepo.acreditar(destino, monto); // ...esto NO se ejecuta\n    }                                         // O ambos, o ninguno\n    \n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void auditarSiempre(String msg) {\n        // TransacciÃ³n INDEPENDIENTE\n        // Se guarda aunque la principal falle\n    }\n}",
      "frase": "@Transactional = todo o nada. REQUIRES_NEW = independiente."
    },
    {
      "id": 32,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es Event Sourcing?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Diario Contable</p><p class='narrador'>En lugar de guardar \"saldo actual\", guardas CADA movimiento...</p><div class='comparacion'><div class='opcion'><strong>ğŸ“Š TRADICIONAL (Estado)</strong><p>Guardas: saldo = $500</p><p>Â¿CÃ³mo llegÃ³ ahÃ­? ğŸ¤·</p></div><div class='opcion'><strong>ğŸ“œ EVENT SOURCING</strong><p>Guardas: CuentaCreada, Depositado($1000), Debitado($500)</p><p>Reconstruyes estado desde eventos</p></div></div><div class='beneficios'><strong>âœ¨ BENEFICIOS:</strong><ul><li>AuditorÃ­a completa</li><li>Time travel: estado en cualquier momento</li><li>Replay: reconstruir si hay bug</li></ul></div></div>",
      "codigo": "// EVENTOS\npublic record CuentaCreada(String id, Instant cuando) {}\npublic record Depositado(String cuentaId, BigDecimal monto, Instant cuando) {}\npublic record Debitado(String cuentaId, BigDecimal monto, Instant cuando) {}\n\n// RECONSTRUIR ESTADO\npublic Cuenta reconstruir(String cuentaId) {\n    List<DomainEvent> eventos = eventStore.getEvents(cuentaId);\n    Cuenta cuenta = new Cuenta();\n    for (DomainEvent e : eventos) {\n        cuenta.apply(e);  // Aplica cada evento\n    }\n    return cuenta;\n}",
      "frase": "No guardes estado, guarda historia. Siempre puedes reconstruir."
    },
    {
      "id": 33,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es CQRS?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: SeparaciÃ³n de Poderes</p><p class='narrador'>Leer y escribir son trabajos muy diferentes...</p><div class='concepto'><strong>âš”ï¸ CQRS = Command Query Responsibility Segregation</strong><p>\"Separar ESCRITURA de LECTURA\"</p></div><div class='separacion'><div class='lado'><strong>âœï¸ COMMAND (Escribir)</strong><p>CrearCuenta, Transferir</p><p>BD normalizada, validaciones</p></div><div class='lado'><strong>ğŸ‘ï¸ QUERY (Leer)</strong><p>GetCuenta, ListarMovimientos</p><p>BD desnormalizada, optimizada</p></div></div><div class='combo'><strong>ğŸ”¥ COMBO:</strong> CQRS + Event Sourcing = Poder mÃ¡ximo</div></div>",
      "codigo": "// COMMAND - Escribir\n@Service\npublic class CuentaCommandService {\n    public void crear(CrearCuentaCommand cmd) {\n        // Validaciones, reglas de negocio\n        // Guarda en BD de escritura\n    }\n}\n\n// QUERY - Leer (BD optimizada para lectura)\n@Service\npublic class CuentaQueryService {\n    public CuentaView getCuenta(String id) {\n        return cuentaReadRepo.findById(id);  // Vista desnormalizada\n    }\n}\n\n// SINCRONIZACIÃ“N vÃ­a eventos\n@EventHandler\npublic void on(CuentaCreada e) {\n    readRepo.save(new CuentaView(e));  // Actualiza vista\n}",
      "frase": "Escribe en BD normalizada. Lee de vista optimizada. Sincroniza con eventos."
    },
    {
      "id": 34,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es el patrÃ³n Saga?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Cadena de Pagos</p><p class='narrador'>Comprar un vuelo requiere: Reserva â†’ Pago â†’ Asiento â†’ Equipaje...</p><div class='problema'><strong>âŒ PROBLEMA:</strong><p>Pago OK â†’ Asiento FALLA</p><p>Â¿CÃ³mo deshaces el pago en OTRO servicio?</p></div><div class='solucion'><strong>âœ… SAGA:</strong><p>TransacciÃ³n distribuida con COMPENSACIONES</p><ul><li>Cada paso tiene su \"deshacer\"</li><li>Si falla paso 3, ejecuta deshacer 2, deshacer 1</li></ul></div><div class='tipos'><strong>ğŸ“‹ TIPOS:</strong><ul><li><strong>CoreografÃ­a:</strong> Eventos. Cada servicio escucha y reacciona.</li><li><strong>OrquestaciÃ³n:</strong> Un coordinador central dirige.</li></ul></div></div>",
      "codigo": "// SAGA ORQUESTADA\n@Service\npublic class ReservaSagaOrquestador {\n    \n    public void ejecutar(ReservaRequest req) {\n        try {\n            String pagoId = pagoService.cobrar(req);    // Paso 1\n            String asientoId = asientoService.reservar(req);  // Paso 2 FALLA\n        } catch (Exception e) {\n            // COMPENSACIONES\n            pagoService.reembolsar(pagoId);  // Deshacer paso 1\n            throw new SagaFallidaException(e);\n        }\n    }\n}\n\n// SAGA COREOGRAFIADA (eventos)\n// PagoRealizado â†’ AsientoService escucha â†’ AsientoReservado â†’ ...\n// AsientoFallido â†’ PagoService escucha â†’ Reembolsa",
      "frase": "Saga: cada paso tiene su deshacer. Falla = rollback distribuido."
    },
    {
      "id": 35,
      "categoria": "fundamentos",
      "dificultad": "junior",
      "pregunta": "Â¿QuÃ© es un Optional?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Paquete de SchrÃ¶dinger</p><p class='narrador'>Antes de Java 8, null era el terror...</p><div class='antes'><strong>ğŸ˜± ANTES:</strong><p><code>Cuenta c = repo.find(id); // Â¿null?</code></p><p>NullPointerException a las 3am</p></div><div class='despues'><strong>ğŸ“¦ OPTIONAL:</strong><p>\"Caja que PUEDE tener algo o estar vacÃ­a\"</p><p>Te OBLIGA a pensar en el caso vacÃ­o</p></div><div class='metodos'><strong>ğŸ”§ MÃ‰TODOS:</strong><ul><li><code>isPresent()</code> - Â¿Hay algo?</li><li><code>orElse(default)</code> - Si vacÃ­o, usa esto</li><li><code>orElseThrow()</code> - Si vacÃ­o, explota</li><li><code>map()</code> - Transforma si existe</li></ul></div></div>",
      "codigo": "// CREAR\nOptional<Cuenta> cuenta = repo.findById(id);  // Puede estar vacÃ­o\n\n// USAR\nString nombre = cuenta\n    .map(Cuenta::getTitular)\n    .orElse(\"Desconocido\");\n\n// LANZAR SI NO EXISTE\nCuenta c = cuenta.orElseThrow(() -> \n    new CuentaNotFoundException(id));\n\n// âŒ NO HAGAS\nif (optional.isPresent()) { optional.get(); }  // Anti-pattern\n\n// âœ… HAZ\noptional.ifPresent(c -> procesar(c));\noptional.map(this::procesar).orElse(default);",
      "frase": "Optional te OBLIGA a pensar en null. Usa map/orElse, no get()."
    },
    {
      "id": 36,
      "categoria": "seguridad",
      "dificultad": "senior",
      "pregunta": "Â¿CÃ³mo proteger endpoints con Spring Security?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Los Filtros del Club</p><p class='narrador'>Para entrar al club hay CAPAS de seguridad...</p><div class='capas'><strong>ğŸ” SECURITY FILTER CHAIN:</strong><ol><li>Â¿Tiene token? (Authentication)</li><li>Â¿Token vÃ¡lido? (JWT Validation)</li><li>Â¿Tiene permiso? (Authorization)</li></ol></div><div class='anotaciones'><strong>ğŸ·ï¸ ANOTACIONES:</strong><ul><li><code>@PreAuthorize(\"hasRole('ADMIN')\")</code></li><li><code>@Secured(\"ROLE_USER\")</code></li><li><code>permitAll()</code> / <code>authenticated()</code></li></ul></div></div>",
      "codigo": "@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        return http\n            .csrf(csrf -> csrf.disable())\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/public/**\").permitAll()\n                .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt())\n            .build();\n    }\n}\n\n// EN CONTROLLER\n@PreAuthorize(\"hasRole('ADMIN')\")\n@GetMapping(\"/admin/usuarios\")\npublic List<Usuario> listar() { }",
      "frase": "SecurityFilterChain configura. @PreAuthorize protege mÃ©todo."
    },
    {
      "id": 37,
      "categoria": "liderazgo",
      "dificultad": "senior",
      "pregunta": "Â¿CÃ³mo haces code review efectivo?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Sensei del PR</p><p class='narrador'>Code review no es buscar errores, es mejorar juntos...</p><div class='principios'><strong>ğŸ¯ PRINCIPIOS:</strong><ul><li><strong>Critica cÃ³digo, no personas</strong></li><li><strong>Pregunta, no ordenes:</strong> \"Â¿Consideraste X?\" vs \"Hazlo asÃ­\"</li><li><strong>Explica el POR QUÃ‰</strong></li><li><strong>Ofrece alternativas</strong></li></ul></div><div class='checklist'><strong>âœ… REVISA:</strong><ol><li>Â¿Resuelve el problema?</li><li>Â¿Es mantenible?</li><li>Â¿Tiene tests?</li><li>Â¿Sigue convenciones?</li><li>Â¿Hay edge cases?</li></ol></div><div class='regla'><strong>â±ï¸ REGLA:</strong> PR grande = review malo. MÃ¡ximo 400 lÃ­neas.</div></div>",
      "codigo": "// âŒ COMENTARIO MALO\n\"Esto estÃ¡ mal\"\n\"No me gusta\"\n\"CÃ¡mbialo\"\n\n// âœ… COMENTARIO BUENO\n\"Â¿QuÃ© pasa si monto es negativo? PodrÃ­amos validar:\nif (monto.compareTo(ZERO) <= 0) throw new IllegalArgumentException();\"\n\n// LABELS\n[nit] - Sugerencia menor, no bloquea\n[question] - Pregunta, no bloquea\n[suggestion] - Mejora opcional\n[must-fix] - Debe cambiarse",
      "frase": "Pregunta en vez de ordenar. Explica el por quÃ©. PRs pequeÃ±os."
    },
    {
      "id": 38,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Â¿CÃ³mo estimas tareas de desarrollo?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La MaldiciÃ³n del Estimado</p><p class='narrador'>\"Â¿CuÃ¡nto demora?\" - La pregunta que destruye careers...</p><div class='problema'><strong>ğŸ˜± PROBLEMA:</strong><p>Todo siempre tarda 3x mÃ¡s de lo estimado.</p></div><div class='tecnicas'><strong>ğŸ”§ TÃ‰CNICAS:</strong><ul><li><strong>T-shirt sizing:</strong> S, M, L, XL - Relativo, no absoluto</li><li><strong>Planning Poker:</strong> Equipo vota, discute diferencias</li><li><strong>Dividir:</strong> Si > 8 puntos, es Ã©pica, divÃ­dela</li><li><strong>Buffer:</strong> Multiplica x1.5 para imprevistos</li></ul></div><div class='sabiduria'><strong>ğŸ§™ SABIDURÃA:</strong><p>\"Estima en COMPLEJIDAD, no en tiempo. El tiempo depende de mil factores.\"</p></div></div>",
      "codigo": "// T-SHIRT SIZING\nS = 1-2 puntos (horas)\nM = 3-5 puntos (1 dÃ­a)\nL = 8-13 puntos (2-3 dÃ­as)\nXL = 21+ puntos (DIVIDIR)\n\n// FÃ“RMULA REALISTA\nTiempo = (Optimista + 4*Probable + Pesimista) / 6\n\n// Ejemplo:\nOptimista: 2 dÃ­as\nProbable: 4 dÃ­as  \nPesimista: 10 dÃ­as\nEstimado = (2 + 16 + 10) / 6 = 4.6 dÃ­as\n\n// CON BUFFER: 4.6 * 1.5 = 7 dÃ­as",
      "frase": "Estima complejidad, no tiempo. Divide lo grande. Buffer x1.5."
    },
    {
      "id": 39,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Â¿CÃ³mo manejas deuda tÃ©cnica?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Hipoteca del CÃ³digo</p><p class='narrador'>Deuda tÃ©cnica es como hipoteca: Ãºtil al inicio, mortal si no pagas...</p><div class='tipos'><strong>ğŸ¦ TIPOS:</strong><ul><li><strong>Deliberada:</strong> \"Sabemos que es feo pero hay deadline\"</li><li><strong>Accidental:</strong> \"No sabÃ­amos mejor\"</li><li><strong>Bit rot:</strong> CÃ³digo que envejece</li></ul></div><div class='estrategia'><strong>ğŸ“‹ ESTRATEGIA:</strong><ul><li><strong>Visibilizar:</strong> TODO con ticket, no comentarios perdidos</li><li><strong>Negociar:</strong> 20% del sprint para pagar deuda</li><li><strong>Boy Scout Rule:</strong> Deja mejor de como encontraste</li><li><strong>Priorizar:</strong> Deuda en cÃ³digo caliente primero</li></ul></div></div>",
      "codigo": "// âŒ MAL - Comentario perdido\n// TODO: refactorizar esto algÃºn dÃ­a\n\n// âœ… BIEN - Con ticket\n// TODO [JIRA-1234]: Extraer validaciones a ValidadorService\n// Contexto: Deadline Q1, priorizar refactor en Q2\n\n// MÃ‰TRICAS\n- Code coverage < 60% = deuda\n- DuplicaciÃ³n > 5% = deuda\n- Complejidad ciclomÃ¡tica > 10 = deuda\n- Dependencias desactualizadas = deuda\n\n// NEGOCIAR CON PRODUCTO\n\"Cada sprint: 80% features, 20% deuda tÃ©cnica\"\n\"Sin esto, velocidad cae 10% cada mes\"",
      "frase": "Visibiliza deuda con tickets. Negocia 20% del sprint. Boy Scout Rule."
    },
    {
      "id": 40,
      "categoria": "funcional",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es flatMap y cuÃ¡ndo usarlo?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Aplanador</p><p class='narrador'>map devuelve caja dentro de caja. flatMap las aplana...</p><div class='problema'><strong>ğŸ“¦ğŸ“¦ PROBLEMA con map:</strong><p><code>Optional&lt;Optional&lt;Cuenta&gt;&gt;</code></p><p>Â¡Caja dentro de caja!</p></div><div class='solucion'><strong>ğŸ“¦ flatMap:</strong><p>Aplana: una sola caja</p><p>Usa cuando tu funciÃ³n YA devuelve Optional/Stream/Mono</p></div><div class='regla'><strong>ğŸ¯ REGLA:</strong><p><code>map</code>: T â†’ R</p><p><code>flatMap</code>: T â†’ Optional&lt;R&gt; / Stream&lt;R&gt; / Mono&lt;R&gt;</p></div></div>",
      "codigo": "// MAP - FunciÃ³n simple\nOptional<String> nombre = cuenta.map(Cuenta::getNombre);\n// T -> R\n\n// FLATMAP - FunciÃ³n que ya devuelve Optional\nOptional<Cuenta> cuenta = usuario\n    .flatMap(u -> repo.findCuentaPrincipal(u.getId()));\n// T -> Optional<R> ... aplanado a Optional<R>\n\n// EN STREAMS - Aplanar listas\nList<Movimiento> todos = cuentas.stream()\n    .flatMap(c -> c.getMovimientos().stream())  // Stream<Stream> â†’ Stream\n    .collect(toList());\n\n// EN REACTIVO\nMono<Saldo> saldo = cuentaMono\n    .flatMap(c -> saldoService.calcular(c.getId()));  // Mono<Mono> â†’ Mono",
      "frase": "map=transforma. flatMap=transforma Y aplana. Usa con funciones que ya envuelven."
    }
  ]
}
