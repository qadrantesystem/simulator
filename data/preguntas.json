{
  "metadata": {
    "version": "2.0",
    "estilo": "PÃ­ldoras Narrativas - Tech Lead Edition",
    "autor": "WorldReactive",
    "totalPreguntas": 50,
    "categorias": ["fundamentos", "paradigmas", "java-evolution", "funcional", "reactivo", "frameworks", "seguridad", "mensajeria", "cloud", "patrones", "liderazgo"]
  },
  "preguntas": [
    {
      "id": 1,
      "categoria": "fundamentos",
      "dificultad": "junior",
      "pregunta": "Â¿QuÃ© son JVM, JRE y JDK?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Cocina de JavaLandia</p><p class='narrador'>En el reino de JavaLandia existe una cocina legendaria...</p><div class='personaje'><strong>ğŸ‘¨â€ğŸ³ JVM = EL COCINERO</strong><p>Lee tu receta (bytecode) y prepara el plato. No le importa si viene de Windows o Mac, Ã©l cocina igual.</p></div><div class='personaje'><strong>ğŸ½ï¸ JRE = EL RESTAURANTE</strong><p>Cocina equipada: cocinero + ollas + platos. Solo puedes COMER (ejecutar), no crear recetas.</p></div><div class='personaje'><strong>ğŸ­ JDK = LA ESCUELA DE CHEFS</strong><p>Instituto completo: restaurante + aulas + cuchillos pro (compilador). AquÃ­ CREAS recetas.</p></div></div>",
      "codigo": "# Â¿QuÃ© tienes?\njava -version   # JRE (ejecutar)\njavac -version  # JDK (compilar)\n\n# Flujo:\n# MiApp.java â†’ javac â†’ MiApp.class â†’ java â†’ Ejecuta",
      "frase": "Usuario = JRE. Developer = JDK. Ambos llevan JVM."
    },
    {
      "id": 2,
      "categoria": "java-evolution",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© trajo Java 8 que cambiÃ³ todo?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La RevoluciÃ³n de 2014</p><p class='narrador'>Era un tiempo oscuro. Los developers escribÃ­an 50 lÃ­neas para filtrar una lista...</p><div class='heroe'><strong>âš¡ JAVA 8 - EL REVOLUCIONARIO</strong><p>LlegÃ³ con poderes nunca vistos:</p><ul><li><strong>LAMBDAS:</strong> Funciones en 1 lÃ­nea â†’ <code>(x) -> x * 2</code></li><li><strong>STREAMS:</strong> Datos que fluyen, se filtran, se transforman</li><li><strong>OPTIONAL:</strong> AdiÃ³s NullPointerException</li><li><strong>INTERFACES FUNCIONALES:</strong> Predicate, Consumer, Function, Supplier</li></ul></div></div>",
      "codigo": "// ANTES - Sufrimiento\nList<String> filtrados = new ArrayList<>();\nfor (Cuenta c : cuentas) {\n    if (c.getSaldo() > 1000) filtrados.add(c.getTitular());\n}\n\n// JAVA 8 - IluminaciÃ³n âœ¨\nList<String> filtrados = cuentas.stream()\n    .filter(c -> c.getSaldo() > 1000)\n    .map(Cuenta::getTitular)\n    .collect(Collectors.toList());",
      "frase": "Java 8 no fue versiÃ³n, fue REVOLUCIÃ“N."
    },
    {
      "id": 3,
      "categoria": "java-evolution",
      "dificultad": "senior",
      "pregunta": "Â¿Por quÃ© Java 11 es LTS?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Toyota Corolla</p><p class='narrador'>En el concesionario, los arquitectos buscaban confiabilidad...</p><div class='personaje'><strong>ğŸš— JAVA 11 LTS</strong><p>No es sexy pero es LTS = soporte por AÃ‘OS.</p><p><em>\"Las empresas serias quieren Corolla, no Tesla beta\"</em></p><ul><li><strong>var en lambdas</strong></li><li><strong>String:</strong> isBlank(), strip(), repeat()</li><li><strong>HttpClient moderno</strong></li><li><strong>Ejecutar directo:</strong> java MiApp.java</li></ul></div><div class='alerta'><strong>LTS:</strong> 8, 11, 17, 21 - Las Ãºnicas con soporte largo.</div></div>",
      "codigo": "// Java 11 goodies\n\"  \".isBlank();        // true\n\"ja\".repeat(3);        // \"jajaja\"\n\"  hola  \".strip();    // \"hola\"\n\n// HttpClient moderno\nvar client = HttpClient.newHttpClient();\nvar response = client.send(request, BodyHandlers.ofString());",
      "frase": "Java 11 LTS: el Corolla. Estable, soporte largo, cero drama."
    },
    {
      "id": 4,
      "categoria": "java-evolution",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© tiene Java 17 que todos quieren?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Mago del Boilerplate</p><p class='narrador'>Los developers estaban hartos de escribir 50 lÃ­neas para un DTO...</p><div class='heroe'><strong>âœ¨ JAVA 17</strong><p><em>\"Â¿50 lÃ­neas para getters? Observa esto...\"</em></p><ul><li><strong>RECORDS:</strong> DTOs en 1 lÃ­nea</li><li><strong>PATTERN MATCHING:</strong> Cast automÃ¡tico</li><li><strong>SEALED CLASSES:</strong> Controlas quiÃ©n hereda</li><li><strong>TEXT BLOCKS:</strong> Strings multilÃ­nea</li></ul></div><div class='alerta'>âš ï¸ Spring Boot 3+ REQUIERE Java 17</div></div>",
      "codigo": "// RECORD - 1 lÃ­nea = constructor + getters + equals + hashCode + toString\npublic record CuentaDTO(String id, BigDecimal saldo) {}\n\n// PATTERN MATCHING\nif (obj instanceof Cuenta c) {  // Cast automÃ¡tico!\n    return c.getSaldo();\n}\n\n// TEXT BLOCKS\nString json = \"\"\"\n    {\"nombre\": \"Juan\", \"saldo\": 1500}\n    \"\"\";",
      "frase": "Records + Pattern Matching = 40% menos cÃ³digo."
    },
    {
      "id": 5,
      "categoria": "java-evolution",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© son Virtual Threads en Java 21?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Batalla de los Hilos</p><p class='narrador'>Lord Caos lanzÃ³ un millÃ³n de requests. Los Platform Threads caÃ­an...</p><div class='villano'><strong>ğŸ˜µ PLATFORM THREADS</strong><p>Cada hilo = 1MB memoria. 10,000 hilos = servidor muerto.</p></div><div class='heroe'><strong>âš¡ VIRTUAL THREADS (Java 21)</strong><p>Hilos manejados por JVM. Crea MILLONES sin sudar.</p><p><em>\"CÃ³digo bloqueante simple con performance de reactivo\"</em></p></div><div class='revelacion'><strong>ğŸ¯ Â¿AdiÃ³s WebFlux?</strong><p>Para muchos casos, sÃ­. Virtual Threads simplifica todo.</p></div></div>",
      "codigo": "// ANTES - MÃ¡ximo ~10,000 hilos\nExecutors.newFixedThreadPool(100);\n\n// JAVA 21 - Millones, cero drama\nExecutors.newVirtualThreadPerTaskExecutor();\n\n// Simple\nThread.startVirtualThread(() -> {\n    var saldo = httpClient.send(request);  // Bloquea SIN PROBLEMA\n    database.save(saldo);                   // Bloquea SIN PROBLEMA\n});",
      "frase": "Virtual Threads: cÃ³digo simple, performance de reactivo."
    },
    {
      "id": 6,
      "categoria": "paradigmas",
      "dificultad": "senior",
      "pregunta": "Â¿CuÃ¡les son los 3 paradigmas y cuÃ¡ndo uso cada uno?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Los 3 Reinos</p><p class='narrador'>En el mundo del cÃ³digo existen 3 reinos...</p><div class='reino'><strong>ğŸ° OOP</strong><p><em>\"Todo es OBJETO con datos y comportamiento\"</em></p><p>Usa cuando: Modelas entidades (Cuenta, Usuario)</p></div><div class='reino'><strong>âš¡ FUNCIONAL</strong><p><em>\"Funciones puras, sin efectos, datos inmutables\"</em></p><p>Usa cuando: Transformas datos (filter, map, reduce)</p></div><div class='reino'><strong>ğŸŒŠ REACTIVO</strong><p><em>\"Reacciona a eventos, nunca bloquees\"</em></p><p>Usa cuando: Alta concurrencia, I/O intensivo</p></div><div class='sabiduria'><strong>ğŸ§™ En Java moderno:</strong> Los 3 conviven. OOP modela, Funcional transforma, Reactivo escala.</div></div>",
      "codigo": "// ğŸ° OOP - Modelar\npublic class Cuenta {\n    private BigDecimal saldo;\n    public void depositar(BigDecimal m) { this.saldo = saldo.add(m); }\n}\n\n// âš¡ FUNCIONAL - Transformar\ncuentas.stream().filter(c -> c.estaActiva()).map(Cuenta::getSaldo).collect(toList());\n\n// ğŸŒŠ REACTIVO - No bloquear\ncuentaRepo.findById(id).map(this::enriquecer).subscribe();",
      "frase": "OOP modela, Funcional transforma, Reactivo escala. Usa los 3."
    },
    {
      "id": 7,
      "categoria": "paradigmas",
      "dificultad": "senior",
      "pregunta": "Â¿CÃ³mo combino POO con Funcional?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Alianza</p><p class='narrador'>Los sabios descubrieron que OOP y Funcional son aliados perfectos...</p><div class='alianza'><strong>ğŸ¤ LA ALIANZA:</strong><p>OOP = ESTRUCTURA (clases, entidades)</p><p>Funcional = COMPORTAMIENTO (quÃ© hacer con datos)</p></div><div class='patron'><strong>ğŸ“ EL PATRÃ“N:</strong><ol><li>Modelas con clases (OOP)</li><li>MÃ©todos usan Streams (Funcional)</li><li>Pasas comportamiento como parÃ¡metro (Lambdas)</li></ol></div></div>",
      "codigo": "// Clase OOP con comportamiento Funcional\n@Service\npublic class CuentaService {\n    // Predicates (Funcional)\n    private final Predicate<Cuenta> estaActiva = c -> \"ACTIVA\".equals(c.getEstado());\n    private final Predicate<Cuenta> tieneSaldo = c -> c.getSaldo().compareTo(ZERO) > 0;\n    \n    // MÃ©todo OOP que usa Funcional\n    public List<CuentaDTO> getCuentasParaYape(List<Cuenta> cuentas) {\n        return cuentas.stream()\n            .filter(estaActiva.and(tieneSaldo))\n            .map(this::toDTO)\n            .collect(toList());\n    }\n}",
      "frase": "OOP estructura, Funcional comporta. Juntos = poder total."
    },
    {
      "id": 8,
      "categoria": "paradigmas",
      "dificultad": "senior",
      "pregunta": "Â¿CuÃ¡les son los 4 pilares de OOP?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Los 4 Guardianes del BCP</p><p class='narrador'>En las bÃ³vedas del BCP, 4 guardianes protegen los secretos...</p><div class='guardian'><strong>ğŸ”’ ENCAPSULAMIENTO</strong><p>El cliente ve ventanilla, no bÃ³veda. Private adentro, public afuera.</p></div><div class='guardian'><strong>ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ HERENCIA</strong><p>CuentaAhorro hereda de Cuenta, pero tiene su propia tasa.</p></div><div class='guardian'><strong>ğŸ­ POLIMORFISMO</strong><p>calcularInteres() existe en todas, pero cada una calcula diferente.</p></div><div class='guardian'><strong>ğŸ¨ ABSTRACCIÃ“N</strong><p>Usas el app sin saber cÃ³mo funciona el core.</p></div></div>",
      "codigo": "// ğŸ”’ ENCAPSULAMIENTO\nprivate BigDecimal saldo;  // Oculto\npublic BigDecimal getSaldo() { return saldo; }  // Controlado\n\n// ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ HERENCIA\npublic class CuentaAhorro extends Cuenta { }\n\n// ğŸ­ POLIMORFISMO\ninterface Notificador { void enviar(String msg); }\nclass EmailNotificador implements Notificador { /*...*/ }\nclass SmsNotificador implements Notificador { /*...*/ }\n\n// ğŸ¨ ABSTRACCIÃ“N\nabstract class Transaccion { abstract void ejecutar(); }",
      "frase": "ENCAPSULAR oculta, HEREDAR comparte, POLIMORFISMO adapta, ABSTRACCIÃ“N simplifica."
    },
    {
      "id": 9,
      "categoria": "funcional",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© son las Interfaces Funcionales?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Los 4 Jinetes del Club</p><p class='narrador'>En una noche de fiesta, 4 personajes controlan el flujo...</p><div class='personaje'><strong>ğŸšª PREDICATE = Portero</strong><p>\"Â¿Cumples? SÃ­ o No\" â†’ <code>boolean test(T)</code></p></div><div class='personaje'><strong>ğŸ“¬ CONSUMER = Camarero</strong><p>\"Dame, lo proceso, no esperes respuesta\" â†’ <code>void accept(T)</code></p></div><div class='personaje'><strong>ğŸ° SUPPLIER = MÃ¡quina</strong><p>\"No me des nada, solo pide\" â†’ <code>T get()</code></p></div><div class='personaje'><strong>ğŸ”„ FUNCTION = DJ</strong><p>\"Dame algo, lo transformo\" â†’ <code>R apply(T)</code></p></div></div>",
      "codigo": "// ğŸšª PREDICATE - Â¿Pasa?\nPredicate<Cuenta> activa = c -> \"ACTIVA\".equals(c.getEstado());\nboolean pasa = activa.test(cuenta);  // true/false\n\n// ğŸ“¬ CONSUMER - Ejecuta sin retorno\nConsumer<Transferencia> log = tx -> log.info(\"TX: {}\", tx);\nlog.accept(transferencia);  // No retorna nada\n\n// ğŸ° SUPPLIER - Genera\nSupplier<String> uuid = () -> UUID.randomUUID().toString();\nString id = uuid.get();  // Genera cuando pides\n\n// ğŸ”„ FUNCTION - Transforma\nFunction<Cuenta, CuentaDTO> toDTO = c -> new CuentaDTO(c.getId());\nCuentaDTO dto = toDTO.apply(cuenta);",
      "frase": "Predicate=filtra, Consumer=ejecuta, Supplier=genera, Function=transforma."
    },
    {
      "id": 10,
      "categoria": "funcional",
      "dificultad": "senior",
      "pregunta": "Â¿Operadores Intermedios vs Terminales?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Cocina del Chef Stream</p><p class='narrador'>El Chef Stream prepara platos con un proceso especial...</p><div class='etapa'><strong>ğŸ“ INTERMEDIOS = Instrucciones</strong><p>\"Picar, mezclar, sazonar... NADA se cocina aÃºn\"</p><p>Son LAZY. Solo preparan. Retornan otro Stream.</p><ul><li>filter(), map(), flatMap(), sorted(), distinct(), limit()</li></ul></div><div class='etapa'><strong>ğŸ”¥ TERMINALES = Â¡Al Horno!</strong><p>\"Â¡COCINAR! AquÃ­ se ejecuta todo\"</p><p>Disparan la ejecuciÃ³n. Solo UNO al final.</p><ul><li>collect(), forEach(), count(), reduce(), findFirst()</li></ul></div><div class='alerta'>âš ï¸ SIN TERMINAL = NADA PASA</div></div>",
      "codigo": "// âŒ NADA SE EJECUTA - Solo intermedios\ncuentas.stream()\n    .filter(c -> c.estaActiva())   // Lazy\n    .map(Cuenta::getSaldo);         // Lazy\n// Receta escrita, nadie cocinÃ³\n\n// âœ… AHORA SÃ - Terminal dispara todo\nList<BigDecimal> saldos = cuentas.stream()\n    .filter(c -> c.estaActiva())   // Intermedio\n    .map(Cuenta::getSaldo)          // Intermedio\n    .collect(toList());             // TERMINAL - Â¡Ejecuta!",
      "frase": "Sin terminal, tu Stream es letra muerta. Es el botÃ³n PLAY."
    },
    {
      "id": 11,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "Â¿CuÃ¡l es la jerarquÃ­a de Excepciones?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Ãrbol de los Errores</p><p class='narrador'>Todas las catÃ¡strofes tienen un ancestro: Throwable...</p><div class='arbol'><pre>ğŸ‘‘ THROWABLE\nâ”œâ”€â”€ âŒ ERROR (Desastres - No manejes)\nâ”‚   â””â”€â”€ OutOfMemoryError, StackOverflowError\nâ””â”€â”€ âš ï¸ EXCEPTION (Manejables)\n    â”œâ”€â”€ ğŸ”´ Checked (Obligatorio try-catch)\n    â”‚   â””â”€â”€ IOException, SQLException\n    â””â”€â”€ ğŸŸ¡ RuntimeException (Unchecked - Opcional)\n        â””â”€â”€ NullPointerException, IllegalArgumentException</pre></div><div class='regla'><strong>ğŸ¯ REGLA:</strong><p>Checked = Problemas externos (archivo, BD)</p><p>Unchecked = Bugs tuyos (null, Ã­ndice)</p></div></div>",
      "codigo": "// ğŸ”´ CHECKED - Obligatorio manejar\ntry {\n    new FileReader(\"datos.txt\");\n} catch (FileNotFoundException e) {  // OBLIGATORIO\n    log.error(\"No existe\");\n}\n\n// ğŸŸ¡ UNCHECKED - Opcional (RuntimeException)\npublic void transferir(Cuenta c, BigDecimal m) {\n    if (c == null) throw new IllegalArgumentException(\"Cuenta null\");\n    if (m.compareTo(ZERO) <= 0) throw new IllegalArgumentException(\"Monto invÃ¡lido\");\n}\n\n// âŒ ERROR - No manejes, deja que muera\n// catch (OutOfMemoryError e) { } // Â¡NO!",
      "frase": "Checked=mundo. Unchecked=tÃº. Error=apocalipsis."
    },
    {
      "id": 12,
      "categoria": "reactivo",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es ProgramaciÃ³n Reactiva?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Restaurante vs Food Court</p><p class='narrador'>Dos formas de servir a miles de clientes...</p><div class='comparacion'><div class='opcion'><strong>ğŸ– TRADICIONAL (Bloqueante)</strong><p>Pides pollo, te quedas PARADO 20 min esperando.</p><p>1,000 clientes = 1,000 meseros = ğŸ’¸ğŸ’¸ğŸ’¸</p></div><div class='opcion'><strong>ğŸ• REACTIVO (No Bloqueante)</strong><p>Pides, te dan BEEPER, te sientas. Te avisan cuando estÃ¡.</p><p>1,000 clientes = 10 meseros = ğŸ’° (90% ahorro)</p></div></div><div class='impacto'><strong>ğŸš€ EN YAPE:</strong><p>100,000 usuarios en hora punta.</p><p>Tradicional: 100 servidores. Reactivo: 10 servidores.</p></div></div>",
      "codigo": "// ğŸ– BLOQUEANTE - Hilo muerto esperando\npublic Saldo getSaldo(String id) {\n    return repository.findById(id);  // ğŸ˜´ Esperando...\n}\n\n// ğŸ• REACTIVO - Hilo libre\npublic Mono<Saldo> getSaldo(String id) {\n    return repository.findById(id);  // ğŸƒ Sigue trabajando\n}\n\n// FLUJO COMPLETO\npublic Mono<Response> yapear(YapeRequest req) {\n    return validarCuenta(req)         // No bloquea\n        .flatMap(this::validarSaldo)  // No bloquea\n        .flatMap(this::ejecutar)      // No bloquea\n        .map(this::response);         // Transforma\n}",
      "frase": "Reactivo = beeper. No esperas, te avisan. Escala 10x."
    },
    {
      "id": 13,
      "categoria": "reactivo",
      "dificultad": "senior",
      "pregunta": "Â¿Mono vs Flux?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Delivery Reactivo</p><p class='narrador'>Dos tipos de paquetes en el delivery...</p><div class='paquete'><strong>ğŸ“¦ MONO = Un Paquete</strong><p>\"Pediste UNA pizza, te llega UNA (o ninguna)\"</p><p>Emite: 0 o 1 elemento</p><ul><li>Buscar por ID â†’ Mono&lt;Cuenta&gt;</li><li>Guardar â†’ Mono&lt;Cuenta&gt;</li><li>Transferir â†’ Mono&lt;Transferencia&gt;</li></ul></div><div class='paquete'><strong>ğŸ“¬ FLUX = SuscripciÃ³n</strong><p>\"Te suscribiste a revista. Llegan MUCHOS nÃºmeros.\"</p><p>Emite: 0 a N elementos</p><ul><li>Listar movimientos â†’ Flux&lt;Movimiento&gt;</li><li>Notificaciones real-time â†’ Flux&lt;Notif&gt;</li></ul></div></div>",
      "codigo": "// ğŸ“¦ MONO - Una respuesta\npublic Mono<Cuenta> buscar(String id) {\n    return repo.findById(id);  // 0 o 1\n}\n\n// ğŸ“¬ FLUX - MÃºltiples\npublic Flux<Movimiento> getMovimientos(String cuentaId) {\n    return repo.findByCuentaId(cuentaId);  // 0 a N\n}\n\n// CONVERSIONES\nMono<List<Mov>> lista = flux.collectList();  // Flux â†’ Mono<List>\nFlux<Cuenta> flujo = Flux.just(c1, c2);      // Varios â†’ Flux",
      "frase": "Mono=UNA cosa. Flux=MUCHAS cosas."
    },
    {
      "id": 14,
      "categoria": "frameworks",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es InyecciÃ³n de Dependencias?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Chef y los Ingredientes</p><p class='narrador'>Dos chefs preparan ceviche diferente...</p><div class='chef'><strong>ğŸ‘¨â€ğŸ³ SIN INYECCIÃ“N</strong><p>\"Yo voy al mercado, compro pescado, limones...\"</p><p>CambiÃ³ proveedor = cambio MI cÃ³digo. Para testear = ingredientes REALES.</p></div><div class='chef'><strong>ğŸ‘¨â€ğŸ³ CON INYECCIÃ“N</strong><p>\"Me TRAEN ingredientes. Yo solo cocino.\"</p><p>CambiÃ³ proveedor = no me importa. Para testear = ingredientes FALSOS (mocks).</p></div><div class='regla'><strong>ğŸ¯ REGLA:</strong> No hagas <code>new Dependencia()</code>. Declara quÃ© necesitas, el framework te lo da.</div></div>",
      "codigo": "// âŒ SIN DI - Acoplado\npublic class TransferenciaService {\n    private CuentaRepo repo = new CuentaRepoImpl();  // YO creo\n}\n\n// âœ… CON DI - Desacoplado\n@Service\npublic class TransferenciaService {\n    private final CuentaRepo repo;  // Solo DECLARO\n    \n    public TransferenciaService(CuentaRepo repo) {\n        this.repo = repo;  // Spring INYECTA\n    }\n}\n\n// TEST con mocks\nvar service = new TransferenciaService(mockRepo);",
      "frase": "DI: declaras quÃ© necesitas, el framework te lo da."
    },
    {
      "id": 15,
      "categoria": "frameworks",
      "dificultad": "junior",
      "pregunta": "Â¿QuÃ© es Lombok?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Practicante MÃ¡gico</p><p class='narrador'>Los developers hartos de cÃ³digo aburrido...</p><div class='problema'><strong>ğŸ˜« PROBLEMA:</strong><p>Una clase Cuenta = 50+ lÃ­neas de getters, setters, equals, hashCode, toString...</p></div><div class='heroe'><strong>âœ¨ LOMBOK</strong><p>\"Ponme una anotaciÃ³n, yo escribo todo.\"</p><ul><li><strong>@Data</strong> = Getters + Setters + equals + hashCode + toString</li><li><strong>@Builder</strong> = PatrÃ³n Builder</li><li><strong>@Slf4j</strong> = Logger gratis</li></ul></div></div>",
      "codigo": "// ğŸ˜« SIN LOMBOK - 50 lÃ­neas\npublic class Cuenta {\n    private String id;\n    // + getters, setters, equals, hashCode, toString...\n}\n\n// âœ¨ CON LOMBOK - 5 lÃ­neas\n@Data @Builder @NoArgsConstructor @AllArgsConstructor\npublic class Cuenta {\n    private String id;\n    private BigDecimal saldo;\n}\n\n// Uso\nCuenta c = Cuenta.builder().id(\"123\").saldo(new BigDecimal(\"1500\")).build();\n\n// @Slf4j\n@Slf4j @Service\npublic class MiServicio {\n    public void x() { log.info(\"Funciona!\"); }  // log ya existe\n}",
      "frase": "@Data + @Builder + @Slf4j = obligatorio en Java moderno."
    },
    {
      "id": 16,
      "categoria": "seguridad",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es JWT?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Pase VIP</p><p class='narrador'>En el concierto, demuestras quiÃ©n eres con un pase especial...</p><div class='vip'><strong>ğŸ« JWT = Pase VIP Firmado</strong><p>3 partes: HEADER.PAYLOAD.SIGNATURE</p><ul><li><strong>Header:</strong> Tipo de pase</li><li><strong>Payload:</strong> Tu info (nombre, roles, expiraciÃ³n)</li><li><strong>Signature:</strong> Holograma que prueba es real</li></ul></div><div class='flujo'><strong>ğŸ”„ FLUJO:</strong><p>Login â†’ Te dan JWT â†’ Lo envÃ­as en cada request â†’ Servidor verifica holograma</p></div><div class='magia'><strong>âœ¨ MAGIA:</strong> Servidor NO guarda sesiones. Todo en el token. STATELESS.</div></div>",
      "codigo": "// ESTRUCTURA\n// eyJhbGc.eyJzdWI.firma\n// HEADER.PAYLOAD.SIGNATURE\n\n// GENERAR\nString token = Jwts.builder()\n    .setSubject(usuario.getId())\n    .claim(\"roles\", usuario.getRoles())\n    .setExpiration(new Date(now + 3600000))\n    .signWith(SECRET_KEY)\n    .compact();\n\n// VALIDAR\nClaims claims = Jwts.parser()\n    .setSigningKey(SECRET_KEY)\n    .parseClaimsJws(token)\n    .getBody();\n\n// ENVIAR: Authorization: Bearer eyJhbGc...",
      "frase": "JWT: pase firmado. Servidor no guarda nada. Stateless = escala infinito."
    },
    {
      "id": 17,
      "categoria": "seguridad",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es OAuth2?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Valet Parking</p><p class='narrador'>En el hotel, accedes al carro de forma especial...</p><div class='concepto'><strong>ğŸš— OAUTH2 = Valet Parking para Datos</strong><p>Das llave ESPECIAL (token) al valet (app) para estacionar.</p><p>Pero NO le das llave de tu casa. Acceso LIMITADO y TEMPORAL.</p></div><div class='flujos'><strong>ğŸ“‹ FLUJOS:</strong><ul><li><strong>Authorization Code:</strong> Web apps con backend (mÃ¡s seguro)</li><li><strong>Client Credentials:</strong> MÃ¡quina a mÃ¡quina (microservicios)</li></ul></div><div class='alerta'>âš ï¸ OAuth2 = AUTORIZACIÃ“N (quÃ© puedes hacer), no AUTENTICACIÃ“N (quiÃ©n eres)</div></div>",
      "codigo": "// AUTHORIZATION CODE\n// 1. Redirect\nGET https://auth.banco.com/authorize?response_type=code&client_id=app\n\n// 2. Usuario aprueba, recibe cÃ³digo\n// 3. Backend intercambia cÃ³digo por token\nPOST https://auth.banco.com/token\ngrant_type=authorization_code&code=ABC123&client_secret=SECRET\n\n// 4. Recibe tokens\n{\"access_token\": \"eyJ...\", \"refresh_token\": \"eyJ...\"}\n\n// CLIENT CREDENTIALS (servicio a servicio)\nPOST /token grant_type=client_credentials&client_id=ms-x&client_secret=SECRET",
      "frase": "Auth Code para usuarios. Client Credentials para microservicios."
    },
    {
      "id": 18,
      "categoria": "mensajeria",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es Kafka?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: PeriÃ³dico vs Carta</p><p class='narrador'>Dos formas de comunicarse entre servicios...</p><div class='comparacion'><div class='opcion'><strong>ğŸ“° KAFKA = PeriÃ³dico</strong><p>Se imprime UNA vez, TODOS leen, queda ARCHIVADO.</p><p>Puedes leer el de ayer, de la semana pasada...</p></div><div class='opcion'><strong>ğŸ’Œ RABBITMQ = Carta</strong><p>Se entrega a UNO, confirmas, se destruye.</p></div></div><div class='conceptos'><strong>ğŸ“š CONCEPTOS:</strong><ul><li><strong>Topic:</strong> El periÃ³dico</li><li><strong>Partition:</strong> Secciones para paralelo</li><li><strong>Producer:</strong> Publica</li><li><strong>Consumer:</strong> Lee</li><li><strong>Offset:</strong> PÃ¡gina donde te quedaste</li></ul></div></div>",
      "codigo": "// PRODUCER\n@Service\npublic class EventPublisher {\n    @Autowired KafkaTemplate<String, Object> kafka;\n    \n    public void publicar(TransferenciaEvent e) {\n        kafka.send(\"transferencias\", e.getCuentaId(), e);\n    }\n}\n\n// CONSUMER\n@KafkaListener(topics = \"transferencias\", groupId = \"notif\")\npublic void procesar(TransferenciaEvent e) {\n    log.info(\"Recibido: {}\", e);\n}",
      "frase": "Kafka=periÃ³dico (todos leen, archivado). RabbitMQ=carta (uno recibe)."
    },
    {
      "id": 19,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es DDD?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Departamentos del Banco</p><p class='narrador'>Cada departamento tiene su idioma y territorio...</p><div class='concepto'><strong>ğŸ›ï¸ DDD = CÃ³digo como el Negocio</strong><p>\"El cÃ³digo debe hablar el idioma del negocio\"</p></div><div class='bloques'><strong>ğŸ§± BLOQUES:</strong><ul><li><strong>Bounded Context:</strong> Departamento. Cuentas â‰  PrÃ©stamos.</li><li><strong>Aggregate:</strong> Grupo que se modifica junto. Cuenta + Movimientos.</li><li><strong>Domain Event:</strong> NotificaciÃ³n. \"TransferenciaRealizada\"</li><li><strong>Anti-Corruption Layer:</strong> Traductor con sistemas legacy.</li></ul></div></div>",
      "codigo": "// AGGREGATE ROOT\n@AggregateRoot\npublic class Cuenta {\n    private CuentaId id;\n    private Saldo saldo;\n    private List<Movimiento> movimientos;\n    \n    public DomainEvent debitar(Monto monto) {\n        if (saldo.menorQue(monto)) throw new SaldoInsuficienteException();\n        saldo = saldo.restar(monto);\n        return new CuentaDebitada(id, monto, Instant.now());\n    }\n}\n\n// DOMAIN EVENT\npublic record CuentaDebitada(CuentaId id, Monto monto, Instant cuando) {}",
      "frase": "DDD: cÃ³digo que habla el idioma del negocio."
    },
    {
      "id": 20,
      "categoria": "liderazgo",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es Conventional Commits?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Caos de Commits</p><p class='narrador'>Los commits eran un desastre...</p><div class='caos'><strong>ğŸ˜± CAOS:</strong><pre>\"arreglÃ© algo\" / \"WIP\" / \"asdf\" / \"cambios\"</pre></div><div class='heroe'><strong>âœ¨ CONVENTIONAL COMMITS</strong><p>Formato: <code>tipo(alcance): descripciÃ³n</code></p></div><div class='tipos'><strong>ğŸ·ï¸ TIPOS:</strong><ul><li><strong>feat:</strong> Nueva funcionalidad</li><li><strong>fix:</strong> Bug fix</li><li><strong>docs:</strong> DocumentaciÃ³n</li><li><strong>refactor:</strong> RefactorizaciÃ³n</li><li><strong>test:</strong> Tests</li><li><strong>chore:</strong> Mantenimiento</li></ul></div></div>",
      "codigo": "# âœ… BUENOS\ngit commit -m \"feat(auth): agregar login con Google\"\ngit commit -m \"fix(transfer): corregir cÃ¡lculo comisiÃ³n\"\ngit commit -m \"docs(readme): actualizar instalaciÃ³n\"\ngit commit -m \"refactor(cuenta): extraer validaciones\"\ngit commit -m \"test(transfer): tests transferencias fallidas\"\n\n# BREAKING CHANGE\ngit commit -m \"feat(api)!: cambiar estructura respuesta\"\n\n# âŒ MALOS\ngit commit -m \"fix\" / \"cambios\" / \"WIP\"",
      "frase": "feat=feature, fix=bug, docs=docs. AsÃ­ de simple."
    },
    {
      "id": 21,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es GitHub Actions?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La FÃ¡brica Automatizada</p><p class='narrador'>Antes todo era manual. Ahora hay robots...</p><div class='antes'><strong>ğŸ˜° ANTES:</strong><p>Push â†’ Â¿Alguien corre tests? â†’ Â¿Alguien hace build? â†’ Â¿Alguien despliega?</p></div><div class='despues'><strong>ğŸ¤– DESPUÃ‰S:</strong><p>Push â†’ ROBOT tests â†’ ROBOT build â†’ ROBOT quality â†’ ROBOT deploy</p><p>\"Imposible desplegar cÃ³digo roto\"</p></div></div>",
      "codigo": "# .github/workflows/ci.yml\nname: CI/CD\non:\n  push:\n    branches: [main]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-java@v4\n        with:\n          distribution: 'temurin'\n          java-version: '17'\n      - run: ./gradlew test\n      - run: ./gradlew build\n  \n  deploy:\n    needs: build\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - run: echo \"Desplegando...\"",
      "frase": "Push â†’ Tests â†’ Build â†’ Deploy. Todo automÃ¡tico."
    },
    {
      "id": 22,
      "categoria": "cloud",
      "dificultad": "senior",
      "pregunta": "Docker en 5 comandos",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Tupperware de CÃ³digo</p><p class='narrador'>Empacas tu app para que funcione igual en todos lados...</p><div class='concepto'><strong>ğŸ“¦ DOCKER = Tupperware</strong><p>Empacas app + todo lo que necesita. Funciona IGUAL en cualquier servidor.</p></div><div class='comandos'><strong>ğŸ”§ LOS 5:</strong><ol><li><code>docker build -t app:v1 .</code> â†’ Construir</li><li><code>docker run -d -p 8080:8080 app</code> â†’ Ejecutar</li><li><code>docker ps</code> â†’ Ver corriendo</li><li><code>docker logs -f container</code> â†’ Ver logs</li><li><code>docker exec -it container sh</code> â†’ Entrar</li></ol></div></div>",
      "codigo": "# DOCKERFILE\nFROM eclipse-temurin:17-jre-alpine\nCOPY target/*.jar app.jar\nCMD [\"java\", \"-jar\", \"app.jar\"]\n\n# COMANDOS\ndocker build -t app:v1 .\ndocker run -d -p 8080:8080 app:v1\ndocker ps\ndocker logs -f mi-container\ndocker exec -it mi-container sh\n\n# COMPOSE\ndocker-compose up -d",
      "frase": "build, run, ps, logs, exec. Con esos 5 sobrevives."
    },
    {
      "id": 23,
      "categoria": "cloud",
      "dificultad": "lead",
      "pregunta": "Kubernetes en 6 comandos",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Incidente 3am</p><p class='narrador'>ProducciÃ³n caÃ­do. Solo tienes kubectl y cafÃ©...</p><div class='comandos'><strong>ğŸ†˜ LOS 6 QUE TE SALVAN:</strong><ol><li><code>kubectl get pods</code> â†’ Â¿QuÃ© hay?</li><li><code>kubectl describe pod X</code> â†’ Â¿Por quÃ© fallÃ³?</li><li><code>kubectl logs -f X</code> â†’ Â¿QuÃ© dice?</li><li><code>kubectl exec -it X -- sh</code> â†’ Entrar</li><li><code>kubectl rollout undo deployment/X</code> â†’ Â¡ROLLBACK!</li><li><code>kubectl apply -f X.yaml</code> â†’ Desplegar</li></ol></div><div class='emergencia'><strong>ğŸš¨ EMERGENCIA:</strong><p><code>kubectl rollout undo</code> = tu mejor amigo</p></div></div>",
      "codigo": "kubectl get pods                      # Ver\nkubectl get pods -w                   # Watch\nkubectl describe pod mi-pod           # Detalles\nkubectl logs -f mi-pod                # Logs\nkubectl exec -it mi-pod -- sh         # Entrar\nkubectl rollout undo deployment/app   # ROLLBACK\nkubectl apply -f k8s/                 # Desplegar",
      "frase": "get, describe, logs, exec, rollout, apply. Te salvan a las 3am."
    },
    {
      "id": 24,
      "categoria": "frameworks",
      "dificultad": "senior",
      "pregunta": "Â¿Spring Boot o Quarkus?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Concesionario</p><p class='narrador'>Dos vehÃ­culos compiten...</p><div class='vehiculo'><strong>ğŸš™ SPRING BOOT = Land Cruiser</strong><ul><li>Veterano, todos lo conocen</li><li>DocumentaciÃ³n infinita</li><li>Startup: 2-5s, RAM: 200-500MB</li></ul></div><div class='vehiculo'><strong>ğŸï¸ QUARKUS = Moto Deportiva</strong><ul><li>Joven, naciÃ³ para containers</li><li>Startup: 0.02s (native), RAM: 20MB</li><li>GraalVM nativo desde dÃ­a 1</li></ul></div><div class='decision'><strong>ğŸ¯ DECISIÃ“N:</strong><p>Spring: Equipo grande, ecosistema completo</p><p>Quarkus: Kubernetes, serverless, cada ms cuenta</p></div></div>",
      "codigo": "// SPRING BOOT\n@RestController\npublic class CuentaController {\n    @Autowired CuentaService service;\n    @GetMapping(\"/{id}\")\n    public Cuenta get(@PathVariable String id) { return service.find(id); }\n}\n\n// QUARKUS\n@Path(\"/cuentas\")\npublic class CuentaResource {\n    @Inject CuentaService service;\n    @GET @Path(\"/{id}\")\n    public Cuenta get(@PathParam(\"id\") String id) { return service.find(id); }\n}\n\n# QUARKUS NATIVE\n./mvnw package -Pnative  # 50MB, 0.02s startup",
      "frase": "Spring=todo. Quarkus=velocidad. No hay malo, hay contexto."
    },
    {
      "id": 25,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿Patrones de resiliencia para microservicios?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Los 5 Guardianes</p><p class='narrador'>5 guardianes protegen contra el caos...</p><div class='guardian'><strong>âš¡ CIRCUIT BREAKER</strong><p>Fusible. 5 fallas â†’ Corta circuito.</p></div><div class='guardian'><strong>ğŸ”„ RETRY</strong><p>Reintenta con backoff: 1s, 2s, 4s...</p></div><div class='guardian'><strong>â±ï¸ TIMEOUT</strong><p>5s mÃ¡ximo. Si no responde, siguiente.</p></div><div class='guardian'><strong>ğŸš¢ BULKHEAD</strong><p>Compartimentos. Si uno se inunda, otros siguen.</p></div><div class='guardian'><strong>ğŸ›Ÿ FALLBACK</strong><p>Plan B. Â¿No hay real-time? Muestro cache.</p></div></div>",
      "codigo": "@CircuitBreaker(name = \"pagos\", fallbackMethod = \"fallback\")\n@Retry(name = \"pagos\")\n@TimeLimiter(name = \"pagos\")\n@Bulkhead(name = \"pagos\")\npublic Mono<Response> pagar(Request req) {\n    return webClient.post().bodyValue(req).retrieve().bodyToMono(Response.class);\n}\n\npublic Mono<Response> fallback(Request req, Throwable t) {\n    return Mono.just(Response.pendiente(\"Reintentando...\"));\n}\n\n# Config\nresilience4j.circuitbreaker.instances.pagos:\n  failureRateThreshold: 50\n  waitDurationInOpenState: 30s",
      "frase": "DiseÃ±a para el FALLO. CircuitBreaker+Retry+Timeout+Fallback=sobrevives."
    },
    {
      "id": 26,
      "categoria": "patrones",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© son los principios SOLID?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Templo de los 5 Maestros</p><p class='narrador'>En las montaÃ±as de CleanCodelandia, 5 maestros ancestrales guardan los secretos del cÃ³digo que NO apesta...</p><p>Un joven developer llamado Junior llegÃ³ buscando sabidurÃ­a. Los maestros hablaron:</p><div class='dialogo'><p><strong>ğŸ‘´ Maestro S (Responsabilidad Ãšnica):</strong></p><p><em>\"Â¿Ves a ese chef? Cocina. Â¿Ves al mesero? Sirve. El chef NO lava platos. Cada clase, UN trabajo. Cuando tu clase hace TODO, no hace NADA bien.\"</em></p></div><div class='dialogo'><p><strong>ğŸ‘´ Maestro O (Abierto/Cerrado):</strong></p><p><em>\"Mi cÃ³digo es como LEGO. Â¿Quieres nueva funcionalidad? AGREGAS pieza. NUNCA destruyes las que ya funcionan.\"</em></p></div><div class='dialogo'><p><strong>ğŸ‘´ Maestro L (Liskov):</strong></p><p><em>\"Si dices que tu Pato es un Ave, mÃ¡s te vale que vuele. El hijo NUNCA debe romper promesas del padre.\"</em></p></div><div class='dialogo'><p><strong>ğŸ‘´ Maestro I (SegregaciÃ³n):</strong></p><p><em>\"No obligues al pez a implementar caminar(). Interfaces PEQUEÃ‘AS. Solo lo que necesitas.\"</em></p></div><div class='dialogo'><p><strong>ğŸ‘´ Maestro D (InversiÃ³n):</strong></p><p><em>\"El rey no conoce al panadero. Conoce 'alguien que hace pan'. Depende de CONTRATOS, no de implementaciones.\"</em></p></div></div>",
      "codigo": "// ğŸ‘´ S - Chef solo cocina\n@Service class ValidadorTransferencia { } // Solo valida\n@Service class EjecutorTransferencia { }  // Solo ejecuta\n\n// ğŸ‘´ O - LEGO: agrega, no destruyas\ninterface Notificador { void enviar(String msg); }\nclass SmsNotif implements Notificador { }  // Nueva pieza, cero cambios\n\n// ğŸ‘´ D - El rey y el panadero\npublic TransferenciaService(NotificadorPort notif) {}  // Contrato, no impl",
      "frase": "S=un trabajo. O=LEGO. L=promesas. I=pequeÃ±o. D=contratos."
    },
    {
      "id": 27,
      "categoria": "fundamentos",
      "dificultad": "senior",
      "pregunta": "Â¿CÃ³mo funciona la memoria en Java?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Ciudad de Memorylandia</p><p class='narrador'>En Memorylandia existen dos zonas muy diferentes donde viven los datos...</p><p>El alcalde JVM gobierna ambas con reglas estrictas.</p><div class='zona'><p><strong>ğŸ  ZONA STACK - El Barrio de las Casitas</strong></p><p>Casitas pequeÃ±as, ordenadas en fila. Cada trabajador (hilo) tiene su propia calle privada.</p><p><em>\"Â¿Terminaste tu mÃ©todo? Tu casita DESAPARECE automÃ¡ticamente. AquÃ­ nadie limpia, todo es automÃ¡tico.\"</em></p><p>AquÃ­ viven: variables locales, parÃ¡metros, y las DIRECCIONES de los objetos (no los objetos mismos).</p></div><div class='zona'><p><strong>ğŸ¢ ZONA HEAP - El Condominio CaÃ³tico</strong></p><p>Edificio ENORME donde viven todos los objetos. Compartido por TODOS los hilos.</p><p><em>\"Â¿Nadie te visita? El SeÃ±or GC viene a desalojarte.\"</em></p><p>AquÃ­ viven: todos los objetos creados con <code>new</code>.</p></div><p class='revelacion'>ğŸ”‘ <strong>LA CLAVE:</strong> Stack guarda la DIRECCIÃ“N. Heap guarda el OBJETO. Cuando pasas un objeto a un mÃ©todo, pasas la direcciÃ³n, no una copia.</p></div>",
      "codigo": "public void yapear(Cuenta origen, BigDecimal monto) {\n    // STACK de este mÃ©todo:\n    // - origen â†’ DIRECCIÃ“N al objeto Cuenta en Heap\n    // - monto  â†’ DIRECCIÃ“N al objeto BigDecimal en Heap\n    \n    String id = generarId();  // STACK: id (direcciÃ³n)\n                               // HEAP: objeto String \"ABC123\"\n}  \n// MÃ©todo termina â†’ Stack se limpia SOLO\n// Heap â†’ GC decidirÃ¡ cuÃ¡ndo limpiar",
      "frase": "Stack=casita privada (auto-limpia). Heap=condominio (GC limpia huÃ©rfanos)."
    },
    {
      "id": 28,
      "categoria": "fundamentos",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© hace el Garbage Collector?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Don Limpio y el Condominio Heap</p><p class='narrador'>En el Condominio Heap vive un personaje legendario: Don Limpio, el Garbage Collector...</p><p>Don Limpio tiene una regla simple:</p><p class='cita'>ğŸ’€ <em>\"Â¿Nadie te visita? Â¿Nadie tiene tu direcciÃ³n? Entonces estÃ¡s MUERTO para mÃ­. Â¡FUERA!\"</em></p><div class='historia'><p>El condominio tiene 3 pisos:</p><p><strong>ğŸ£ Piso 1 - Young Generation:</strong> AquÃ­ nacen TODOS los objetos. Don Limpio pasa SEGUIDO. La mayorÃ­a muere joven (variables temporales).</p><p><strong>ğŸ‘´ Piso 2 - Old Generation:</strong> Los sobrevivientes suben aquÃ­. Don Limpio pasa POCO pero cuando pasa... es PESADO (Full GC).</p><p><strong>ğŸ“š Piso 3 - Metaspace:</strong> Donde viven las clases. Don Limpio casi nunca sube.</p></div><div class='villano'><p><strong>ğŸ˜± EL TERROR:</strong> Cuando Don Limpio hace limpieza profunda (Full GC), TODO EL EDIFICIO SE CONGELA. Stop-The-World. Por eso existen los nuevos limpiadores: G1GC, ZGC...</p></div></div>",
      "codigo": "// VER A DON LIMPIO TRABAJAR\njava -Xlog:gc* -jar app.jar\n\n// ELEGIR TIPO DE DON LIMPIO\njava -XX:+UseG1GC app.jar      // Balance (default Java 11+)\njava -XX:+UseZGC app.jar       // Pausas < 1ms (Java 15+)\njava -XX:+UseShenandoahGC      // Similar a ZGC\n\n// NUNCA HAGAS ESTO EN PROD\nSystem.gc();  // \"Oye Don Limpio, limpia YA\" (Ã©l decide si te hace caso)",
      "frase": "Don Limpio: sin referencias = muerto. G1GC balance, ZGC velocidad."
    },
    {
      "id": 29,
      "categoria": "mensajeria",
      "dificultad": "senior",
      "pregunta": "Â¿Kafka vs RabbitMQ?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: PeriÃ³dico vs Cartero</p><p class='narrador'>Dos filosofÃ­as de entregar mensajes...</p><div class='versus'><div class='opcion'><strong>ğŸ“° KAFKA</strong><ul><li>PeriÃ³dico: TODOS leen, queda guardado</li><li>Replay: puedes leer mensajes viejos</li><li>Throughput: millones/seg</li><li>Usa cuando: eventos, analytics, logs</li></ul></div><div class='opcion'><strong>ğŸ° RABBITMQ</strong><ul><li>Cartero: entrega a UNO, confirma, destruye</li><li>Routing: flexible, exchanges</li><li>Acknowledge: garantiza procesamiento</li><li>Usa cuando: tareas, workflows, RPC</li></ul></div></div><div class='decision'><strong>ğŸ¯ REGLA:</strong> Eventos/stream = Kafka. Tareas/comandos = RabbitMQ.</div></div>",
      "codigo": "// KAFKA - Eventos\n@KafkaListener(topics = \"transferencias\")\npublic void onTransfer(TransferenciaEvent e) {\n    // MÃºltiples consumers pueden leer el MISMO evento\n}\n\n// RABBITMQ - Tareas\n@RabbitListener(queues = \"enviar-email\")\npublic void process(EmailTask task) {\n    emailService.send(task);  // Solo UN consumer procesa\n    // ACK automÃ¡tico al terminar\n}",
      "frase": "Kafka=eventos (todos leen). RabbitMQ=tareas (uno procesa)."
    },
    {
      "id": 30,
      "categoria": "frameworks",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© son los scopes de Spring?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Vida de los Beans</p><p class='narrador'>Cada bean tiene su ciclo de vida...</p><div class='scope'><strong>ğŸŒ SINGLETON (default)</strong><p>\"Nace UNO, todos comparten ese mismo.\"</p><p>Usa: Services, Repositories (stateless)</p></div><div class='scope'><strong>ğŸ”„ PROTOTYPE</strong><p>\"Cada vez que pides, nace uno nuevo.\"</p><p>Usa: Builders, objetos con estado</p></div><div class='scope'><strong>ğŸŒ REQUEST</strong><p>\"Vive durante UN request HTTP.\"</p></div><div class='scope'><strong>ğŸ“‹ SESSION</strong><p>\"Vive durante la sesiÃ³n del usuario.\"</p></div><div class='alerta'>âš ï¸ Singleton + estado mutable = BUG de concurrencia</div></div>",
      "codigo": "// SINGLETON (default) - Compartido\n@Service\npublic class CuentaService { }  // UNA instancia\n\n// PROTOTYPE - Nueva cada vez\n@Scope(\"prototype\")\n@Component\npublic class ReporteBuilder { }  // NUEVA cada inyecciÃ³n\n\n// REQUEST - Por peticiÃ³n HTTP\n@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)\n@Component\npublic class RequestContext { }",
      "frase": "Singleton=compartido. Prototype=nuevo. Request=por peticiÃ³n."
    },
    {
      "id": 31,
      "categoria": "frameworks",
      "dificultad": "senior",
      "pregunta": "Â¿CÃ³mo manejar transacciones en Spring?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Todo o Nada</p><p class='narrador'>Una transferencia tiene DOS operaciones...</p><div class='problema'><strong>âŒ SIN TRANSACCIÃ“N:</strong><p>DÃ©bito âœ… â†’ Error â†’ CrÃ©dito âŒ</p><p>Â¡Dinero desapareciÃ³!</p></div><div class='solucion'><strong>âœ… CON TRANSACCIÃ“N:</strong><p>DÃ©bito â†’ Error â†’ ROLLBACK â†’ Todo vuelve atrÃ¡s</p></div><div class='propagacion'><strong>ğŸ“‹ PROPAGACIÃ“N:</strong><ul><li><strong>REQUIRED:</strong> Usa existente o crea nueva</li><li><strong>REQUIRES_NEW:</strong> SIEMPRE nueva (independiente)</li><li><strong>MANDATORY:</strong> DEBE existir una</li></ul></div></div>",
      "codigo": "@Service\npublic class TransferenciaService {\n    \n    @Transactional  // Todo o nada\n    public void transferir(String origen, String destino, BigDecimal monto) {\n        cuentaRepo.debitar(origen, monto);   // Si esto falla...\n        cuentaRepo.acreditar(destino, monto); // ...esto NO se ejecuta\n    }                                         // O ambos, o ninguno\n    \n    @Transactional(propagation = Propagation.REQUIRES_NEW)\n    public void auditarSiempre(String msg) {\n        // TransacciÃ³n INDEPENDIENTE\n        // Se guarda aunque la principal falle\n    }\n}",
      "frase": "@Transactional = todo o nada. REQUIRES_NEW = independiente."
    },
    {
      "id": 32,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es Event Sourcing?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Detective y la Cuenta Bancaria</p><p class='narrador'>El Detective GarcÃ­a investiga un fraude en el BCP. Llega a la bÃ³veda de datos...</p><div class='dialogo'><p><strong>ğŸ•µï¸ Detective:</strong> \"Necesito saber cÃ³mo esta cuenta llegÃ³ a tener $500.\"</p><p><strong>ğŸ’¾ Sistema Tradicional:</strong> \"Saldo = $500. Eso es todo lo que sÃ©.\"</p><p><strong>ğŸ•µï¸ Detective:</strong> \"Â¡Â¿Pero CÃ“MO llegÃ³ ahÃ­?! Â¡Â¿QuiÃ©n depositÃ³?! Â¡Â¿CuÃ¡ndo?!\"</p><p><strong>ğŸ’¾ Sistema:</strong> \"ğŸ¤· No tengo idea. Solo guardo el RESULTADO, no la HISTORIA.\"</p></div><div class='revelacion'><p><strong>âœ¨ ENTONCES NACIÃ“ EVENT SOURCING:</strong></p><p>\"No guardes el RESULTADO. Guarda cada COSA QUE PASÃ“.\"</p><p class='eventos'>ğŸ“œ CuentaCreada â†’ Depositado($1000) â†’ Debitado($300) â†’ Depositado($200) â†’ Debitado($400)</p><p>Â¿Saldo actual? Replay de eventos = $500</p><p>Â¿Saldo hace 2 meses? Replay hasta esa fecha.</p><p>Â¿QuiÃ©n hizo quÃ©? TODO estÃ¡ registrado.</p></div><p class='magia'><strong>ğŸ”® SUPERPODER:</strong> Time travel. AuditorÃ­a perfecta. Si hay bug, replay y corriges.</p></div>",
      "codigo": "// GUARDAS EVENTOS, NO ESTADO\npublic record CuentaCreada(String id, Instant cuando) {}\npublic record Depositado(String cuentaId, BigDecimal monto, Instant cuando) {}\npublic record Debitado(String cuentaId, BigDecimal monto, Instant cuando) {}\n\n// RECONSTRUIR = REPLAY\npublic Cuenta reconstruir(String cuentaId) {\n    List<Event> historia = eventStore.getEvents(cuentaId);\n    Cuenta cuenta = new Cuenta();\n    for (Event e : historia) {\n        cuenta.apply(e);  // \"PelÃ­cula\" de la cuenta\n    }\n    return cuenta;  // Estado actual\n}",
      "frase": "No guardes resultado, guarda historia. Siempre puedes hacer replay."
    },
    {
      "id": 33,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es CQRS?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: SeparaciÃ³n de Poderes</p><p class='narrador'>Leer y escribir son trabajos muy diferentes...</p><div class='concepto'><strong>âš”ï¸ CQRS = Command Query Responsibility Segregation</strong><p>\"Separar ESCRITURA de LECTURA\"</p></div><div class='separacion'><div class='lado'><strong>âœï¸ COMMAND (Escribir)</strong><p>CrearCuenta, Transferir</p><p>BD normalizada, validaciones</p></div><div class='lado'><strong>ğŸ‘ï¸ QUERY (Leer)</strong><p>GetCuenta, ListarMovimientos</p><p>BD desnormalizada, optimizada</p></div></div><div class='combo'><strong>ğŸ”¥ COMBO:</strong> CQRS + Event Sourcing = Poder mÃ¡ximo</div></div>",
      "codigo": "// COMMAND - Escribir\n@Service\npublic class CuentaCommandService {\n    public void crear(CrearCuentaCommand cmd) {\n        // Validaciones, reglas de negocio\n        // Guarda en BD de escritura\n    }\n}\n\n// QUERY - Leer (BD optimizada para lectura)\n@Service\npublic class CuentaQueryService {\n    public CuentaView getCuenta(String id) {\n        return cuentaReadRepo.findById(id);  // Vista desnormalizada\n    }\n}\n\n// SINCRONIZACIÃ“N vÃ­a eventos\n@EventHandler\npublic void on(CuentaCreada e) {\n    readRepo.save(new CuentaView(e));  // Actualiza vista\n}",
      "frase": "Escribe en BD normalizada. Lee de vista optimizada. Sincroniza con eventos."
    },
    {
      "id": 34,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es el patrÃ³n Saga?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Viaje de Pesadilla</p><p class='narrador'>MarÃ­a quiere ir a CancÃºn. Compra un paquete que incluye: Vuelo + Hotel + Auto...</p><div class='drama'><p><strong>âœˆï¸ Paso 1:</strong> Vuelo reservado. âœ… $500 cobrados.</p><p><strong>ğŸ¨ Paso 2:</strong> Hotel reservado. âœ… $300 cobrados.</p><p><strong>ğŸš— Paso 3:</strong> Auto... ERROR. No hay disponibles. âŒ</p><p class='panico'>ğŸ˜± <strong>Â¡PÃNICO!</strong> MarÃ­a pagÃ³ $800 pero NO puede viajar sin auto.</p><p>Â¿CÃ³mo deshaces pagos que ya estÃ¡n en OTROS sistemas?</p></div><div class='heroe'><p><strong>ğŸ¦¸ PATRÃ“N SAGA al rescate:</strong></p><p>Cada paso tiene su DESHACER (compensaciÃ³n):</p><p>âŒ Auto falla â†’ ğŸ”„ Cancelar hotel â†’ ğŸ”„ Reembolsar vuelo</p><p>Todo se deshace en orden INVERSO.</p></div><div class='tipos'><p><strong>ğŸ­ DOS ESTILOS:</strong></p><p><strong>OrquestaciÃ³n:</strong> Un director (Saga Orchestrator) da Ã³rdenes.</p><p><strong>CoreografÃ­a:</strong> Cada servicio escucha eventos y reacciona solo.</p></div></div>",
      "codigo": "// CADA PASO TIENE SU \"DESHACER\"\n// Paso 1: cobrar()     â†’ CompensaciÃ³n: reembolsar()\n// Paso 2: reservar()   â†’ CompensaciÃ³n: cancelar()\n// Paso 3: alquilar()   â†’ CompensaciÃ³n: liberar()\n\n@Service\npublic class ViajeSaga {\n    public void ejecutar(ViajeRequest req) {\n        String pagoId = null, hotelId = null;\n        try {\n            pagoId = pagoService.cobrar(req);      // Paso 1 âœ…\n            hotelId = hotelService.reservar(req);  // Paso 2 âœ…\n            autoService.alquilar(req);             // Paso 3 âŒ FALLA\n        } catch (Exception e) {\n            // COMPENSACIONES en orden inverso\n            if (hotelId != null) hotelService.cancelar(hotelId);\n            if (pagoId != null) pagoService.reembolsar(pagoId);\n        }\n    }\n}",
      "frase": "Saga: cada acciÃ³n tiene su deshacer. Falla = rebobinar todo."
    },
    {
      "id": 35,
      "categoria": "fundamentos",
      "dificultad": "junior",
      "pregunta": "Â¿QuÃ© es un Optional?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Paquete de SchrÃ¶dinger</p><p class='narrador'>Antes de Java 8, null era el terror...</p><div class='antes'><strong>ğŸ˜± ANTES:</strong><p><code>Cuenta c = repo.find(id); // Â¿null?</code></p><p>NullPointerException a las 3am</p></div><div class='despues'><strong>ğŸ“¦ OPTIONAL:</strong><p>\"Caja que PUEDE tener algo o estar vacÃ­a\"</p><p>Te OBLIGA a pensar en el caso vacÃ­o</p></div><div class='metodos'><strong>ğŸ”§ MÃ‰TODOS:</strong><ul><li><code>isPresent()</code> - Â¿Hay algo?</li><li><code>orElse(default)</code> - Si vacÃ­o, usa esto</li><li><code>orElseThrow()</code> - Si vacÃ­o, explota</li><li><code>map()</code> - Transforma si existe</li></ul></div></div>",
      "codigo": "// CREAR\nOptional<Cuenta> cuenta = repo.findById(id);  // Puede estar vacÃ­o\n\n// USAR\nString nombre = cuenta\n    .map(Cuenta::getTitular)\n    .orElse(\"Desconocido\");\n\n// LANZAR SI NO EXISTE\nCuenta c = cuenta.orElseThrow(() -> \n    new CuentaNotFoundException(id));\n\n// âŒ NO HAGAS\nif (optional.isPresent()) { optional.get(); }  // Anti-pattern\n\n// âœ… HAZ\noptional.ifPresent(c -> procesar(c));\noptional.map(this::procesar).orElse(default);",
      "frase": "Optional te OBLIGA a pensar en null. Usa map/orElse, no get()."
    },
    {
      "id": 36,
      "categoria": "seguridad",
      "dificultad": "senior",
      "pregunta": "Â¿CÃ³mo proteger endpoints con Spring Security?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Los Filtros del Club</p><p class='narrador'>Para entrar al club hay CAPAS de seguridad...</p><div class='capas'><strong>ğŸ” SECURITY FILTER CHAIN:</strong><ol><li>Â¿Tiene token? (Authentication)</li><li>Â¿Token vÃ¡lido? (JWT Validation)</li><li>Â¿Tiene permiso? (Authorization)</li></ol></div><div class='anotaciones'><strong>ğŸ·ï¸ ANOTACIONES:</strong><ul><li><code>@PreAuthorize(\"hasRole('ADMIN')\")</code></li><li><code>@Secured(\"ROLE_USER\")</code></li><li><code>permitAll()</code> / <code>authenticated()</code></li></ul></div></div>",
      "codigo": "@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n    \n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) {\n        return http\n            .csrf(csrf -> csrf.disable())\n            .authorizeHttpRequests(auth -> auth\n                .requestMatchers(\"/public/**\").permitAll()\n                .requestMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n                .anyRequest().authenticated()\n            )\n            .oauth2ResourceServer(oauth2 -> oauth2.jwt())\n            .build();\n    }\n}\n\n// EN CONTROLLER\n@PreAuthorize(\"hasRole('ADMIN')\")\n@GetMapping(\"/admin/usuarios\")\npublic List<Usuario> listar() { }",
      "frase": "SecurityFilterChain configura. @PreAuthorize protege mÃ©todo."
    },
    {
      "id": 37,
      "categoria": "liderazgo",
      "dificultad": "senior",
      "pregunta": "Â¿CÃ³mo haces code review efectivo?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Dojo del Code Review</p><p class='narrador'>Dos developers. Un Pull Request. La tensiÃ³n se corta con cuchillo...</p><div class='malo'><p><strong>ğŸ˜ˆ EL REVIEWER TÃ“XICO:</strong></p><p><em>\"Esto estÃ¡ mal.\"</em></p><p><em>\"No me gusta.\"</em></p><p><em>\"Â¿Por quÃ© hiciste esto asÃ­?\"</em> (tono de juicio)</p><p>Resultado: Developer humillado, equipo roto, nadie quiere hacer PRs.</p></div><div class='bueno'><p><strong>ğŸ§™ EL REVIEWER SABIO:</strong></p><p><em>\"Â¿QuÃ© pasa si monto es negativo? PodrÃ­amos agregar validaciÃ³n aquÃ­.\"</em></p><p><em>\"Interesante approach. Â¿Consideraste usar Optional? Te evitarÃ­a el null check.\"</em></p><p><em>\"[nit] PodrÃ­as extraer esto a mÃ©todo, pero no bloquea el PR.\"</em></p><p>Resultado: Developer aprende, equipo crece, cÃ³digo mejora.</p></div><p class='regla'><strong>ğŸ“ LA REGLA DE ORO:</strong> Critica el CÃ“DIGO, no la PERSONA. Pregunta en vez de ordenar. Y por favor... PRs de mÃ¡ximo 400 lÃ­neas. Nadie revisa bien 2000 lÃ­neas.</p></div>",
      "codigo": "// âŒ TÃ“XICO\n\"Esto estÃ¡ mal\"\n\"CÃ¡mbialo\"\n\"No entiendo por quÃ© hiciste esto\"\n\n// âœ… SABIO\n\"Â¿QuÃ© pasa si monto es null? Sugerencia:\nOptional.ofNullable(monto).orElseThrow(...)\"\n\n// LABELS QUE SALVAN VIDAS\n[nit] - \"Detallito, no bloquea\"\n[question] - \"Pregunta genuina\"\n[must-fix] - \"Esto sÃ­ debe cambiar\"",
      "frase": "Critica cÃ³digo, no personas. Pregunta, no ordenes. PRs pequeÃ±os."
    },
    {
      "id": 38,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Â¿CÃ³mo estimas tareas de desarrollo?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Trampa del \"Â¿CuÃ¡nto demora?\"</p><p class='narrador'>Gerencia pregunta. El developer tiembla. La historia siempre termina mal...</p><div class='escena1'><p><strong>ğŸ‘” Gerente:</strong> \"Â¿CuÃ¡nto demora agregar el botÃ³n de pago?\"</p><p><strong>ğŸ‘¨â€ğŸ’» Junior:</strong> \"Mmm... 2 dÃ­as.\"</p><p><strong>ğŸ”¥ REALIDAD:</strong> 2 semanas. El Junior no considerÃ³: integraciÃ³n con pasarela, manejo de errores, tests, QA, edge cases, la API legacy que nadie documentÃ³...</p></div><div class='revelacion'><p><strong>ğŸ§™ EL SECRETO:</strong> NO estimes TIEMPO. Estima COMPLEJIDAD.</p><p>T-shirt sizing: S, M, L, XL</p><p>S = trivial. XL = Â¿Seguro que es UNA tarea? DIVIDE.</p></div><div class='regla'><p><strong>ğŸ“ REGLAS DE ORO:</strong></p><p>1. Si > 8 puntos â†’ DIVIDIR</p><p>2. Multiplica tu estimado x1.5 (buffer de realidad)</p><p>3. El equipo estima JUNTO (Planning Poker). Si hay diferencias grandes, hay conocimiento oculto.</p></div></div>",
      "codigo": "// T-SHIRT â†’ PUNTOS\nS = 1-2 pts   // \"Lo hago en una sentada\"\nM = 3-5 pts   // \"Un dÃ­a enfocado\"\nL = 8-13 pts  // \"Necesito investigar\"\nXL = 21+ pts  // \"ALERTA: Dividir en tareas menores\"\n\n// FÃ“RMULA PERT (cuando te obliguen a dar tiempo)\nEstimado = (Optimista + 4Ã—Probable + Pesimista) / 6\n\n// EJEMPLO\nOptimista: 2 dÃ­as (todo sale perfecto)\nProbable: 5 dÃ­as (lo normal)\nPesimista: 12 dÃ­as (Murphy ataca)\n= (2 + 20 + 12) / 6 = 5.6 dÃ­as\nÃ— 1.5 buffer = 8.5 dÃ­as â†’ \"Una semana y media\"",
      "frase": "Estima complejidad, no tiempo. Si es XL, divide. Buffer x1.5."
    },
    {
      "id": 39,
      "categoria": "liderazgo",
      "dificultad": "lead",
      "pregunta": "Â¿CÃ³mo manejas deuda tÃ©cnica?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Hipoteca de Don CÃ³digo</p><p class='narrador'>Don CÃ³digo pidiÃ³ un prÃ©stamo al Banco del Tiempo...</p><div class='historia'><p><strong>ğŸ¦ AÃ‘O 1:</strong> \"Necesito entregar el MVP. Voy a hacer este cÃ³digo feo pero funciona. Ya lo arreglo despuÃ©s.\"</p><p><strong>ğŸ¦ AÃ‘O 2:</strong> \"No hay tiempo para arreglar, hay features nuevos. El cÃ³digo feo sigue ahÃ­.\"</p><p><strong>ğŸ¦ AÃ‘O 3:</strong> Los intereses se acumularon. Cada feature nuevo tarda 3x mÃ¡s. Los bugs aparecen solos. El equipo nuevo no entiende nada.</p><p class='colapso'>ğŸ’€ <strong>AÃ‘O 4:</strong> \"Hay que reescribir todo desde cero.\" Don CÃ³digo quebrÃ³.</p></div><div class='solucion'><p><strong>ğŸ’° CÃ“MO NO QUEBRAR:</strong></p><p>1. <strong>Visibiliza:</strong> TODO con ticket JIRA, no comentarios perdidos</p><p>2. <strong>Negocia:</strong> \"Producto, necesito 20% del sprint para pagar deuda\"</p><p>3. <strong>Boy Scout:</strong> Deja el cÃ³digo mejor de como lo encontraste</p><p>4. <strong>Prioriza:</strong> Paga primero la deuda en cÃ³digo que tocas SEGUIDO</p></div></div>",
      "codigo": "// âŒ DEUDA INVISIBLE (la peor)\n// TODO: arreglar esto algÃºn dÃ­a\n\n// âœ… DEUDA VISIBLE\n// TODO [JIRA-1234]: Extraer a ValidadorService\n// RazÃ³n: Deadline Q1. Pagar en Q2.\n\n// NEGOCIAR CON PRODUCTO\nTech Lead: \"Cada sprint: 80% features, 20% deuda\"\nProducto: \"Â¿Por quÃ©?\"\nTech Lead: \"Sin esto, en 6 meses cada feature tardarÃ¡ el doble.\n            La deuda cobra intereses.\"",
      "frase": "Deuda tÃ©cnica cobra intereses. Visibiliza. Negocia 20%. Boy Scout."
    },
    {
      "id": 40,
      "categoria": "funcional",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es flatMap y cuÃ¡ndo usarlo?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Aplanador</p><p class='narrador'>map devuelve caja dentro de caja. flatMap las aplana...</p><div class='problema'><strong>ğŸ“¦ğŸ“¦ PROBLEMA con map:</strong><p><code>Optional&lt;Optional&lt;Cuenta&gt;&gt;</code></p><p>Â¡Caja dentro de caja!</p></div><div class='solucion'><strong>ğŸ“¦ flatMap:</strong><p>Aplana: una sola caja</p><p>Usa cuando tu funciÃ³n YA devuelve Optional/Stream/Mono</p></div><div class='regla'><strong>ğŸ¯ REGLA:</strong><p><code>map</code>: T â†’ R</p><p><code>flatMap</code>: T â†’ Optional&lt;R&gt; / Stream&lt;R&gt; / Mono&lt;R&gt;</p></div></div>",
      "codigo": "// MAP - FunciÃ³n simple\nOptional<String> nombre = cuenta.map(Cuenta::getNombre);\n// T -> R\n\n// FLATMAP - FunciÃ³n que ya devuelve Optional\nOptional<Cuenta> cuenta = usuario\n    .flatMap(u -> repo.findCuentaPrincipal(u.getId()));\n// T -> Optional<R> ... aplanado a Optional<R>\n\n// EN STREAMS - Aplanar listas\nList<Movimiento> todos = cuentas.stream()\n    .flatMap(c -> c.getMovimientos().stream())  // Stream<Stream> â†’ Stream\n    .collect(toList());\n\n// EN REACTIVO\nMono<Saldo> saldo = cuentaMono\n    .flatMap(c -> saldoService.calcular(c.getId()));  // Mono<Mono> â†’ Mono",
      "frase": "map=transforma. flatMap=transforma Y aplana. Usa con funciones que ya envuelven."
    },
    {
      "id": 41,
      "categoria": "patrones",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es Arquitectura MonolÃ­tica?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Edificio de Un Solo Bloque</p><p class='narrador'>En los 90s, todo era mÃ¡s simple... o eso creÃ­amos.</p><div class='historia'><p><strong>ğŸ¢ EL MONOLITO:</strong></p><p>Imagina un edificio donde TODO estÃ¡ junto: banco, restaurante, gym, cine, hospital. Una sola construcciÃ³n gigante.</p><p><em>\"Â¿Quieres agregar una piscina? Hay que cerrar TODO el edificio para remodelar.\"</em></p></div><div class='caracteristicas'><p><strong>âœ… VENTAJAS:</strong></p><p>â€¢ Simple de desarrollar al inicio</p><p>â€¢ Un solo deploy, una sola BD</p><p>â€¢ FÃ¡cil de debuggear (todo en un lugar)</p><p><strong>âŒ PROBLEMAS:</strong></p><p>â€¢ Escalar = escalar TODO (aunque solo un mÃ³dulo tenga carga)</p><p>â€¢ Deploy de un fix = redesplegar TODO</p><p>â€¢ El cÃ³digo se vuelve espagueti con el tiempo</p><p>â€¢ Un bug puede tumbar TODO</p></div><div class='cuando'><p><strong>ğŸ¯ ÃšSALO CUANDO:</strong> MVP, startup pequeÃ±a, equipo de 3-5 devs. DespuÃ©s... migra.</p></div></div>",
      "codigo": "// MONOLITO TÃPICO\nbanco-app/\nâ”œâ”€â”€ src/\nâ”‚   â”œâ”€â”€ cuentas/\nâ”‚   â”œâ”€â”€ transferencias/\nâ”‚   â”œâ”€â”€ prestamos/\nâ”‚   â”œâ”€â”€ tarjetas/\nâ”‚   â””â”€â”€ notificaciones/\nâ”œâ”€â”€ application.properties  # UNA config\nâ””â”€â”€ pom.xml                 # UN artefacto\n\n# UN SOLO JAR\nmvn package â†’ banco-app.jar\njava -jar banco-app.jar  # TODO junto",
      "frase": "Monolito: simple al inicio, pesadilla despuÃ©s. Bueno para MVP, malo para escalar."
    },
    {
      "id": 42,
      "categoria": "patrones",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es Arquitectura de Microservicios?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La Ciudad de Servicios Independientes</p><p class='narrador'>El monolito creciÃ³ tanto que ya nadie lo entendÃ­a. Entonces naciÃ³ una nueva era...</p><div class='historia'><p><strong>ğŸ˜ï¸ MICROSERVICIOS:</strong></p><p>En vez de UN edificio gigante, construyes una CIUDAD. Cada servicio es un edificio independiente.</p><p>â€¢ <strong>ms-cuentas:</strong> Solo maneja cuentas</p><p>â€¢ <strong>ms-transferencias:</strong> Solo transfiere</p><p>â€¢ <strong>ms-notificaciones:</strong> Solo notifica</p><p><em>\"Â¿Se cae notificaciones? El resto sigue funcionando.\"</em></p></div><div class='reglas'><p><strong>ğŸ“ REGLAS DE ORO:</strong></p><p>1. Cada servicio tiene SU propia BD (no comparten)</p><p>2. Se comunican por HTTP/REST o eventos</p><p>3. Cada equipo es dueÃ±o de su servicio</p><p>4. Deploy independiente</p></div><div class='precio'><p><strong>ğŸ’° EL PRECIO:</strong> MÃ¡s complejidad operacional. Necesitas: API Gateway, Service Discovery, Config Server, Observabilidad...</p></div></div>",
      "codigo": "// ARQUITECTURA MICROSERVICIOS\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ API Gateway â”‚  â† Entrada Ãºnica\nâ””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜\n       â”‚\nâ”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚             â”‚              â”‚             â”‚\nâ–¼             â–¼              â–¼             â–¼\nâ”Œâ”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”\nâ”‚ ms- â”‚   â”‚ ms- â”‚      â”‚ ms- â”‚      â”‚ ms- â”‚\nâ”‚cuen-â”‚   â”‚transâ”‚      â”‚pres-â”‚      â”‚noti-â”‚\nâ”‚ tas â”‚   â”‚ fer â”‚      â”‚tamosâ”‚      â”‚ fic â”‚\nâ””â”€â”€â”¬â”€â”€â”˜   â””â”€â”€â”¬â”€â”€â”˜      â””â”€â”€â”¬â”€â”€â”˜      â””â”€â”€â”¬â”€â”€â”˜\n   â”‚         â”‚            â”‚            â”‚\n   â–¼         â–¼            â–¼            â–¼\n [BD1]    [BD2]        [BD3]        [BD4]\n\n# Cada uno es un repo, un deploy, un equipo",
      "frase": "Microservicios: independencia total. MÃ¡s poder, mÃ¡s responsabilidad."
    },
    {
      "id": 43,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es Arquitectura Hexagonal?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Castillo con Puentes Levadizos</p><p class='narrador'>El arquitecto estaba harto. Cada vez que cambiaba la BD, TODO el cÃ³digo se rompÃ­a...</p><div class='problema'><p><strong>ğŸ˜± EL PROBLEMA:</strong></p><p>Tu lÃ³gica de negocio estaba AMARRADA a PostgreSQL, a Spring, a Kafka.</p><p>Â¿Quieres cambiar de BD? Reescribes TODO.</p></div><div class='solucion'><p><strong>ğŸ° ARQUITECTURA HEXAGONAL (Ports & Adapters):</strong></p><p>Tu negocio es el CASTILLO. EstÃ¡ en el centro, protegido.</p><p>Los PUERTOS son las puertas del castillo (interfaces).</p><p>Los ADAPTADORES son los puentes que conectan con el mundo exterior.</p><p><em>\"El castillo no sabe si afuera hay PostgreSQL o MongoDB. Solo conoce el puerto.\"</em></p></div><div class='capas'><p><strong>ğŸ¯ LAS 3 CAPAS:</strong></p><p>â€¢ <strong>DOMAIN:</strong> Tu negocio puro (Cuenta, Transferencia). SIN dependencias externas.</p><p>â€¢ <strong>APPLICATION:</strong> Casos de uso (TransferirDineroUseCase)</p><p>â€¢ <strong>INFRASTRUCTURE:</strong> Adaptadores (PostgresRepo, KafkaPublisher, RestController)</p></div></div>",
      "codigo": "// ESTRUCTURA HEXAGONAL\ncom.banco.transferencias/\nâ”œâ”€â”€ domain/                    # ğŸ° EL CASTILLO (negocio puro)\nâ”‚   â”œâ”€â”€ model/\nâ”‚   â”‚   â”œâ”€â”€ Cuenta.java\nâ”‚   â”‚   â””â”€â”€ Transferencia.java\nâ”‚   â””â”€â”€ port/                  # ğŸšª PUERTOS (interfaces)\nâ”‚       â”œâ”€â”€ in/\nâ”‚       â”‚   â””â”€â”€ TransferirDineroUseCase.java\nâ”‚       â””â”€â”€ out/\nâ”‚           â”œâ”€â”€ CuentaRepositoryPort.java\nâ”‚           â””â”€â”€ EventPublisherPort.java\nâ”‚\nâ”œâ”€â”€ application/               # ğŸ“‹ CASOS DE USO\nâ”‚   â””â”€â”€ TransferirDineroService.java\nâ”‚\nâ””â”€â”€ infrastructure/            # ğŸŒ‰ ADAPTADORES\n    â”œâ”€â”€ in/\n    â”‚   â””â”€â”€ rest/TransferenciaController.java\n    â””â”€â”€ out/\n        â”œâ”€â”€ persistence/PostgresCuentaAdapter.java\n        â””â”€â”€ messaging/KafkaEventAdapter.java",
      "frase": "Hexagonal: el negocio en el centro, infraestructura afuera. Cambia BD sin tocar lÃ³gica."
    },
    {
      "id": 44,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es Arquitectura Event-Driven?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Banco que Habla con Eventos</p><p class='narrador'>En el banco tenÃ­amos un problema: los servicios se llamaban entre sÃ­ y cuando uno se caÃ­a, TODO fallaba...</p><div class='antes'><p><strong>âŒ ANTES (SÃ­ncrono):</strong></p><p>Transferencia â†’ llama a â†’ Cuentas â†’ llama a â†’ Notificaciones</p><p>Si Notificaciones se cae, la transferencia FALLA. El cliente furioso.</p></div><div class='despues'><p><strong>âœ… DESPUÃ‰S (Event-Driven con Event Hub):</strong></p><p>Transferencia PUBLICA evento: <code>TransferenciaRealizada</code></p><p>Cuentas CONSUME y actualiza saldos</p><p>Notificaciones CONSUME y envÃ­a SMS</p><p>AuditorÃ­a CONSUME y guarda log</p><p><em>\"Cada quien consume cuando puede. Si Notificaciones estÃ¡ caÃ­do, cuando vuelva procesa los eventos pendientes.\"</em></p></div><div class='componentes'><p><strong>ğŸ”§ EN AZURE:</strong></p><p>â€¢ <strong>Event Hub:</strong> El canal donde publicas eventos</p><p>â€¢ <strong>Producer:</strong> Quien publica (ms-transferencias)</p><p>â€¢ <strong>Consumer Group:</strong> Quien consume (ms-notificaciones)</p><p>â€¢ <strong>Partition:</strong> Para paralelismo</p></div></div>",
      "codigo": "// PRODUCER - Publica evento al Event Hub\n@Service\npublic class TransferenciaService {\n    @Autowired\n    private EventHubProducerClient producer;\n    \n    public void transferir(TransferenciaRequest req) {\n        // 1. Ejecuta transferencia\n        Transferencia tx = ejecutar(req);\n        \n        // 2. PUBLICA EVENTO (fire and forget)\n        EventData evento = new EventData(toJson(new TransferenciaRealizada(\n            tx.getId(), tx.getOrigen(), tx.getDestino(), tx.getMonto()\n        )));\n        producer.send(Collections.singletonList(evento));\n    }\n}\n\n// CONSUMER - Escucha eventos\n@Service\npublic class NotificacionConsumer {\n    @EventHubListener(eventHub = \"transferencias\", consumerGroup = \"notif\")\n    public void onTransferencia(TransferenciaRealizada evento) {\n        smsService.enviar(evento.getDestino(), \"Recibiste \" + evento.getMonto());\n    }\n}",
      "frase": "Event-Driven: publica y olvida. Desacoplamiento total. Si un consumer cae, luego se recupera."
    },
    {
      "id": 45,
      "categoria": "patrones",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es TDD (Test-Driven Development)?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Arquitecto que Construye al RevÃ©s</p><p class='narrador'>En una constructora normal, primero construyes la casa y luego verificas si estÃ¡ bien. Pero habÃ­a un arquitecto loco que hacÃ­a algo diferente...</p><div class='loco'><p><strong>ğŸ¤ª EL ARQUITECTO LOCO:</strong></p><p><em>\"Primero escribo la PRUEBA de que la casa soporta un terremoto. La prueba FALLA porque no hay casa. LUEGO construyo la casa hasta que la prueba pase.\"</em></p></div><div class='ciclo'><p><strong>ğŸ”„ EL CICLO SAGRADO: RED â†’ GREEN â†’ REFACTOR</strong></p><p>ğŸ”´ <strong>RED:</strong> Escribe el test. FALLA (no hay cÃ³digo).</p><p>ğŸŸ¢ <strong>GREEN:</strong> Escribe el cÃ³digo MÃNIMO para que pase.</p><p>ğŸ”µ <strong>REFACTOR:</strong> Limpia el cÃ³digo sin romper el test.</p><p>ğŸ” Repite.</p></div><div class='beneficio'><p><strong>âœ¨ Â¿POR QUÃ‰ FUNCIONA?</strong></p><p>â€¢ El test documenta quÃ© hace el cÃ³digo</p><p>â€¢ Nunca escribes cÃ³digo innecesario</p><p>â€¢ Refactorizas con confianza (el test te protege)</p><p>â€¢ Bugs detectados EN DESARROLLO, no en PROD</p></div></div>",
      "codigo": "// ğŸ”´ RED - Escribo el test PRIMERO (falla, no existe el cÃ³digo)\n@Test\nvoid debeRechazarTransferenciaSinSaldo() {\n    Cuenta cuenta = new Cuenta(\"123\", new BigDecimal(\"100\"));\n    \n    assertThrows(SaldoInsuficienteException.class, () -> {\n        cuenta.debitar(new BigDecimal(\"500\"));  // No hay suficiente\n    });\n}\n// âŒ FALLA - Cuenta.debitar() no existe\n\n// ğŸŸ¢ GREEN - CÃ³digo MÃNIMO para que pase\npublic void debitar(BigDecimal monto) {\n    if (monto.compareTo(saldo) > 0) {\n        throw new SaldoInsuficienteException();\n    }\n    this.saldo = saldo.subtract(monto);\n}\n// âœ… PASA\n\n// ğŸ”µ REFACTOR - Limpio sin romper test\npublic void debitar(Monto monto) {\n    validarSaldoSuficiente(monto);\n    this.saldo = saldo.restar(monto);\n}",
      "frase": "TDD: Test PRIMERO, cÃ³digo DESPUÃ‰S. Red â†’ Green â†’ Refactor. Nunca al revÃ©s."
    },
    {
      "id": 46,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿QuÃ© es DDD (Domain-Driven Design) y sus building blocks?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Traductor entre Negocio y CÃ³digo</p><p class='narrador'>En el BCP habÃ­a un problema grave: los desarrolladores hablaban de \"entities\" y \"repositories\", pero el negocio hablaba de \"cuentas\" y \"transferencias\". Nadie se entendÃ­a...</p><div class='revelacion'><p><strong>ğŸ’¡ DDD = El cÃ³digo HABLA el idioma del negocio</strong></p><p>No mÃ¡s traducciÃ³n. Si el negocio dice \"Cuenta\", el cÃ³digo tiene <code>class Cuenta</code>.</p></div><div class='blocks'><p><strong>ğŸ§± LOS BUILDING BLOCKS:</strong></p><p><strong>ğŸ“¦ ENTITY:</strong> Tiene identidad Ãºnica. Dos cuentas con mismo saldo NO son iguales si tienen diferente ID.</p><p><strong>ğŸ“‹ VALUE OBJECT:</strong> Sin identidad. Dos <code>Monto(100)</code> SON iguales. Inmutables.</p><p><strong>ğŸ›ï¸ AGGREGATE:</strong> Grupo que se modifica JUNTO. Cuenta + sus Movimientos. Solo accedes por la RAÃZ (Cuenta).</p><p><strong>ğŸšª REPOSITORY:</strong> Guarda y recupera Aggregates. <code>cuentaRepository.findById()</code></p><p><strong>âš¡ DOMAIN EVENT:</strong> Algo que PASÃ“. <code>TransferenciaRealizada</code>.</p><p><strong>ğŸ”§ DOMAIN SERVICE:</strong> LÃ³gica que no pertenece a ninguna Entity. <code>TransferenciaService</code>.</p></div><div class='bounded'><p><strong>ğŸ—ºï¸ BOUNDED CONTEXT:</strong> Cada departamento tiene su propio \"idioma\". En Ventas, Cliente tiene telÃ©fono. En FacturaciÃ³n, Cliente tiene RUC. Son DIFERENTES Clientes.</p></div></div>",
      "codigo": "// ğŸ“¦ ENTITY - Tiene ID\n@Entity\npublic class Cuenta {\n    @Id\n    private CuentaId id;  // Identidad Ãºnica\n    private Saldo saldo;\n    private List<Movimiento> movimientos;\n    \n    // LÃ³gica de NEGOCIO vive aquÃ­\n    public DomainEvent debitar(Monto monto) {\n        if (saldo.menorQue(monto)) \n            throw new SaldoInsuficienteException();\n        saldo = saldo.restar(monto);\n        return new CuentaDebitada(id, monto, Instant.now());\n    }\n}\n\n// ğŸ“‹ VALUE OBJECT - Inmutable, sin ID\npublic record Monto(BigDecimal valor) {\n    public Monto {\n        if (valor.compareTo(ZERO) < 0) \n            throw new MontoInvalidoException();\n    }\n}\n\n// âš¡ DOMAIN EVENT\npublic record CuentaDebitada(CuentaId id, Monto monto, Instant cuando) {}",
      "frase": "DDD: el cÃ³digo habla negocio. Entity=identidad. Value Object=valor. Aggregate=grupo. Event=pasÃ³."
    },
    {
      "id": 47,
      "categoria": "patrones",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es Clean Architecture?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: Las Capas de la Cebolla</p><p class='narrador'>Uncle Bob estaba harto. Cada vez que cambiaba el framework, TODO el cÃ³digo se rompÃ­a. Entonces dibujÃ³ una cebolla...</p><div class='cebolla'><p><strong>ğŸ§… LA CEBOLLA DE CLEAN ARCHITECTURE:</strong></p><p>Capas concÃ©ntricas. Las de ADENTRO no conocen a las de AFUERA.</p></div><div class='capas'><p>ğŸ¯ <strong>CENTRO - ENTITIES:</strong> Tu negocio puro. Cuenta, Transferencia. SIN dependencias.</p><p>ğŸ“‹ <strong>USE CASES:</strong> QuÃ© puede hacer tu sistema. TransferirDineroUseCase.</p><p>ğŸ”Œ <strong>ADAPTERS:</strong> Traductores. Controllers, Presenters, Gateways.</p><p>ğŸŒ <strong>FRAMEWORKS:</strong> El mundo exterior. Spring, PostgreSQL, Kafka.</p></div><div class='regla'><p><strong>ğŸ“ LA REGLA DE ORO:</strong></p><p>Las dependencias SIEMPRE apuntan hacia ADENTRO.</p><p>âŒ Entity NO importa Spring</p><p>âŒ UseCase NO importa PostgreSQL</p><p>âœ… PostgresAdapter importa UseCase (implementa interfaz)</p></div></div>",
      "codigo": "// ğŸ¯ ENTITIES (centro, sin dependencias)\npackage com.banco.domain;\npublic class Cuenta { }  // CERO imports de frameworks\n\n// ğŸ“‹ USE CASES (solo conoce entities)\npackage com.banco.application;\npublic class TransferirDineroUseCase {\n    private final CuentaRepository repo;  // INTERFAZ, no implementaciÃ³n\n    \n    public void execute(TransferirCommand cmd) {\n        Cuenta origen = repo.findById(cmd.origen());\n        origen.debitar(cmd.monto());\n        repo.save(origen);\n    }\n}\n\n// ğŸ”Œ ADAPTERS (implementa interfaces del centro)\npackage com.banco.infrastructure;\n@Repository\npublic class PostgresCuentaRepository implements CuentaRepository {\n    @Autowired\n    private JpaRepository jpa;  // AquÃ­ SÃ conoce Spring\n}",
      "frase": "Clean Architecture: dependencias hacia adentro. El negocio NO conoce frameworks."
    },
    {
      "id": 48,
      "categoria": "patrones",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© es Arquitectura en Capas (Layered)?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Edificio de 3 Pisos</p><p class='narrador'>La arquitectura mÃ¡s comÃºn y simple. Como un edificio donde cada piso tiene su funciÃ³n...</p><div class='pisos'><p><strong>ğŸ¢ LOS 3 PISOS CLÃSICOS:</strong></p><p>ğŸ–¥ï¸ <strong>PISO 3 - PRESENTATION:</strong> Lo que ve el usuario. Controllers, Views, DTOs.</p><p>âš™ï¸ <strong>PISO 2 - BUSINESS/SERVICE:</strong> La lÃ³gica. Validaciones, cÃ¡lculos, reglas.</p><p>ğŸ’¾ <strong>PISO 1 - DATA/PERSISTENCE:</strong> Acceso a BD. Repositories, DAOs.</p></div><div class='regla'><p><strong>ğŸ“ REGLA:</strong> Cada piso SOLO habla con el de abajo.</p><p>Controller â†’ Service â†’ Repository</p><p>âŒ Controller NO llama directo a Repository</p></div><div class='problema'><p><strong>âš ï¸ EL PROBLEMA:</strong></p><p>El negocio (Service) depende de la BD (Repository).</p><p>Por eso nacieron Hexagonal y Clean Architecture: invertir esa dependencia.</p></div></div>",
      "codigo": "// ğŸ–¥ï¸ PRESENTATION LAYER\n@RestController\n@RequestMapping(\"/api/cuentas\")\npublic class CuentaController {\n    @Autowired\n    private CuentaService service;  // Solo conoce Service\n    \n    @GetMapping(\"/{id}\")\n    public CuentaDTO get(@PathVariable String id) {\n        return service.buscar(id);\n    }\n}\n\n// âš™ï¸ SERVICE LAYER\n@Service\npublic class CuentaService {\n    @Autowired\n    private CuentaRepository repo;  // Solo conoce Repository\n    \n    public CuentaDTO buscar(String id) {\n        Cuenta cuenta = repo.findById(id).orElseThrow();\n        return toDTO(cuenta);\n    }\n}\n\n// ğŸ’¾ DATA LAYER\n@Repository\npublic interface CuentaRepository extends JpaRepository<Cuenta, String> { }",
      "frase": "Layered: Controller â†’ Service â†’ Repository. Simple pero el negocio depende de BD."
    },
    {
      "id": 49,
      "categoria": "patrones",
      "dificultad": "lead",
      "pregunta": "Â¿CuÃ¡l es la diferencia entre BDD y TDD?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: El Developer y el Product Owner</p><p class='narrador'>El developer escribÃ­a tests tÃ©cnicos que nadie entendÃ­a. El PO preguntaba: \"Â¿Pero hace lo que pedÃ­?\"...</p><div class='tdd'><p><strong>ğŸ”§ TDD (Test-Driven Development):</strong></p><p>Escrito por DEVELOPERS, para DEVELOPERS.</p><p><code>@Test void shouldThrowExceptionWhenInsufficientBalance()</code></p><p>TÃ©cnico. Prueba unidades de cÃ³digo.</p></div><div class='bdd'><p><strong>ğŸ“– BDD (Behavior-Driven Development):</strong></p><p>Escrito en LENGUAJE NATURAL. Negocio lo entiende.</p><p><code>GIVEN una cuenta con saldo 100</code></p><p><code>WHEN intento transferir 500</code></p><p><code>THEN debe rechazar con error \"Saldo insuficiente\"</code></p></div><div class='combo'><p><strong>ğŸ¯ EN LA PRÃCTICA:</strong></p><p>BDD para los casos de uso (el QUÃ‰).</p><p>TDD para la implementaciÃ³n (el CÃ“MO).</p><p>BDD con Cucumber/Gherkin. TDD con JUnit.</p></div></div>",
      "codigo": "// ğŸ“– BDD con CUCUMBER (Gherkin)\n# transferencias.feature\nFeature: Transferencias bancarias\n\n  Scenario: Rechazar transferencia sin saldo\n    Given una cuenta \"123\" con saldo 100 soles\n    When intento transferir 500 soles a cuenta \"456\"\n    Then la transferencia es rechazada\n    And el mensaje es \"Saldo insuficiente\"\n\n// ğŸ”§ TDD con JUNIT\n@Test\nvoid debeRechazarTransferenciaSinSaldo() {\n    Cuenta cuenta = new Cuenta(\"123\", saldo(100));\n    \n    var ex = assertThrows(SaldoInsuficienteException.class,\n        () -> cuenta.debitar(monto(500)));\n    \n    assertEquals(\"Saldo insuficiente\", ex.getMessage());\n}",
      "frase": "BDD=lenguaje negocio (Given/When/Then). TDD=lenguaje tÃ©cnico. Usa ambos."
    },
    {
      "id": 50,
      "categoria": "patrones",
      "dificultad": "senior",
      "pregunta": "Â¿QuÃ© tipos de tests existen?",
      "respuesta": "<div class='pildora'><p class='escena'>ğŸ¬ ESCENA: La PirÃ¡mide de Tests</p><p class='narrador'>En el banco tenÃ­amos 1000 tests E2E que tardaban 4 horas. Un dÃ­a, el arquitecto dibujÃ³ una pirÃ¡mide...</p><div class='piramide'><p><strong>ğŸ”º LA PIRÃMIDE DE TESTS:</strong></p><p>MÃ¡s tests abajo, menos arriba.</p></div><div class='niveles'><p>ğŸ”µ <strong>BASE - UNIT TESTS (70%):</strong></p><p>Prueban UNA clase aislada. Mocks para dependencias. RÃPIDOS. Segundos.</p><p>ğŸŸ¡ <strong>MEDIO - INTEGRATION TESTS (20%):</strong></p><p>Prueban varias clases juntas. BD real (TestContainers). Minutos.</p><p>ğŸ”´ <strong>CIMA - E2E / UI TESTS (10%):</strong></p><p>Prueban TODO el flujo. Selenium, Cypress. LENTOS. FrÃ¡giles.</p></div><div class='regla'><p><strong>ğŸ“ REGLA:</strong></p><p>Si tus E2E tardan horas, tu pirÃ¡mide estÃ¡ invertida.</p><p>80% de bugs se detectan con unit tests bien escritos.</p></div></div>",
      "codigo": "// ğŸ”µ UNIT TEST (rÃ¡pido, aislado)\n@Test\nvoid debeCalcularInteres() {\n    Cuenta cuenta = new Cuenta(saldo(1000));\n    \n    BigDecimal interes = cuenta.calcularInteres(tasa(0.05));\n    \n    assertEquals(new BigDecimal(\"50\"), interes);\n}\n\n// ğŸŸ¡ INTEGRATION TEST (con BD real)\n@SpringBootTest\n@Testcontainers\nclass CuentaRepositoryIT {\n    @Container\n    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:15\");\n    \n    @Test\n    void debeGuardarYRecuperar() {\n        Cuenta cuenta = new Cuenta(\"123\", saldo(1000));\n        repo.save(cuenta);\n        \n        Cuenta found = repo.findById(\"123\").orElseThrow();\n        assertEquals(saldo(1000), found.getSaldo());\n    }\n}\n\n// ğŸ”´ E2E TEST (Selenium/Cypress - evitar muchos)\n// cy.visit('/login')\n// cy.get('#user').type('admin')\n// cy.get('#pass').type('123')\n// cy.get('#submit').click()\n// cy.url().should('include', '/dashboard')",
      "frase": "PirÃ¡mide: 70% Unit, 20% Integration, 10% E2E. Invertida = dolor."
    }
  ]
}
